<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | 李阳的秘密小屋</title><meta name="author" content="李阳"><meta name="copyright" content="李阳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考郝斌，王卓老师的C语言版数据结构 后序会再更新">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://lyay23.github.io/posts/79666db/index.html">
<meta property="og:site_name" content="李阳的秘密小屋">
<meta property="og:description" content="参考郝斌，王卓老师的C语言版数据结构 后序会再更新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lyay23.github.io/img/bg_4.png">
<meta property="article:published_time" content="2024-11-20T13:34:21.000Z">
<meta property="article:modified_time" content="2024-11-21T14:55:21.058Z">
<meta property="article:author" content="李阳">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lyay23.github.io/img/bg_4.png"><link rel="shortcut icon" href="/img/favicon-48.png"><link rel="canonical" href="http://lyay23.github.io/posts/79666db/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/aplayer.css"><link rel="stylesheet" href="/css/APlayer.min.css"><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="李阳的秘密小屋" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw icon-taiyang"></i><span> 小世界</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg_4.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">数据结构</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw icon-taiyang"></i><span> 小世界</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-20T13:34:21.000Z" title="发表于 2024-11-20 21:34:21">2024-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-21T14:55:21.058Z" title="更新于 2024-11-21 22:55:21">2024-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="waline-pageview-count" data-path="/posts/79666db/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C语言—数据结构"><a href="#C语言—数据结构" class="headerlink" title="C语言—数据结构"></a>C语言—数据结构</h1><p>———————————————————-内容参考《郝斌数据结构》，《王道》《王卓》</p>
<span id="more"></span>
<h2 id="一、数据结构之基础"><a href="#一、数据结构之基础" class="headerlink" title="一、数据结构之基础"></a>一、数据结构之基础</h2><h3 id="1-数据结构的三要素"><a href="#1-数据结构的三要素" class="headerlink" title="1.数据结构的三要素"></a>1.数据结构的三要素</h3><p><img src="/posts/79666db/image-20240911162821303-1731069393910-1.png" alt></p>
<p>1.若采用顺序存储，则各个数据元素在物理上必须是连续的;若采用非顺序存储，则各个数据元素在物理上可以是离散的。<br>2.数据的存储结构会影响存储空间分配的方便程度<br>3数椐的存储结构会影响对数据运算的速度</p>
<p><img src="/posts/79666db/image-20241009153911315-1731069393910-2.png" alt="image-20241009153911315"></p>
<h4 id="数据的存储结构有几种"><a href="#数据的存储结构有几种" class="headerlink" title="数据的存储结构有几种"></a><strong>数据的存储结构有几种</strong></h4><p>​    线性</p>
<p>​          连续存储（数组）</p>
<p>​                   优点：存储速度很快</p>
<p>​                   缺点：插入和删除元素很慢，空间通常是有限的</p>
<p>​           离散存储（链表）</p>
<p>​                    优点：空间没有限制，插入删除元素很快</p>
<p>​                    缺点：存取速度很慢</p>
<h3 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><p><img src="/posts/79666db/image-20240911163008131-1731069393910-3.png" alt="image-20240911163008131"></p>
<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>顺序存储,把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>链式存储，逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。（指针链接指针）</p>
<h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p>索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)离散的</p>
<h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><p>散列存储。根据元素的夭键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p>
<h3 id="3-算法特征："><a href="#3-算法特征：" class="headerlink" title="3.算法特征："></a>3.算法特征：</h3><p>确定性，可行性，输入，输出</p>
<h4 id="好算法特征："><a href="#好算法特征：" class="headerlink" title="好算法特征："></a>好算法特征：</h4><p>正确性，可读性，健壮性，高效率与低存储需求（时间，空间复杂度低）</p>
<p><img src="/posts/79666db/image-20240911172342285-1731069393910-4.png" alt="image-20240911172342285"></p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1-数组的优缺点："><a href="#1-数组的优缺点：" class="headerlink" title="1.数组的优缺点："></a>1.数组的优缺点：</h3><p>优点：存储速度快</p>
<p>缺点：需要一个连续很大的内存，插入和删除元素的效率很低</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>优点：插入 删除元素效率高，不需要一个连续的很大内存</p>
<p>缺点：查找某个元素的效率低</p>
<h3 id="3-术语："><a href="#3-术语：" class="headerlink" title="3.术语："></a>3.术语：</h3><h4 id="首节点"><a href="#首节点" class="headerlink" title="首节点"></a><strong>首节点</strong></h4><ul>
<li>存放第一个有效数据的节点</li>
</ul>
<h4 id="尾节点"><a href="#尾节点" class="headerlink" title="尾节点"></a><strong>尾节点</strong></h4><ul>
<li>存放最后一个元素的有效数据节点</li>
</ul>
<h4 id="头结点："><a href="#头结点：" class="headerlink" title="头结点："></a><strong>头结点：</strong></h4><ol>
<li>头结点的数据类型和首节点的类型是一样的</li>
<li>头结点是首结点前面的那个节点</li>
<li>头结点里面不存放有效数据</li>
<li>设置结点是为了方便对链表经行操作</li>
</ol>
<h4 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a><strong>头指针</strong></h4><ul>
<li>存放头结点的地址的指针变量</li>
<li>可以通过头指针推算出链表的其他信息</li>
</ul>
<h3 id="4-链表的定义"><a href="#4-链表的定义" class="headerlink" title="4.链表的定义"></a>4.链表的定义</h3><ul>
<li>n个节点离散分配</li>
<li>彼此通过指针相连接</li>
<li>每个节点只有一个前驱节点和后驱节点</li>
<li>首节点没有前驱节点，  尾节点没有后续节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> date;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,*pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-分类："><a href="#5-分类：" class="headerlink" title="5.分类："></a>5.分类：</h3><ul>
<li><p>单链表</p>
</li>
<li><p>双链表</p>
<p>​        每一个节点都有两个指针域</p>
</li>
<li><p>循环链表</p>
<p>​       能通过任何一个节点找到其他所有节点</p>
</li>
<li><p>非循环链表</p>
</li>
</ul>
<h3 id="6-算法"><a href="#6-算法" class="headerlink" title="6.算法"></a>6.算法</h3><p>遍历</p>
<p>查找</p>
<p>清空</p>
<p>销毁</p>
<p>排序</p>
<p>删除节点</p>
<p>插入节点 </p>
<h3 id="7-创建带头单链表并遍历输出"><a href="#7-创建带头单链表并遍历输出" class="headerlink" title="7.创建带头单链表并遍历输出"></a>7.创建带头单链表并遍历输出</h3><p>郝斌老师代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义单链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（带头）</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-※链表的基本操作※"><a href="#8-※链表的基本操作※" class="headerlink" title="8.※链表的基本操作※"></a>8.※链表的基本操作※</h3><p>郝斌老师代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之单链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode,<span class="type">int</span> ,<span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //判断链表是否为空</span></span><br><span class="line"><span class="comment">    if(is_empty(pHead))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表为空！\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表不空");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //返回链表长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int len= length_list(pHead);</span></span><br><span class="line"><span class="comment">    printf("链表长度是 %d\n",len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //排序</span></span><br><span class="line"><span class="comment">    printf("从小到大排序后的代码是：\n");</span></span><br><span class="line"><span class="comment">    sort_list(pHead);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //插入</span></span><br><span class="line"><span class="comment">    insert_list(pHead,3,44);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //删除</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    if(delete_list(pHead,3,&amp;val))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("删除成功，您删除的元素是%d\n",val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    } else</span></span><br><span class="line"><span class="comment">        printf("删除未成功\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead-&gt;pNext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将头节点的地址给他</span></span><br><span class="line">    <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p)<span class="comment">//如果这里面是空的</span></span><br><span class="line">    {</span><br><span class="line">        ++len;<span class="comment">//++</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向下一个元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i,j,t;</span><br><span class="line"><span class="type">int</span> len = length_list(pHead);</span><br><span class="line">pNode p,q;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>,p=pHead-&gt;pNext; i &lt;len<span class="number">-1</span> ; ++i,p=p-&gt;pNext) {<span class="comment">//p放的是第一个元素，</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>,q=p-&gt;pNext; j &lt;len ; ++j,q=q-&gt;pNext) {<span class="comment">//q放的是p的后面的一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            {</span><br><span class="line">                t=p-&gt;data;</span><br><span class="line">                p-&gt;data=q-&gt;data;</span><br><span class="line">                q-&gt;data=t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入--在第pos的前面插入一个新的节点val，pos从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNew -&gt;data=val;<span class="comment">//定义了一个新节点，将val先放进去</span></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//p此时已经来到了pos-1的地方，也就是他的前面，</span></span><br><span class="line">    p-&gt;pNext=pNew;<span class="comment">//将他的地址给pNew</span></span><br><span class="line">    pNew-&gt;pNext=q;<span class="comment">//再将pNew的下一元素的地址给next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> * pval)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p-&gt;pNext &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p-&gt;pNext)<span class="comment">//pos-1:eg:删除第3个必须要知道第二个</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//第pos个节点</span></span><br><span class="line">    *pval=q-&gt;data;<span class="comment">//将要删除的节点保存下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除p节点后面的节点</span></span><br><span class="line">    p-&gt;pNext=p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="9-李阳的线性表"><a href="#9-李阳的线性表" class="headerlink" title="9.李阳的线性表"></a>9.李阳的线性表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/11.--线性表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DateType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    DateType data[MAXNUM];<span class="comment">//定义了一个数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span> <span class="params">(SqList *L)</span>{</span><br><span class="line">      L-&gt;length=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType d)</span><span class="comment">//第i位置插入d</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;MAXNUM)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表满了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = L-&gt;length; k &gt;=i ; k--) <span class="comment">//依次向后移</span></span><br><span class="line">    {</span><br><span class="line">        L-&gt;data[k]=L-&gt;data[k<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=d;<span class="comment">//当用户输入在3的位置插入，其实是在索引2的位置，如果想</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//修改，可以将k&gt;=i改为k&gt;i即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListDelete</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType *d)</span><span class="comment">//删除第i个元素并保存在d中</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *d=L-&gt;data[i<span class="number">-1</span>];<span class="comment">//保存被删除的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;L-&gt;length;k++)<span class="comment">//找到被删除元素位置</span></span><br><span class="line">    {</span><br><span class="line">       L-&gt;data[k<span class="number">-1</span>]= L-&gt;data[k];<span class="comment">//向前移</span></span><br><span class="line">    }</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(SqList L)</span><span class="comment">//这里传的L而不是*L是值传递，不需要对数据进行修改</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,L.data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指定位置元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListUpdate</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找索引为i的指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListGit</span><span class="params">(SqList L,<span class="type">int</span> i,DateType *x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *x=L.data[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素的位置（返回第一个匹配元素的位置）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, DateType e)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回的是位置索引，从1开始计数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    SqList  L;</span><br><span class="line">    initList(&amp;L);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    ListInsert(&amp;L,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">    DateType d;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    ListDelete(&amp;L,<span class="number">2</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除的元素是：%d "</span>,d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="10-李阳的带头单链表"><a href="#10-李阳的带头单链表" class="headerlink" title="10.李阳的带头单链表"></a>10.李阳的带头单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/12.</span></span><br><span class="line"><span class="comment">//带头单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Node * <span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">     Node * head=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">instertATEnd</span><span class="params">(Node * head ,<span class="type">int</span> date)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode -&gt;data=date;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node *temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertATHead</span><span class="params">(Node * head,<span class="type">int</span>  data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=head-&gt;next;<span class="comment">//尾巴结点为NULL</span></span><br><span class="line">    head-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node * head)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node * head, <span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp;temp-&gt;next-&gt;data!=data)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        Node * current=temp-&gt;next;</span><br><span class="line">        temp-&gt;next=current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没找到哦"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(Node* head, <span class="type">int</span> index)</span> {</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; count &lt; index) {</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"索引 %d 越界\n"</span>, index);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 或者返回一个特殊值表示错误，比如 INT_MIN 或 -1（需要包含 &lt;limits.h&gt;）</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getListLength</span><span class="params">(Node* head)</span> {</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 不计算头结点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        length++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表内存的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(Node* head)</span> {</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 从头结点的下一个节点开始释放</span></span><br><span class="line">    Node* nextNode;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        nextNode = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">        current = nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(head); <span class="comment">// 最后释放头结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置添加数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList</span><span class="params">(Node * head,<span class="type">int</span> i,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode =(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊情况：在头部插入</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span> &amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != i - <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 位置超出链表长度</span></span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置超出链表长度\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=temp-&gt;next;</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引删除元素，并将值保存在data中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteList</span><span class="params">(Node* head,<span class="type">int</span> i,<span class="type">int</span> *data)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空，无法删除\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index!=i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      Node * current=temp-&gt;next;</span><br><span class="line">    *data=current-&gt;data;</span><br><span class="line"></span><br><span class="line">    temp-&gt;next=current-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Node * head=initList();</span><br><span class="line"></span><br><span class="line">    instertATEnd(head,<span class="number">1</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">2</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">3</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"尾插法"</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"头插法\n"</span>);</span><br><span class="line"></span><br><span class="line">    insertATHead(head,<span class="number">5</span>);</span><br><span class="line">    insertATHead(head,<span class="number">4</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    deleteNode(head,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="type">int</span> length = getListLength(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Linked list length: %d\n"</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​             一种可以实现“先进后出”的存储结构</p>
<p>​            栈类似于一个箱子，先放进去的后拿出来，后进去的先拿出来</p>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><p>   静态栈</p>
<p>   动态栈</p>
<h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h3><p>​      出栈</p>
<p>​      压栈</p>
<p>郝斌老师代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构之栈 o.O</span></span><br><span class="line"><span class="comment"> *  Created by 李阳 on 2024/10/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pNext</span>;</span></span><br><span class="line">}Node,*pNode;</span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    pNode pTop;<span class="comment">//元素顶部</span></span><br><span class="line">    pNode pBottom;<span class="comment">//元素底部</span></span><br><span class="line">}sTack,*pStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">   sTack S;<span class="comment">//sTack等价于 struct Stack--建立了一个名为S的成员变量，里面有两个元素，ptop和pbottom，里面暂时没有有效数据</span></span><br><span class="line"></span><br><span class="line">   initStack(&amp;S);<span class="comment">//初始化-造出空栈</span></span><br><span class="line">   pushStack(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">2</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">3</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">4</span>);<span class="comment">//压栈</span></span><br><span class="line"></span><br><span class="line">    traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    clear(&amp;S);</span><br><span class="line">   <span class="comment">// traverse(&amp;S);//输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>( popStack(&amp;S,&amp;val))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈成功，出栈的元素是：%d\n"</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈失败\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pS-&gt;pTop=(pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));<span class="comment">//将top指向一个新造的空节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pS-&gt;pTop)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pS-&gt;pBottom=pS-&gt;pTop;<span class="comment">//地址都指向空节点</span></span><br><span class="line">        pS-&gt;pTop-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//将新造的节点的指针域为空--因为他是最后一个元素的下一个元素，因此没有指针域</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈--进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pNode pNew=(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line">    pNew-&gt;data=val;</span><br><span class="line">    pNew-&gt;pNext=pS-&gt;pTop;<span class="comment">//此时ptoop里面放的是初始化时的临时变量地址，这里调用，将新建的栈的指针域指向初始化的元素地址</span></span><br><span class="line">    pS-&gt;pTop=pNew;<span class="comment">//再将新的节点地址给top</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pS-&gt;pTop;<span class="comment">//定义个临时指针变量p，将头的值给p，</span></span><br><span class="line">    <span class="keyword">while</span> (p!=pS-&gt;pBottom)<span class="comment">//当p为底部元素时程序终止</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向p的下一元素地址</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop==pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack pS,<span class="type">int</span> * pVal)</span><span class="comment">//把ps所指向的栈出栈一次，并将出栈元素存入pval新参所指向的变量中，成功返回true，否则false</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(empty(pS))</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">        pNode r=pS-&gt;pTop;<span class="comment">//定义一个变量r，将顶元素给r</span></span><br><span class="line">        *pVal=r-&gt;data;</span><br><span class="line">        pS-&gt;pTop=r-&gt;pNext;<span class="comment">//再将top指向下一元素，这样r就被孤立了</span></span><br><span class="line">         <span class="built_in">free</span>(r);</span><br><span class="line">         r=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    pNode p=pS-&gt;pTop;</span><br><span class="line">    pNode q=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=pS-&gt;pBottom)</span><br><span class="line">        {</span><br><span class="line">            q=p-&gt;pNext;<span class="comment">//q指向第二个</span></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p=q;<span class="comment">//p又指向了下一个元素了</span></span><br><span class="line">        }</span><br><span class="line">        pS-&gt;pTop=pS-&gt;pBottom;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>函数调用</p>
<p>中断</p>
<p>表达式求值</p>
<p>内存分配</p>
<p>缓存处理</p>
<p>迷宫</p>
<h3 id="5-栈的表达式求值—后缀表达式（逆波兰表达式）"><a href="#5-栈的表达式求值—后缀表达式（逆波兰表达式）" class="headerlink" title="5.栈的表达式求值—后缀表达式（逆波兰表达式）"></a>5.栈的表达式求值—后缀表达式（逆波兰表达式）</h3><p><strong>1.例如：1+2*3</strong></p>
<p>​     后缀表达式为 1 2 3 * +</p>
<p>​             遇到一个运算符他会在前面两个数字间运算 </p>
<ol>
<li>​          2 *3</li>
<li>然后向后移到+    </li>
<li>6+1</li>
</ol>
<p><strong>2、(a + b) * (c - (d / e)) + f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b + c d e / - * f +</span><br></pre></td></tr></table></figure>
<p><strong>3.、a * (b + c) - (d / e)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c + * d e / -</span><br></pre></td></tr></table></figure>
<p><strong>4、a + b * (c - d / e) ^ f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a b c d e / - f ^ * +</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 操作数和运算符</span><br><span class="line">操作数（如变量和常数）直接添加到输出列表中。</span><br><span class="line">运算符则需要根据优先级和括号来决定是否入栈、弹出或保持在栈中。</span><br><span class="line">2. 运算符优先级</span><br><span class="line">运算符的优先级从高到低一般为：</span><br><span class="line">* 和 / （乘法和除法）优先级高</span><br><span class="line">+ 和 - （加法和减法）优先级低</span><br><span class="line">在遇到相同优先级的运算符时，按照左结合性处理（从左到右）。</span><br><span class="line">3. 括号的处理</span><br><span class="line">遇到左括号 ( 时，直接入栈。</span><br><span class="line">遇到右括号 ) 时，弹出栈中的运算符到输出，直到遇到对应的左括号为止，左括号被丢弃。</span><br><span class="line">4. 栈的使用</span><br><span class="line">当一个运算符被处理时，检查栈顶运算符的优先级：</span><br><span class="line">如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</span><br><span class="line">否则，将当前运算符入栈。</span><br><span class="line">5. 表达式结束时的处理</span><br><span class="line">当整个中序表达式处理完毕后，仍有运算符在栈中时，将它们全部弹出到输出。</span><br><span class="line">6. 后缀表达式的特征</span><br><span class="line">后缀表达式不需要括号，因为运算符的顺序和位置已经明确了运算的优先级和关联性。</span><br></pre></td></tr></table></figure>
<p><strong>当一个运算符被处理时，检查栈顶运算符的优先级：</strong><br><strong>如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</strong><br><strong>否则，将当前运算符入栈。</strong></p>
<p>总结：</p>
<ul>
<li>栈底部的运算符永远是最低的</li>
<li>遇到括号先输出括号里的运算符，但不保留括号</li>
<li>当有刚入栈的运算符小于或等于当前栈中的运算符，那直接将栈出到小于此运算符的位置</li>
<li>来看个小例子吧：</li>
<li>1.当栈低为+或-时，来了个*或/时可以留着栈中，当此时又来了一个新运算符，假设为-，此时栈中的为+和<em>，那么将\</em>和+直接出栈，-再放入栈中</li>
<li>2.假设栈底运算符为<em>或者/，当入栈为+或-时，那么将\</em>或\出栈，将+或-压入栈底部</li>
<li>3.当栈低为+和<em>时，此时入栈了一个/那么将\</em>出栈，+留在栈中，/也压入栈中</li>
</ul>
<p>特别注意：* / ^的运算符是在两个运算的字母后的</p>
<p>例题：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">eg:1. (A + B) * (C - D) / E ^ F </span><br><span class="line"> 遇到括号左括号进栈A输出+进栈B输出，扫描到右括号+出栈，此时为AB+</span><br><span class="line"> *入栈，左括号入栈C输出-入栈D输出右括号出栈，此时变为AB+CD-,栈低为*</span><br><span class="line"> 扫描/入栈，因为/的优先级不大于*，因此*出栈，此时变为AB+CD-*，栈低为/</span><br><span class="line"> E输出，^进栈^的优先级不大于/要出栈，但是因为我们的运算符要相匹配，因此F输出在依次输出栈/^,这里E F ^ 表示 E 和 F 进行指数运算。/ 表示乘法结果除以 E F ^ 的结果</span><br><span class="line"> AB+CD-*EF/^</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2. A + B * (C ^ D - E) ^ F / G</span><br><span class="line">   输出A,+进栈，输出B，此时为AB，+在栈里面</span><br><span class="line">   扫描左括号入栈，C输出，^进栈D输出，-进栈，因为我们的-优先级低于^,所以^的位置上移动，出栈，E输出扫描到又括号^出栈，-出栈，栈低为+和*，此时为ABCD^E-</span><br><span class="line">   ^入栈,因为^的优先级不大于*，所以*出栈，^入栈，栈里为+^，F输出,/进栈，因为FG是个组合，所以输出*FG/^  </span><br><span class="line">   结果是ABCD^E-*FG/^  </span><br></pre></td></tr></table></figure>
<h3 id="6-后缀表达式转中缀"><a href="#6-后缀表达式转中缀" class="headerlink" title="6.后缀表达式转中缀"></a>6.后缀表达式转中缀</h3><p>我们学完了中缀转后缀下面来试一试后缀表达式转中缀吧！</p>
<p>我们先来看题吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AB+CD-*EF/^</span><br><span class="line"></span><br><span class="line">首先我们的ab进栈，这时我们扫描到运算符+，这时候就变成a+b，然后入栈（遇到运算符要与他的前两位进行计算）</span><br><span class="line">cd进栈，扫描到运算符-，就变成c-d然后入栈，此时栈里存放的是a+b 和c-d </span><br><span class="line">然后扫描到运算符* ，就变成 a+b * c-d ，因为我们左右两边是个整体，所以要加括号（a+b） * （c-d），然后再入栈</span><br><span class="line">EF进栈，扫描到/，就变成E/F,此时栈里存放的是（a+b） * （c-d） 和 （E/F）</span><br><span class="line">扫描到^ 就变成 （a+b） * （c-d） ^ （E/F）</span><br><span class="line">本题结束(●'◡'●)</span><br></pre></td></tr></table></figure>
<p>由此我们可以反推出 ：</p>
<p>字母总是两两存在的因此在中序转后缀需要考虑组合</p>
<p>后缀转中缀的是运算符之前的两位数字/字母进行计算</p>
<h3 id="7-李阳的栈"><a href="#7-李阳的栈" class="headerlink" title="7.李阳的栈"></a>7.李阳的栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式栈</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span>{</span></span><br><span class="line">    Node * top;<span class="comment">//栈顶指针，初始化为NULL表示空栈</span></span><br><span class="line">} LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedStack * <span class="title function_">initStack</span><span class="params">()</span>{</span><br><span class="line">    LinkedStack * <span class="built_in">stack</span>=(LinkedStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=<span class="literal">NULL</span>; <span class="comment">// 初始化栈顶指针为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top==<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * 解析：让我来为你解析吧！</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个链表，然后一个空栈，里面有一个top指向NULL</span></span><br><span class="line"><span class="comment"> * 然后我们传入一个元素假设为1</span></span><br><span class="line"><span class="comment"> * 然后newNode-&gt;next=stack-&gt;top;// 新节点的next指向当前栈顶</span></span><br><span class="line"><span class="comment">    stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> *这俩是核心代码 我们直接说这个</span></span><br><span class="line"><span class="comment"> * stack-&gt;top上面初始化为NULL</span></span><br><span class="line"><span class="comment"> * 所以newNode-&gt;next里面就是NULL</span></span><br><span class="line"><span class="comment"> * 然后newNode为指针类型的， stack-&gt;top=newNode;就是将top指向了他的指针</span></span><br><span class="line"><span class="comment"> * 我理解的是双胞胎，栈的top的指针就指向了NewNode</span></span><br><span class="line"><span class="comment"> * 假设我们现在又传入了一个2</span></span><br><span class="line"><span class="comment"> * newNode-&gt;next=stack-&gt;top</span></span><br><span class="line"><span class="comment"> * 2的next里面放的是1的地址</span></span><br><span class="line"><span class="comment"> * stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> * 我们又将2的地址给了top，类似top再向上移动</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedStack* <span class="built_in">stack</span>,<span class="type">int</span> data)</span>{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=<span class="built_in">stack</span>-&gt;top;<span class="comment">// 新节点的next指向当前栈顶</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * 我又来啦，现在由李阳为你解析链栈的出栈</span></span><br><span class="line"><span class="comment"> * 我们这个是有返回值的，首先传入一个栈是毋庸置疑的</span></span><br><span class="line"><span class="comment"> * 还需要一个小小的判断-如果栈里面没有元素呢</span></span><br><span class="line"><span class="comment"> * -------核心代码----</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个临时变量temp用于存放栈顶，</span></span><br><span class="line"><span class="comment"> * 这里top里面放的是最后一个元素的地址</span></span><br><span class="line"><span class="comment"> * 根据地址可以找到元素没问题吧</span></span><br><span class="line"><span class="comment"> * 然后我们再将栈顶的元素的下一个地址重新给top</span></span><br><span class="line"><span class="comment"> * 我们之前top里面放的是栈顶的地址，现在我们变成传入栈顶</span></span><br><span class="line"><span class="comment"> * 的下一元素的地址，也就是将top向下移动</span></span><br><span class="line"><span class="comment"> * o.O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span>{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">stack</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="type">int</span>  popData=temp-&gt;data;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> popData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(LinkedStack *<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackTop</span><span class="params">(LinkedStack*<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> topdata=temp-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> topdata;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">      Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">      Node *nextNode;<span class="comment">//下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//来检验一下吧^_^</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedStack *<span class="built_in">stack</span>=initStack();<span class="comment">//初始化</span></span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">2</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">3</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a=  StackTop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈顶元素是：%d "</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> b= pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d出栈了"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    freeStack(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>​        一种可以实现“先进先出”的存储结构—排队买票进站 </p>
<h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><p>​    链式队列（链表）</p>
<p>​    静态队列（数组）</p>
<p>​            静态队列通常都必须是循环队列</p>
<p>​                      <img src="/posts/79666db/image-20241010163206657-1729000222964-1.png" alt="image-20241010163206657">        </p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>郝斌老师代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by 李阳 on 2024/10/14.</span></span><br><span class="line"><span class="comment"> * 数据结构之静态循环队列o.O</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> *pBase;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//首</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾</span></span><br><span class="line">} QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;<span class="comment">//改变实参的值所以要加*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *,<span class="type">int</span>)</span>;<span class="comment">//入队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *,<span class="type">int</span> *pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    init(&amp;Q);<span class="comment">//调用初始化函数</span></span><br><span class="line">    en_queue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (out_queue(&amp;Q, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队成功: %d\n"</span>, val); <span class="comment">// 修正输出格式</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队失败\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    pQ-&gt;pBase=(<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)*<span class="number">6</span>);<span class="comment">//定义了6个数据的数组</span></span><br><span class="line">    pQ-&gt;front=pQ-&gt;rear=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *pQ,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear]=val;<span class="comment">//将值放入尾部，并且尾部要+1</span></span><br><span class="line">        pQ-&gt;rear=(pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;<span class="comment">//尾部+1--因为是循环队列，当他满的时候会又从0开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>==pQ-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> ((i!=pQ-&gt;rear))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> *pVal)</span><span class="comment">//因为要带回来值，所以要*</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">if</span>(emput_queue(pQ))</span><br><span class="line">   {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"表是空的"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   } <span class="keyword">else</span></span><br><span class="line">   {</span><br><span class="line">     *pVal=pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">     pQ-&gt;front=(pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="4-队列的操作"><a href="#4-队列的操作" class="headerlink" title="4.队列的操作"></a>4.队列的操作</h3><p>所有和时间有关的操作</p>
<h3 id="5-李阳的队列"><a href="#5-李阳的队列" class="headerlink" title="5.李阳的队列"></a>5.李阳的队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span> {</span></span><br><span class="line">    Node* front;  <span class="comment">// 队头指针</span></span><br><span class="line">    Node* rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">} LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedQueue * <span class="title function_">initQueue</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedQueue * <span class="built_in">queue</span>=(LinkedQueue*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="comment">//返回0为空，1不为空所以为int类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span> <span class="params">(LinkedQueue * <span class="built_in">queue</span>,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node *newNode=(Node* ) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next=newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue * <span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;<span class="comment">//先进先出</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">deque</span>=temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;front==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NUll\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    Node * nextNode;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFront</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">queue</span>-&gt;front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LinkedQueue* <span class="built_in">queue</span> = initQueue();</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 打印队列内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> temp = getFront(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队头%d \n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 再次打印队列内容</span></span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);  <span class="comment">// 释放队列内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="6-李阳的循环队列"><a href="#6-李阳的循环队列" class="headerlink" title="6.李阳的循环队列"></a>6.李阳的循环队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/16.-循环队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义循环队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> *data;  <span class="comment">// 指向队列数组的指针</span></span><br><span class="line">    <span class="type">int</span> max_size;  <span class="comment">// 队列的最大容量</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头索引</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾索引（指向下一个入队位置）</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 队列中当前元素的数量</span></span><br><span class="line">} CircularQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化循环队列</span></span><br><span class="line">CircularQueue* <span class="title function_">create_circular_queue</span><span class="params">(<span class="type">int</span> max_size)</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = (CircularQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularQueue));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_size = max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(max_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">enqueue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满，无法入队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = value;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dequeue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> *value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，无法出队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    *value = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear) {</span><br><span class="line">        <span class="comment">// 队列中只有一个元素，出队后队列为空</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列中的所有元素（用于调试）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; <span class="built_in">queue</span>-&gt;size; count++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列占用的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_circular_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = create_circular_queue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    dequeue(<span class="built_in">queue</span>, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队元素: %d\n"</span>, value);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">50</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">60</span>);  <span class="comment">// 这将导致队列满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次入队会失败，因为队列已满</span></span><br><span class="line">    <span class="comment">// enqueue(queue, 70);</span></span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    free_circular_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="五、递归"><a href="#五、递归" class="headerlink" title="五、递归"></a>五、递归</h2><p><img src="/posts/79666db/image-20241015182021998-1731069393910-5.png" alt="image-20241015182021998"></p>
<h3 id="1-简单应用—阶层"><a href="#1-简单应用—阶层" class="headerlink" title="1.简单应用—阶层"></a>1.简单应用—阶层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之递归</span></span><br><span class="line"><span class="comment"> * Created by 李阳 on 2024/10/15.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo1--求阶层</span></span><br><span class="line"><span class="comment">/* for循环版</span></span><br><span class="line"><span class="comment">int jiec(int a)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=1;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for ( i=1; i &lt;=a; ++i)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        b=b*i;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    return b;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=5;</span></span><br><span class="line"><span class="comment">    int a= jiec(b);</span></span><br><span class="line"><span class="comment">    printf("%d 的阶层是 %d",b,a);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">long</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要求的阶层"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    b= f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld 的阶层是 %ld"</span>,a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现1+2+...</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="2-定义，要求，意义"><a href="#2-定义，要求，意义" class="headerlink" title="2.定义，要求，意义"></a>2.定义，要求，意义</h3><h4 id="①定义："><a href="#①定义：" class="headerlink" title="①定义："></a>①<strong>定义：</strong></h4><p>一个函数间接或直接调用自己</p>
<h4 id="②递归需要满足的三个条件"><a href="#②递归需要满足的三个条件" class="headerlink" title="②递归需要满足的三个条件"></a>②<strong>递归需要满足的三个条件</strong></h4><ol>
<li>递归必须要有一个明确的终止条件</li>
<li>该函数所处理的数据规模必须在递减</li>
<li>这个转化必须是可解的</li>
</ol>
<h4 id="③意义"><a href="#③意义" class="headerlink" title="③意义"></a>③<strong>意义</strong></h4><p>优点：易于理解</p>
<p>缺点：速度慢，存储空间大</p>
<h4 id="④循环："><a href="#④循环：" class="headerlink" title="④循环："></a>④<strong>循环</strong>：</h4><p>不易理解，速度快，存储空间小</p>
<h2 id="六、串、数组和广义表"><a href="#六、串、数组和广义表" class="headerlink" title="六、串、数组和广义表"></a>六、串、数组和广义表</h2><h3 id="一、串（string）"><a href="#一、串（string）" class="headerlink" title="一、串（string）"></a>一、串（string）</h3><p>0个或多个任意字符组成的有限序列</p>
<h4 id="1-子串的定义"><a href="#1-子串的定义" class="headerlink" title="1.子串的定义"></a>1.子串的定义</h4><p>一个串中任意个连续字符组成的子序列（含空串）称为该串的子串</p>
<p>例如：“abcd”的子串有 </p>
<p>“ ”，“a”,”ab”,”abc”,”abcd”</p>
<p><strong>真子串</strong>：是指不包含自身的所有子串</p>
<p><strong>主串</strong>:包含子串的串相应的称为主串</p>
<p><strong>字符位置</strong>:字符在序列中的序号为该字符串中的位置</p>
<p><strong>子串位置</strong>：子串第一个字符在主串中的位置</p>
<p><strong>空格串：</strong>由一个或多个空格组成的串，与空串不同</p>
<p><img src="/posts/79666db/image-20241015220006062-1731069393910-6.png" alt="image-20241015220006062"></p>
<p><strong>串相等:</strong>当且仅当两个串的长度相等并且各个对应立置上的字符都相同时，这两个串才是相等的。</p>
<h4 id="2-串的类型定义、存储结构及运算"><a href="#2-串的类型定义、存储结构及运算" class="headerlink" title="2.串的类型定义、存储结构及运算"></a>2.串的类型定义、存储结构及运算</h4><p>顺序存储结构-顺序串</p>
<p>链式存储结构-链式串</p>
<h4 id="3-串的表示"><a href="#3-串的表示" class="headerlink" title="3.串的表示"></a>3.串的表示</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串的顺序存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组1-255</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串的链式存储结构--块链结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE]; <span class="comment">// 存储字符块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个块的指针</span></span><br><span class="line">} Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    Chunk *head;  <span class="comment">// 串的首指针</span></span><br><span class="line">    Chunk *tail;  <span class="comment">// 串的尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;   <span class="comment">// 串的当前长度</span></span><br><span class="line">} LString;</span><br></pre></td></tr></table></figure>
<h4 id="4-串的模式匹配"><a href="#4-串的模式匹配" class="headerlink" title="4.串的模式匹配"></a>4.串的模式匹配</h4><h5 id="1-BF算法（穷举法）"><a href="#1-BF算法（穷举法）" class="headerlink" title="1.BF算法（穷举法）"></a>1.BF算法（穷举法）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_BF</span><span class="params">(SString S,SString T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i=(i-j)+<span class="number">2</span>;j=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">      <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241016164724670-1731069393910-7.png" alt="image-20241016164724670"></p>
<h5 id="2-※※※-KMP算法"><a href="#2-※※※-KMP算法" class="headerlink" title="2.※※※ KMP算法"></a>2.<strong>※※※ KMP</strong>算法</h5><p><img src="/posts/79666db/image-20241017130343420-1731069393910-8.png" alt="image-20241017130343420"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算模式串 T 的 next 数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j; <span class="comment">// 注意：next[i] 是 i 位置的前缀长度</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 算法实现，返回模式串 T 在主串 S 中首次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// S 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S.ch[i] == T.ch[j]) { <span class="comment">// j = -1 表示需要跳过</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == T.length) <span class="keyword">return</span> i - T.length; <span class="comment">// 匹配成功，返回匹配位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 匹配失败，返回 -1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="3-KMP算法改进"><a href="#3-KMP算法改进" class="headerlink" title="3.KMP算法改进"></a>3.KMP算法改进</h5><p><img src="/posts/79666db/image-20241017144344602-1731069393910-9.png" alt="image-20241017144344602"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = nextval[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><p>按照一点格式排列起来的具有相同的数据元素集合</p>
<p><strong>一维数组</strong>：若线性表中的元素为非结构的简单元素，则称为一维数组（线性结构，定长的线性表）</p>
<p><strong>二维数组</strong>：若一维数组中的元素又是一维数组结构，则称为二维数组</p>
<p><strong>二维数组逻辑结构：</strong></p>
<ul>
<li>非线性结构： 每一个元素既在一个行表中，又在一个列表中</li>
<li>线性结构：该线性表的每一个元素也是一个定长的线性表</li>
</ul>
<p><strong>数组特点</strong>：结构固定—定义后，维度和为界不再改变</p>
<p><strong>结论</strong>:</p>
<ul>
<li>线性表结构是数组的一个特例</li>
<li>而数组结构又是线性表结构的扩展</li>
</ul>
<p><strong>基本操作</strong>：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p>
<p>一般采用顺序结构来表示数组</p>
<h4 id="2-存储位置"><a href="#2-存储位置" class="headerlink" title="2.存储位置"></a>2.存储位置</h4><p><img src="/posts/79666db/image-20241017154244958-1731069393910-10.png" alt="image-20241017154244958"></p>
<p>数组元素a[i] [j] 的存储位置是 LOC(i,j)=LOC(0,0)+n <em> i+j </em> L(L是存储每个元素所需要L个存储单元)</p>
<h4 id="3-压缩存储"><a href="#3-压缩存储" class="headerlink" title="3.压缩存储"></a>3.压缩存储</h4><ol>
<li>什么是压缩存储?<br>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</li>
<li>什么样的矩阵能够压缩?<br>一些特殊矩阵，如:对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</li>
<li>什么叫稀疏矩阵?<br>矩阵中非零元素的个数较少（一般小于5%)</li>
</ol>
<h5 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a><strong>1.对称矩阵</strong></h5><ol>
<li><h6 id="特点"><a href="#特点" class="headerlink" title="[特点]"></a>[特点]</h6><p>沿着对角线对称</p>
<p>在nxn的矩阵a中，满足如下性质:    aij=aji (1 ≤i, j &lt;n)</p>
</li>
<li><h6 id="存储方法"><a href="#存储方法" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p>
</li>
</ol>
<p><img src="/posts/79666db/image-20241017155259933-1731069393910-11.png" alt="image-20241017155259933"></p>
<p><img src="/posts/79666db/image-20241017155934811-1731069393910-12.png" alt="image-20241017155934811"></p>
<h5 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a><strong>2.三角矩阵</strong></h5><ol>
<li><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="[特点]"></a>[特点]</h6><p>对角线以下(或者以上)的数据元素(不包括对角线)全部为常数co</p>
</li>
<li><h6 id="存储方法-1"><a href="#存储方法-1" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间: sa[1.. n(n+1)/2+1]</p>
</li>
</ol>
<p><img src="/posts/79666db/image-20241017160251060-1731069393911-13.png" alt="image-20241017160251060"></p>
<h5 id="3-对角矩阵（带状矩阵）"><a href="#3-对角矩阵（带状矩阵）" class="headerlink" title="3.对角矩阵（带状矩阵）"></a><strong>3.对角矩阵（带状矩阵）</strong></h5><p>[特点]在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p>
<p><img src="/posts/79666db/image-20241017160553699-1731069393911-14.png" alt="image-20241017160553699"></p>
<p><img src="/posts/79666db/image-20241017160653491-1731069393911-15.png" alt="image-20241017160653491"></p>
<h5 id="4-稀疏矩阵"><a href="#4-稀疏矩阵" class="headerlink" title="4.稀疏矩阵"></a><strong>4.稀疏矩阵</strong></h5><p>稀疏矩阵:设在mxn的矩阵中有t个非零元素。<br>令ɸ= t/(mxn)<br>当ɸ≤0.05时称为稀疏矩阵。</p>
<p><img src="/posts/79666db/image-20241017161616371-1731069393911-16.png" alt="image-20241017161616371" style="zoom:67%;"></p>
<p><img src="/posts/79666db/image-20241017161810079-1731069393911-17.png" alt="image-20241017161810079" style="zoom:67%;"></p>
<p>三元组顺序表又称有序的双下标法。</p>
<ol>
<li><p>三元组顺序表的优点:非零元在表中按行序有序存储，因此便于进</p>
<p>行依行顺序处理的矩阵运算。</p>
</li>
<li><p>三元组顺序表的缺点:不能随机存取。若按行号存取某一行中的非</p>
<p>零元，则需从头开始进行查找。</p>
</li>
</ol>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a><strong>十字链表</strong></h6><p>优点:它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算<br><img src="/posts/79666db/image-20241017162515773-1731069393911-18.png" alt="image-20241017162515773"></p>
<p><img src="/posts/79666db/image-20241017162538457-1731069393911-19.png" alt="image-20241017162538457"></p>
<p> <img src="/posts/79666db/image-20241017163651081-1731069393911-20.png" alt="image-20241017163651081"></p>
<h3 id="三-广义表"><a href="#三-广义表" class="headerlink" title="三.广义表"></a>三.广义表</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><p>广义表 （又称列表Lists）是n≧0个元素 a0,a1…..an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表</p>
<p><img src="/posts/79666db/image-20241017164155126-1731069393911-21.png" alt="image-20241017164155126"></p>
<ul>
<li><p>广义表通常记作:Ls=(a1, a2,..，an)</p>
<p>其中:LS为表名，n为表的长度，每一个ai为表的元素</p>
</li>
<li><p>习惯上，一般用<strong>大写字母</strong>表示<strong>广义表</strong>，<strong>小写字母</strong>表示<strong>原子。</strong></p>
</li>
<li><p><strong>表头：</strong>若LS非空(n≥1)，则其第一个元素a1就是表头。<br>记作head(LS) = a1。<strong>注</strong>:表头可以是原子，也可以是子表。</p>
</li>
<li><p><strong>表尾</strong>：除<strong>表头</strong>之外的<strong>其它元素</strong>组成的<strong>表</strong>。</p>
<p>​      记作tail(LS） = (a2, …. an)。</p>
<p>​     注:表尾不是最后一个元素，而是一个<strong>子表。</strong></p>
<p><img src="/posts/79666db/image-20241017170321265-1731069393911-22.png" alt="image-20241017170321265"></p>
</li>
</ul>
<h4 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h4><ul>
<li><p>(1)广义表中的数据元素有相对<strong>次序;一个直接前驱和一个直接后驱</strong></p>
</li>
<li><p>(2)广义表的<strong>长度</strong>定义为最外层所包含元素的个数;</p>
<p>​     如: C=(a (b, q))是长度为2的广义表。</p>
</li>
<li><p>(3)广义表的<strong>深度</strong>定义为该广义表<strong>展开后所含括号的重数</strong>;</p>
<p>​     A=(b ,c)的深度为1,B=(A,d)的深度为2，C=(f, B,h)的深度为3。</p>
<p>​     <strong>注意</strong>:“原子”的深度为0;“空表”的深度为1。</p>
</li>
<li><p>广义表可以为其他广义表<strong>共享</strong>，如：广义表B就共享了广义表A。在b中不必列出A的值，而是通过名称来引用，B=(A)</p>
</li>
<li><p>广义表可以是一个递归的表。如：F=（a,F=(a,(a,(a,…)))</p>
</li>
</ul>
<p>​               注意：递归表的深度是无穷值，长度是有限值，这里长度是2</p>
<ul>
<li>广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，….。<br>可以用图形象地表示。<br>例:D=(E，F）其中:E=(a, (b,c)）F=(d,(e))</li>
</ul>
<h4 id="3-广义表和线性表的区别"><a href="#3-广义表和线性表的区别" class="headerlink" title="3.广义表和线性表的区别"></a>3.广义表和线性表的区别</h4><ol>
<li>广义表可以看成是线性表的推广，线性表是广义表的特例。</li>
<li>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</li>
<li>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</li>
<li>另外，树和有向图也可以用广义表来表示。</li>
<li>由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</li>
</ol>
<h4 id="4-广义表的基本运算"><a href="#4-广义表的基本运算" class="headerlink" title="4.广义表的基本运算"></a>4.广义表的基本运算</h4><p> <img src="/posts/79666db/image-20241031143536962-1731069393911-23.png" alt="image-20241031143536962"></p>
<p>案例分析</p>
<p><img src="/posts/79666db/image-20241031144308247-1731069393911-24.png" alt="image-20241031144308247"></p>
<p>代码实现</p>
<h2 id="七、树"><a href="#七、树" class="headerlink" title="七、树"></a>七、树</h2><h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1.树的定义"></a>1.树的定义</h3><p><img src="/posts/79666db/image-20241031144903388-1731069393911-25.png" alt="image-20241031144903388"></p>
<h4 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h4><p><strong>树</strong>(Tree)是n (n≥0)个结点的有限集。(递归)<br>       若n =0，称为<strong>空树</strong>;<br>        若n &gt;0，则它满足如下两个条件:<br>              (1)<strong>有且仅有一个</strong>特定的称为<strong>根</strong>(Root)的结点;<br>              (2)<strong>其余结点</strong>可分为m (m≥0)个互不相交的<strong>有限集</strong>T1,T2,T3,…Tm，其中每一个集合本身又是一棵树，并称为根的<strong>子树</strong>(SubTree)。 </p>
<h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><p><strong>结点</strong>：数据元素以及指向树的分支</p>
<p><strong>根结点</strong>：非空树中无前驱点的结点</p>
<p><strong>结点的度</strong>：结点拥有的子树数</p>
<p>​    eg: A 3,B 2,F 0</p>
<p><img src="/posts/79666db/image-20241031152141050-1731069393911-26.png" alt="image-20241031152141050"></p>
<p><strong>树的度</strong>： 数内各结点的度的最大值</p>
<p><strong>叶子结点</strong>:终端结点（度为0）</p>
<p>​          eg: k L G M J</p>
<p><strong>分支结点</strong>:非终端结点</p>
<p>​            eg: B,C,D…</p>
<p><strong>内部结点</strong>:根节点以外的分支结点称为内部结点 </p>
<p><strong>孩子结点</strong>：结点的子树的根称为孩子</p>
<p><strong>双亲结点</strong>：孩子结点的前驱</p>
<p><img src="/posts/79666db/image-20241031154837095-1731069393911-27.png" alt="image-20241031154837095"></p>
<p>​       eg: BCD是A的孩子结点，A是bcd的双亲结点</p>
<p><strong>兄弟结点</strong>：同级的结点</p>
<p><strong>祖先结点</strong>：从根到该结点所经分支上的所有结点</p>
<p>​           eg: M的祖先结点为H,D,A</p>
<p><strong>子孙结点</strong>:从某结点为根的子树的任意结点</p>
<p>​          eg: D的孙子有HM</p>
<p><strong>树的深度</strong>：树中结点的最大层次</p>
<p><strong>有序树</strong>：树中的各子树从左至右有次序(最左边为第一个孩子)</p>
<p><strong>无序树</strong>：树中结点的各子树无次序</p>
<p><strong>森林</strong>：是m（m&gt;=0)棵互不相交的树的集合</p>
<p><img src="/posts/79666db/image-20241031160124987-1731069393911-28.png" alt="image-20241031160124987"></p>
<p>​              树一定是森林，森林不一定是树</p>
<h4 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a>树结构和线性结构的比较</h4><p><img src="/posts/79666db/image-20241031160854242-1731069393911-29.png" alt="image-20241031160854242"></p>
<h3 id="2-二叉树的定义"><a href="#2-二叉树的定义" class="headerlink" title="2.二叉树的定义"></a>2.二叉树的定义</h3><p><img src="/posts/79666db/image-20241031161122434-1731069393911-30.png" alt="image-20241031161122434"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​    二叉树是n(n&gt;=0)个结点的有限集，它或者是空集(n= 0),或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li>每个结点最多有俩孩子(二叉树中不存在度大于2的结点)。</li>
<li>子树有左右之分，其次序不能颠倒。</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树。</li>
</ol>
<h4 id="树和二叉树区别"><a href="#树和二叉树区别" class="headerlink" title="树和二叉树区别"></a><strong>树和二叉树区别</strong></h4><ul>
<li>二叉树不是树的特殊情况，它们是两个概念</li>
<li>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也经行区分，说明它是左子树，还是右子树。</li>
<li>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</li>
<li>(也就是二叉树每个结点位置或者次序都是固定的，可以是空，但是个可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时.它就无所谓左右了)</li>
</ul>
<p><img src="/posts/79666db/image-20241031161802875-1731069393911-31.png" alt="image-20241031161802875"></p>
<p><img src="/posts/79666db/image-20241031161947956-1731069393911-32.png" alt="image-20241031161947956"></p>
<h3 id="3-案例引用"><a href="#3-案例引用" class="headerlink" title="3.案例引用"></a>3.案例引用</h3><p><img src="/posts/79666db/image-20241031162420574-1731069393911-33.png" alt="image-20241031162420574"></p>
<h3 id="4-树和二叉树的抽象数据类型定义"><a href="#4-树和二叉树的抽象数据类型定义" class="headerlink" title="4.树和二叉树的抽象数据类型定义"></a>4.树和二叉树的抽象数据类型定义</h3><p><img src="/posts/79666db/image-20241031162925621-1731069393911-34.png" alt="image-20241031162925621"></p>
<p><img src="/posts/79666db/image-20241031170614463-1731069393911-35.png" alt="image-20241031170614463"></p>
<h3 id="5-二叉树的性质和存储结构"><a href="#5-二叉树的性质和存储结构" class="headerlink" title="5.二叉树的性质和存储结构"></a>5.二叉树的性质和存储结构</h3><h4 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h4><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><strong>满二叉树</strong>：一颗深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>且有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点的二叉树就叫满二叉树</p>
<p><strong>完全二叉树</strong>：深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的具有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的二叉树，当且仅当每一个结点都与深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的<strong>满二叉树</strong>中的<strong>编号</strong>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 1350 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的结点一一对应时，称为<strong>完全二叉树</strong>（叶子结点的编号是连续的,<strong>左侧树必须满元素</strong>)</p>
<ul>
<li>叶子只可能分布在层次最大的两层上，</li>
<li>对任意结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1</li>
</ul>
<p><img src="/posts/79666db/image-20241031204537868-1731069393911-36.png" alt="image-20241031204537868"></p>
<h6 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h6><p>​      在二叉树的第i层上至多有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.915ex" height="1.887ex" role="img" focusable="false" viewbox="0 -833.9 1730.6 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>个结点</p>
<h6 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h6><p>​     深度为k的二叉树至多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点(k&gt;=1)</p>
<h6 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h6><p>​      对任何一个二叉树<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.871ex" role="img" focusable="false" viewbox="0 -677 1020.6 827"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>,如果其叶子为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 1036.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>,度为2的结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.339ex" role="img" focusable="false" viewbox="0 -442 1036.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>，\则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="11.604ex" height="1.881ex" role="img" focusable="false" viewbox="0 -666 5129.1 831.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1314.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2370.1,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3628.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4629.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<p><img src="/posts/79666db/image-20241031173605833-1731069393911-37.png" alt="image-20241031173605833"></p>
<p>​        eg:这里叶子结点7 8 9 10 11 12有6个,度为2的有1 2 3 4 5 有五个</p>
<p>总结点数n  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="20.578ex" height="1.846ex" role="img" focusable="false" viewbox="0 -666 9095.6 816"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(2970.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3542.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4264.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5264.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6301.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(6873.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7595.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8595.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 又 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="16.941ex" height="1.694ex" role="img" focusable="false" viewbox="0 -583 7488.1 748.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3192.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4192.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(5451.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(6451.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container></p>
<p>总边个数B <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="9.989ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4415 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2092.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2914.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3915,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>  =  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="17.041ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 7532.1 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2092.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(3129.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3701.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4423.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5423.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6460.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(7032.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h6 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h6><p>具有n个结点的<strong>完全二叉树</strong>的深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.239ex" role="img" focusable="false" viewbox="0 -694 3489.7 989.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1989.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2989.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h6 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h6><p>如果有一颗<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的<strong>完全二叉树(</strong>深度为 [<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>)的结点按层编号(从第1层到第[<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>层，每层从左到右)，对<strong>任一结点i</strong>(1&lt;=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>&lt;=n),有</p>
<ol>
<li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>=1，则结点i是二叉树的根，无双亲;如果i&gt;1，则其<strong>双亲是结点[i /2]。</strong></li>
<li>如果2<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="5.155ex" height="1.586ex" role="img" focusable="false" viewbox="0 -661 2278.6 701"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1678.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点i为叶子结点，无左孩子;否则，<br>其<strong>左孩子是结点2i。</strong></li>
<li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.183ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 4501 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2845.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(3901,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>无右孩子;否则，其<strong>右孩</strong><br><strong>子是结点2i + 1。</strong></li>
</ol>
<p><strong>总结</strong>: 编号为i，他的父结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.043ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1345 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(345,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(845,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>,左结点为2i，右节点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.809ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2567.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h4 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h4><p><img src="/posts/79666db/image-20241031214118623-1731069393911-38.png" alt="image-20241031214118623"></p>
<h5 id="1-二叉树的顺序存储结构"><a href="#1-二叉树的顺序存储结构" class="headerlink" title="1.二叉树的顺序存储结构"></a>1.二叉树的顺序存储结构</h5><ul>
<li><p>实现：按满二叉树的结点层次编号，依次存放在二叉树的数据元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> SqBiTree[MAXTSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241102133931076.png" alt="image-20241102133931076"></p>
</li>
<li><p>缺点： <img src="/posts/79666db/image-20241102134705813.png" alt="image-20241102134705813"></p>
<p>结点间的关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树</p>
</li>
</ul>
<h5 id="2-二叉树的链式存储结构"><a href="#2-二叉树的链式存储结构" class="headerlink" title="2.二叉树的链式存储结构"></a>2.二叉树的链式存储结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchile</span>;</span><span class="comment">//左右孩子</span></span><br><span class="line">}BiNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241102135937947.png" alt="image-20241102135937947"></p>
<p>在n个结点的二叉链表中，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个空指针域</p>
<p>必有2n个链域，除根节点外，每个结点有且仅有一个双亲，所有只会有n-1个结点的链域存放指针，指向非空子女结点</p>
<h5 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">Ichild</span>,*<span class="title">parent</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向双亲结点</span></span><br><span class="line">}TriTNode,*TriTree;</span><br></pre></td></tr></table></figure>
<h4 id="3-遍历二叉树和线索二叉树"><a href="#3-遍历二叉树和线索二叉树" class="headerlink" title="3.遍历二叉树和线索二叉树"></a>3.遍历二叉树和线索二叉树</h4><h5 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h5><p>先序遍历：根左右</p>
<p>中序遍历：左根右</p>
<p>后续遍历：左右根</p>
<p><img src="/posts/79666db/image-20241102144633249.png" alt="image-20241102144633249">       </p>
<h6 id="先—根左右"><a href="#先—根左右" class="headerlink" title="先—根左右"></a>先—根左右</h6><p><img src="/posts/79666db/image-20241102150119954.png" alt="image-20241102150119954"></p>
<p>ABELDHMIJ</p>
<h6 id="中—左根右"><a href="#中—左根右" class="headerlink" title="中—左根右"></a>中—左根右</h6><p><img src="/posts/79666db/image-20241102150600713.png" alt="image-20241102150600713"></p>
<p>ELBAMHIDJ</p>
<h6 id="后—左右根"><a href="#后—左右根" class="headerlink" title="后—左右根"></a>后—左右根</h6><p><img src="/posts/79666db/image-20241102151437701.png" alt="image-20241102151437701"></p>
<p>LEBMIHJDA </p>
<p>实例：<img src="/posts/79666db/6E50FE1F8569BEB2D29488718E198F13.png" alt="6E50FE1F8569BEB2D29488718E198F13"></p>
<p><img src="/posts/79666db/image-20241102154045025.png" alt="image-20241102154045025"></p>
<h5 id="2-根据遍历序列确定二叉树（先-中-后序）"><a href="#2-根据遍历序列确定二叉树（先-中-后序）" class="headerlink" title="2.根据遍历序列确定二叉树（先 中 后序）"></a>2.根据遍历序列确定二叉树（先 中 后序）</h5><ul>
<li><p>若二叉树中的各结点均不相同，则二叉树结点的先徐序列、中序序列和后序序列都是唯一的</p>
</li>
<li><p>由二叉树的先序和中序序列，或由二叉树的后序和中序序列可以确定唯一一颗二叉树</p>
</li>
</ul>
<h6 id="实例1：先序-中序"><a href="#实例1：先序-中序" class="headerlink" title="实例1：先序+中序"></a>实例1：先序+中序</h6><p>先：A B C D E F G H I</p>
<p>中：C D B F E A I H G J</p>
<p>解题思路</p>
<ol>
<li><p>由先知A必为根，B必为左   由中知 CDBFE在左部，IHGJ在右边</p>
<p><img src="/posts/79666db/image-20241102180223951.png" alt="image-20241102180223951"></p>
</li>
<li><p>由先序知道B为根，由中序知道CD为左子树，FE为右子树</p>
<p><img src="/posts/79666db/image-20241102180244711.png" alt="image-20241102180244711"></p>
</li>
<li><p>由先序知道G是根，那么I H为左子树，J为右子树</p>
<p><img src="/posts/79666db/image-20241102181222814.png" alt="image-20241102181222814"></p>
</li>
<li><p>由中序CD左根右知道，c为左，d为右，先序知道E为根，中序知道F为左</p>
<p><img src="/posts/79666db/image-20241102181439508.png" alt="image-20241102181439508"></p>
</li>
<li><p>由中序知道I为左子树</p>
<p><img src="/posts/79666db/image-20241102181539924.png" alt="image-20241102181539924"></p>
</li>
</ol>
<h6 id="实例2—中序-后续"><a href="#实例2—中序-后续" class="headerlink" title="实例2—中序+后续"></a>实例2—中序+后续</h6><ol>
<li>中序序列:BDCEAFHG</li>
<li>后序序列:DECBHGFA</li>
<li>由中序后续知道根为A，BDCE为左根 FHG为右根</li>
<li>后序知道B为根，中序推出没有左根，c为下一个根</li>
<li>左右根D为左，E为右边</li>
<li>后序知道F为根</li>
<li>由中序知道F没有左，那么H为左，G为根</li>
</ol>
<p><img src="/posts/79666db/image-20241102183841772.png" alt="image-20241102183841772"></p>
<h5 id="3-遍历的算法实现-先序遍历"><a href="#3-遍历的算法实现-先序遍历" class="headerlink" title="3.遍历的算法实现-先序遍历"></a>3.遍历的算法实现-先序遍历</h5><p><img src="/posts/79666db/image-20241102201045571.png" alt="image-20241102201045571"></p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);</span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="递归代码解释"><a href="#递归代码解释" class="headerlink" title="递归代码解释"></a>递归代码解释</h6><ol>
<li><p>首先进入函数，此时T为传入的根结点</p>
</li>
<li><p>打印根节点</p>
</li>
<li><p>第一次调用：<strong>根左右</strong>函数指向根B</p>
</li>
<li><p>进入第二层循环 遍历左，左为空此时返回</p>
</li>
<li><p>回到第二层循环此时 PerOrderTraverse(T-&gt;lchild);为空，那么自动执行下一条语句PerOrderTraverse(T-&gt;rchile);</p>
</li>
<li><p>进入循环，执行到D</p>
</li>
<li><p>再向下执行为空返回到第一次循环</p>
</li>
<li><p>再执行C</p>
<p><img src="/posts/79666db/image-20241103142345827.png" alt="image-20241103142345827"></p>
</li>
</ol>
<p>(●ˇ∀ˇ●)明白了吗！</p>
<h5 id="4-遍历的算法实现-中序遍历"><a href="#4-遍历的算法实现-中序遍历" class="headerlink" title="4.遍历的算法实现-中序遍历"></a>4.遍历的算法实现-中序遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="5-历的算法实现-后序遍历"><a href="#5-历的算法实现-后序遍历" class="headerlink" title="5.历的算法实现-后序遍历"></a>5.历的算法实现-后序遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         </span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="6-二叉树遍历小总结"><a href="#6-二叉树遍历小总结" class="headerlink" title="6.二叉树遍历小总结"></a>6.二叉树遍历小总结</h5><p><img src="/posts/79666db/image-20241103143731170.png" alt="image-20241103143731170"></p>
<p>时间复杂度O(n)//每个结点只访问一次</p>
<p>空间复杂度O(n)//栈占用的最大辅助空间</p>
<h5 id="7-中序遍历非递归算法-栈"><a href="#7-中序遍历非递归算法-栈" class="headerlink" title="7.中序遍历非递归算法-栈"></a>7.中序遍历非递归算法-栈</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    BiTree P;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化</span></span><br><span class="line">    P=T;</span><br><span class="line">    <span class="keyword">while</span> (p||StackEmpty(S))<span class="comment">//遇到的是根的时候</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(P)<span class="comment">//不为空</span></span><br><span class="line">        {</span><br><span class="line">            Push(S,p);<span class="comment">//入栈</span></span><br><span class="line">            p=p-&gt;Ichild;<span class="comment">//访问左子树</span></span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Pop(S,q);<span class="comment">//出栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data);<span class="comment">//输出根</span></span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="8-二叉树的层次遍历"><a href="#8-二叉树的层次遍历" class="headerlink" title="8.二叉树的层次遍历"></a>8.二叉树的层次遍历</h5><p><img src="/posts/79666db/image-20241103154648957.png" alt="image-20241103154648957"></p>
<p><img src="/posts/79666db/image-20241103154702890.png" alt="image-20241103154702890"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    BTNode data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rar;</span><br><span class="line">    </span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">{</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化</span></span><br><span class="line">    enQuenue(qu,b);<span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu)){<span class="comment">//队不为空则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出栈结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);访问结点p</span><br><span class="line">        <span class="title function_">if</span><span class="params">(p-&gt;Ichild!=<span class="literal">NULL</span>)</span><span class="title function_">enQueue</span><span class="params">(qu,p-&gt;Ichild)</span>;<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)enqueue(qu,p-&gt;rchild);<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="9-二叉树遍历算法的应用"><a href="#9-二叉树遍历算法的应用" class="headerlink" title="9.二叉树遍历算法的应用"></a>9.二叉树遍历算法的应用</h5><h6 id="1-二叉树的建立"><a href="#1-二叉树的建立" class="headerlink" title="1.二叉树的建立"></a>1.二叉树的建立</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">"#"</span>) T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">if</span>(!(T=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">        <span class="built_in">exit</span>(OVRTFLOW);</span><br><span class="line">    T-&gt;data=ch;<span class="comment">//生成根节点</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;Ichild);<span class="comment">//构造左子树</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}<span class="comment">//CreateBiTree</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241103164836364.png" alt="image-20241103164836364"></p>
<h6 id="2-复制二叉树"><a href="#2-复制二叉树" class="headerlink" title="2.复制二叉树"></a>2.复制二叉树</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T,BiTree &amp;newT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">        NewT=new BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line"></span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="3-计算二叉树的深度"><a href="#3-计算二叉树的深度" class="headerlink" title="3.计算二叉树的深度"></a>3.计算二叉树的深度</h6><ul>
<li><p>如果是空树，则深度为0</p>
</li>
<li><p>否则，递归计算左子树的深度计为m，递归计算右子树的深度计为n，二叉树的深度则为m与n的较大者<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        m= Depth(T-&gt;lchild);</span><br><span class="line">        n= Depth(T-&gt;rchile);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="4-计算二叉树的结点总数"><a href="#4-计算二叉树的结点总数" class="headerlink" title="4.计算二叉树的结点总数"></a>4.计算二叉树的结点总数</h6><ul>
<li>如果为空树则结点为0</li>
<li>否则，结点个数为左子树个数+右子树结点个数再+1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(Bitree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild)+ NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="5-计算叶子结点的个数"><a href="#5-计算叶子结点的个数" class="headerlink" title="5.计算叶子结点的个数"></a>5.计算叶子结点的个数</h6><ul>
<li>如果是空树返回0</li>
<li>否则，为左子树的叶子结点+右子树的叶子结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchile==<span class="literal">NULL</span>)<span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+leafCount(T-&gt;rchile);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="10-线索二叉树"><a href="#10-线索二叉树" class="headerlink" title="10.线索二叉树"></a>10.线索二叉树</h5><ul>
<li>如果某个结点的左孩子为空，则将空的左孩子指针域改为<strong>指向其前驱</strong>；</li>
<li>如果某孩子的右结点为空，则将空的右孩子的指针域改为<strong>指向其后继</strong>；</li>
</ul>
<p><img src="/posts/79666db/image-20241104153725343.png" alt="image-20241104153725343"></p>
<p>这里是依照遍历来判断前驱后继，而不是图</p>
<h6 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;<span class="comment">//0表示是左/右孩子，1表示是前/后继</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241104155234167.png" alt="image-20241104155234167"></p>
<p><img src="/posts/79666db/image-20241104155240636.png" alt="image-20241104155240636"></p>
<p><img src="/posts/79666db/image-20241104155253366.png" alt="image-20241104155253366"></p>
<hr>
<h6 id="2-线索二叉树画法"><a href="#2-线索二叉树画法" class="headerlink" title="2.线索二叉树画法"></a>2.线索二叉树画法</h6><p><img src="/posts/79666db/image-20241104155331910.png" alt="image-20241104155331910"></p>
<h6 id="3-遍历算法"><a href="#3-遍历算法" class="headerlink" title="3.遍历算法"></a>3.遍历算法</h6><p>408不要求掌握</p>
<h5 id="11-李阳的交换左右子树"><a href="#11-李阳的交换左右子树" class="headerlink" title="11.李阳的交换左右子树"></a>11.李阳的交换左右子树</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/14.树的交换左右子树</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line"></span><br><span class="line">}TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode * <span class="title function_">creatNode</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * newNode=(TreeNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"失败的树 "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;val=val;</span><br><span class="line">    newNode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换左右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swaplr</span><span class="params">(TreeNode * root)</span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode * temp=root-&gt;left;</span><br><span class="line">    root-&gt;left=root-&gt;right;</span><br><span class="line">    root-&gt;right=temp;</span><br><span class="line">    swaplr(root-&gt;left);<span class="comment">//交换左半树</span></span><br><span class="line">    swaplr(root-&gt;right);<span class="comment">//右半边树</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode*root)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个简单的二叉树</span></span><br><span class="line">    <span class="comment">//       1</span></span><br><span class="line">    <span class="comment">//      / \</span></span><br><span class="line"><span class="comment">    //     2   3</span></span><br><span class="line">    <span class="comment">//    / \</span></span><br><span class="line"><span class="comment">    //   4   5</span></span><br><span class="line"></span><br><span class="line">    root= creatNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = creatNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = creatNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = creatNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = creatNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    swaplr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Pre-order traversal after swapping:\n"</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    freeTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-树和森林"><a href="#6-树和森林" class="headerlink" title="6.树和森林"></a>6.树和森林</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">408要求</span><br><span class="line">2森林与二叉树的转换</span><br><span class="line">3树和森林的遍历</span><br></pre></td></tr></table></figure>
<h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>森林</strong>：是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.642ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5145.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1267,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2422.8,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mn" transform="translate(4256.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4756.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>棵互不相交的树的集合</p>
<h4 id="2-双亲表示法"><a href="#2-双亲表示法" class="headerlink" title="2.双亲表示法"></a>2.双亲表示法</h4><ul>
<li><p><strong>实现</strong>：定义结构数组</p>
<p>​            存放树的结点</p>
<p>​             每个结点含两个域</p>
</li>
<li><p><strong>数据域</strong>：存放结点本身信息</p>
</li>
<li><p><strong>双亲域</strong>：指示本结点的双亲结点在数组中的位置</p>
</li>
</ul>
<p><img src="/posts/79666db/image-20241104162141056.png" alt="image-20241104162141056"></p>
<p><strong>特点</strong>：找双亲容易，找孩子难</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>{</span><span class="comment">//树的结点定义</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAXTSIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数,根节点位置</span></span><br><span class="line">}PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-孩子链表"><a href="#3-孩子链表" class="headerlink" title="3.孩子链表"></a>3.孩子链表</h4><p>把每个结点的孩子结点排列起来，看成是一个线性表， 用单链表存储，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。</p>
<p><strong>解释</strong>：每个结点都有一个单链表，叶子节点的单链表是空表，然后再将这些链表的头指针存放在数组中</p>
<p><img src="/posts/79666db/image-20241104164756540.png" alt="image-20241104164756540"></p>
<p>孩子结点结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> child;<span class="comment">//整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个孩子的地址</span></span><br><span class="line">}* ChildPrt;</span><br></pre></td></tr></table></figure>
<p>双亲结点结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    ChildPrt firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">}CTBox;</span><br></pre></td></tr></table></figure>
<p>树结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    CTBox nodes[MAXTSIZE];<span class="comment">//头指针数组</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数和根节点位置下标</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>:找孩子容易，找双亲难</p>
<h4 id="4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）"><a href="#4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）" class="headerlink" title="4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）"></a>4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>实现</strong>：用二叉链表作树的存储结构，链表中的美观结点的指针域分别指向其<strong>第一个孩子节点</strong>和<strong>下一个兄弟节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>{</span></span><br><span class="line">    ELemtype data;<span class="comment">//元素类型 数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子，下一个兄弟</span></span><br><span class="line">}CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<p>左孩子 右兄弟，是兄弟的就来砍我</p>
<p><img src="/posts/79666db/image-20241104171329061.png" alt="image-20241104171329061"></p>
<p>特点：找孩子，找兄弟简单，找双亲难</p>
<h4 id="5-树与二叉树的转换"><a href="#5-树与二叉树的转换" class="headerlink" title="5.*树与二叉树的转换"></a>5.*树与二叉树的转换</h4><h5 id="1-定义-6"><a href="#1-定义-6" class="headerlink" title="1.定义"></a>1.定义</h5><ul>
<li>将树转化为二叉树，利用二叉树的算法实现对树的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则以二叉树链表作媒介可以导出树与二叉树之间的对应关系</li>
</ul>
<p><img src="/posts/79666db/image-20241104173140758.png" alt="image-20241104173140758"></p>
<h5 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h5><h6 id="1-将树转为二叉树"><a href="#1-将树转为二叉树" class="headerlink" title="1.将树转为二叉树"></a>1.将树转为二叉树</h6><ol>
<li><p>加线:在兄弟之间加一连线</p>
</li>
<li><p>抹线:对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
</li>
<li>旋转:以树的根结点为轴心，将整树顺时针转45°</li>
</ol>
<p><img src="/posts/79666db/image-20241104173843558.png" alt="image-20241104173843558"></p>
<h6 id="2-将二叉树转为树"><a href="#2-将二叉树转为树" class="headerlink" title="2.将二叉树转为树"></a>2.将二叉树转为树</h6><ol>
<li>加线:若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩….沿分支找到的所有右孩子，都与p的双亲用线连起来</li>
<li>抹线:抹掉原二叉树中双亲与右孩子之间的连线</li>
<li>调整:将结点按层次排列，形成树结构</li>
</ol>
<p><img src="/posts/79666db/image-20241104173926325.png" alt="image-20241104173926325"></p>
<h4 id="6-森林和二叉树的转换（二叉树与多棵树之间的关系"><a href="#6-森林和二叉树的转换（二叉树与多棵树之间的关系" class="headerlink" title="6.*森林和二叉树的转换（二叉树与多棵树之间的关系)"></a>6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</h4><h5 id="1-森林转化为二叉树"><a href="#1-森林转化为二叉树" class="headerlink" title="1.森林转化为二叉树"></a>1.森林转化为二叉树</h5><ol>
<li><p>将各棵树分别转换成二叉树</p>
</li>
<li><p>将每棵树的根结点用线相连</p>
</li>
<li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>
</li>
</ol>
<p><img src="/posts/79666db/image-20241104180338598.png" alt="image-20241104180338598"></p>
<h5 id="2-二叉树转为森林"><a href="#2-二叉树转为森林" class="headerlink" title="2.二叉树转为森林"></a>2.二叉树转为森林</h5><ol>
<li><p>抹线:将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二又树（去掉全部右孩线）</p>
</li>
<li><p>还原:将孤立的二又树还原成树（孤立二叉再还原)</p>
<p><img src="/posts/79666db/image-20241104181000820.png" alt="image-20241104181000820"></p>
</li>
</ol>
<h4 id="7-树与森林的遍历"><a href="#7-树与森林的遍历" class="headerlink" title="7.树与森林的遍历"></a>7.树与森林的遍历</h4><h5 id="1-树的遍历的三种方式-先根（次序-，后根，层次遍历"><a href="#1-树的遍历的三种方式-先根（次序-，后根，层次遍历" class="headerlink" title="1.树的遍历的三种方式{先根（次序)，后根，层次遍历}"></a>1.树的遍历的三种方式{先根（次序)，后根，层次遍历}</h5><ul>
<li><p>先根遍历（次序）</p>
<p>​           若树不空，则先访问根结点，然后依次先根遍历各棵子树</p>
</li>
<li><p>后根遍历（次序）</p>
<p>​          若树不空，则先依次后根遍历各棵子树，然后访问根结点</p>
</li>
<li><p>层次遍历</p>
<p>​          若树不空，则至上而下自左至右访问树的每个结点</p>
</li>
</ul>
<p><img src="/posts/79666db/image-20241104182021725.png" alt="image-20241104182021725"></p>
<h5 id="2-森林的遍历"><a href="#2-森林的遍历" class="headerlink" title="2.森林的遍历"></a>2.森林的遍历</h5><p>将森林看作3部分构成</p>
<ol>
<li>森林中第一棵树的根结点;</li>
<li>森林中第一棵树的子树森林，</li>
<li>森林中其它树构成的森林。</li>
</ol>
<h6 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h6><p>若森林不空 则：</p>
<ol>
<li>访问森林中第一棵树的<strong>根结点;</strong></li>
<li><strong>先序遍历</strong>森林中第一棵树的子树森林;</li>
<li><strong>先序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</li>
</ol>
<p><img src="/posts/79666db/image-20241104182719934.png" alt="image-20241104182719934"></p>
<h6 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h6><p>若森林不空，则</p>
<p>​    1.<strong>中序遍历</strong>森林中第一棵树的子树森林;</p>
<p>​     2.访问森林中第一棵树的<strong>根结点;</strong></p>
<p>​     3.<strong>中序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</p>
<p>对应：213</p>
<h6 id="3-小案例"><a href="#3-小案例" class="headerlink" title="3.小案例"></a>3.小案例</h6><p><img src="/posts/79666db/image-20241104183504031.png" alt="image-20241104183504031"></p>
<h3 id="7-哈夫曼树及其应用"><a href="#7-哈夫曼树及其应用" class="headerlink" title="7.*哈夫曼树及其应用"></a>7.*哈夫曼树及其应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">408要求：</span><br><span class="line">1．哈夫曼（Huffman）树和哈夫曼编码</span><br><span class="line"></span><br><span class="line">2．并查集及其应用</span><br><span class="line"></span><br><span class="line">3．堆及其应用（25新增）</span><br></pre></td></tr></table></figure>
<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径</p>
<p><strong>结点路径的长度</strong>:两结点间的路径上的分支数</p>
<p><img src="/posts/79666db/image-20241107090341596.png" alt="image-20241107090341596"></p>
<p><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和，记作TL</p>
<p><img src="/posts/79666db/image-20241107090440851.png" alt="image-20241107090440851"></p>
<p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p>
<p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong></p>
<p><strong>结点的带权路径长度</strong>：从<strong>根节点</strong>到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p>
<p><strong>树的带权的路径长度</strong>：树中的所有<strong>叶子</strong>结点<strong>带权路径长度之和</strong>(WPL)</p>
<p><img src="/posts/79666db/image-20241107091528322.png" alt="image-20241107091528322"></p>
<p><strong>最优树</strong>：带权路径最短的树（最优树）度要相同</p>
<p><strong>最优二叉树</strong>：带权路径长度(WPL)最短的二叉树</p>
<p> 满二叉树不一定是哈夫曼树</p>
<p>具有相同带权结点的哈夫曼树不唯一</p>
<p><strong>贪心算法</strong>：构造哈夫曼树时首先选择权最小的叶子结点</p>
<h4 id="2-哈夫曼算法"><a href="#2-哈夫曼算法" class="headerlink" title="2.哈夫曼算法"></a>2.哈夫曼算法</h4><h5 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h5><ol>
<li><p>根据<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个给定的权值<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="14.571ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 6440.4 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1380.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1825.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3205.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(3650.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="msub" transform="translate(4989.1,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>构成的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>棵二叉树的森林<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="16.839ex" height="1.977ex" role="img" focusable="false" viewbox="0 -680 7442.9 874"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(1026.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2082.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1020.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1465.2,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2485.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2930.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="msub" transform="translate(4269.1,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>,其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.889ex" role="img" focusable="false" viewbox="0 -677 911 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>只有一个带权为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.875ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1271 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的根节点</p>
<p>​    构造森林全是根</p>
</li>
<li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</p>
<p>​           选用两小造新树</p>
</li>
<li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中删除这两棵树，同时将新得到的二叉校加入森林中。·</p>
</li>
</ol>
<p>​             删除两小添新人</p>
<p>​    4. 重复2，3剩单根</p>
<p><img src="/posts/79666db/image-20241107094439746.png" alt="image-20241107094439746"></p>
<p><img src="/posts/79666db/image-20241107095725435.png" alt="image-20241107095725435"></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol>
<li>哈夫曼树的结点只有度为0或2的没有度为1的结点</li>
<li>包含n各叶子结点的哈夫曼树共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.386ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2822.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1322.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2322.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点</li>
<li>包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点</li>
<li>在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。</li>
<li>经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。</li>
<li>可见:哈夫曼树中共有n+n-1 = 2n-1个结点，且其所有的分支结点的度均不为1。</li>
</ol>
<h5 id="2-哈夫曼树的算法"><a href="#2-哈夫曼树的算法" class="headerlink" title="2.哈夫曼树的算法"></a>2.哈夫曼树的算法</h5><h6 id="顺序结构（一维数组）"><a href="#顺序结构（一维数组）" class="headerlink" title="顺序结构（一维数组）"></a>顺序结构（一维数组）</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="type">int</span> parent,lch,rch;<span class="comment">//双亲，左孩子，右孩子</span></span><br><span class="line">}HTNode,*HUffmanTree;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241107101801514.png" alt="image-20241107101801514"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span> <span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n)</span>{<span class="comment">//构造哈夫曼树——哈夫曼算法</span></span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;<span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT=new HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;++i){<span class="comment">//将2n-1个元素的Ich、rch、parent置为O</span></span><br><span class="line">    HT[i].lch=<span class="number">0</span>; HT[i].rch=<span class="number">0</span>; HT[i].parent=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;HT[i].weight;<span class="comment">//输入前n个元素的weight值</span></span><br><span class="line"><span class="comment">// 初始化结束，下面开始建立哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=n+<span class="number">1</span>;i&lt;=m; i++){<span class="comment">//合并产生n-1个结点——构造Huffman树</span></span><br><span class="line">     Select(HT, i<span class="number">-1</span>,s1,s2);<span class="comment">//在HT[k](1≤ksi-1)中选择两个其双亲域为0，</span></span><br><span class="line">                           <span class="comment">//且权值最小的结点,并返回它们在HT中的序号s1和s2</span></span><br><span class="line">HT[s1].parent=i; HT[s2] .parent=i;<span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">HT[i].llch=s1;HT[i].rch=s2;<span class="comment">//s1,s2分别作为i的左右孩子</span></span><br><span class="line">HT[i].weight=HT[s1].weight + HT[s2].weight;<span class="comment">//i的权值为左右孩子权值之和</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化HT[1…….2n-1]: lch=rch=parent=0</li>
<li>输入初始n个叶子结点:置HT[1…..n]的weight值;</li>
<li>进行以下n-1次合并，依次产生n-1个结点HT[i], i=n+1…..2n-1:</li>
</ol>
<ul>
<li>a)在HT[1..i-1]中选两个未被选过(从parent ==0的结点中选)的weight最小的两个结点HT[s1]和HT[s2], s1、s2为两个最小结点下标;</li>
<li>b)修改HT[s1]和HT[s2]的parent的值：HT[s1].parent=i;HT[s2].parent=i;</li>
<li>c)修改新产生的HT[i]:<br>.HT[i].weight=HT[s1].weight + HT[s2].weight;. HT[i]. Ich=s1; HT[i]. rch=s2;</li>
</ul>
<h4 id="3-哈夫曼编码"><a href="#3-哈夫曼编码" class="headerlink" title="3.哈夫曼编码"></a>3.哈夫曼编码</h4><p>前缀编码：任意一字符不是另一个字符的前缀</p>
<h5 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h5><p>1、统计字符集中每个字符在电文中出现的平均概率 (概率越大，<br>要求编码越短)。<br>2、利用哈夫曼树的特点:权越大的叶子离根越近;将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。<br>3、在哈夫曼树的每个分支上标上O或1:<br>    结点的左分支标0，右分支标1<br>    把从根到每个吐子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p>
<p><img src="/posts/79666db/image-20241107110159328.png" alt="image-20241107110159328"></p>
<p><img src="/posts/79666db/image-20241107112200535.png" alt="image-20241107112200535"></p>
<p> 左分支标记0，右分支标记1</p>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>1.为什么哈夫曼编码能够保证是前缀编码?</p>
<p>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p>
<p>2.为什么哈夫曼编码能够保证字符编码总长最短?<br>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p>
<p><strong>性质</strong>1：哈夫曼编码是前缀编码</p>
<p><strong>性质</strong>2：哈夫曼编码是最优前缀码</p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp; HC, <span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line">    <span class="type">int</span> i,cd,start;</span><br><span class="line">    HC=new <span class="type">char</span> *[n+<span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line"></span><br><span class="line">    cd=new <span class="type">char</span> [n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line"></span><br><span class="line">    cd[n<span class="number">-1</span>]=<span class="string">'\0’;//编码结束符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for(i=1; i&lt;=n; ++i){//逐个字符求哈夫曼编码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    start=n-1; c=i; f=HT[i].parent;</span></span><br><span class="line"><span class="string">    while(f!=O){//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line"><span class="string">    --start;//回溯一次start向前指一个位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (HT[f].Ichild= =c) cd[start]= '</span>O<span class="number">'</span> ;<span class="comment">//结点c是f的左孩子，则生成代码O</span></span><br><span class="line">    <span class="keyword">else</span> cd[start]= <span class="string">'1'</span> ;<span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">    c=f; f=HT[f].parent;<span class="comment">//继续向上回溯</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//求出第i个字符的编码</span></span><br><span class="line">HC[i]= new <span class="type">char</span> [n-start];<span class="comment">//为第i个字符串编码分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(HC[i],&amp;cd[start]);<span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">delete cd;<span class="comment">//释放临时空间</span></span><br><span class="line"></span><br><span class="line">}<span class="comment">// CreatHuffanCode</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241107135013070.png" alt="image-20241107135013070"></p>
<h4 id="4-编码的实现"><a href="#4-编码的实现" class="headerlink" title="4.编码的实现"></a>4.编码的实现</h4><p><img src="/posts/79666db/image-20241107140225327.png" alt="image-20241107140225327"></p>
<p><img src="/posts/79666db/image-20241107140705475.png" alt="image-20241107140705475"></p>
<h2 id="八、图"><a href="#八、图" class="headerlink" title="八、图"></a>八、图</h2><h3 id="1-图的定义和基本术语"><a href="#1-图的定义和基本术语" class="headerlink" title="1.图的定义和基本术语"></a>1.图的定义和基本术语</h3><h4 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1.图的定义"></a>1.图的定义</h4><p><strong>图</strong>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3722.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
<p>​         V:顶点（数据元素）的有穷非空集合</p>
<p>​         E:边的有穷集合</p>
<p><strong>无向图</strong>：每条边都没有方向</p>
<p><strong>有向图</strong>:每条边都有方向</p>
<p><img src="/posts/79666db/image-20241107141712274.png" alt="image-20241107141712274"></p>
<p><strong>完全图</strong>：任意两个点都有一条边相连</p>
<p><img src="/posts/79666db/image-20241107141847834.png" alt="image-20241107141847834"></p>
<p><strong>稀疏图</strong>：有很少边或弧的图（e&lt;nlogn)</p>
<p><strong>稠密图</strong>：有较多边或弧的图</p>
<p><strong>网</strong>：边/弧带权的图</p>
<p><strong>邻接</strong>:有边/弧相连的两个顶点之间的关系。</p>
<p>​       存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="6.547ex" height="2.363ex" role="img" focusable="false" viewbox="0 -750 2893.9 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1201,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1645.6,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(2504.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，则称<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>;互为<strong>邻接点</strong>;(无向图)</p>
<p>​        存在$<v_i, v_j>$，则称v<strong>邻接到</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container><strong>邻接于</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>(有向图)</v_i,></p>
<p><strong>关联</strong>：边/弧与顶点的关系</p>
<p>​           存在$(V_i,V_j)/<v_i,v_j><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.231ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8500 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">称</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">该</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">边</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(4500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">弧</text></g><g data-mml-node="mi" transform="translate(5500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">关</text></g><g data-mml-node="mi" transform="translate(6500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">联</text></g><g data-mml-node="mi" transform="translate(7500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">于</text></g></g></g></svg></mjx-container>v_i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 1000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g></g></svg></mjx-container>v_j$</v_i,v_j></p>
<p><strong>顶点的度</strong>:与该顶点相关联的边的数目，记为TD(v)</p>
<p>在有向图中，顶点的度等于该顶点的入度与出度之和。</p>
<p>顶点v的入度是以v为终点的有向边的条数,记作ID(v)</p>
<p>顶点v的出度是以v为始点的有向边的条数,记作OD(v)</p>
<p><img src="/posts/79666db/image-20241107142753964.png" alt="image-20241107142753964"></p>
<p><strong>路径</strong>：接续的边构成的顶点序列</p>
<p><strong>路径长度</strong>:路径上边或弧的数目/权值之和。<br><strong>回路(环)</strong>:第一个顶点和最后一个顶点相同的路径。<br><strong>简单路径</strong>:除路径起点和终点可以相同外，其余顶点均不相同的路径。</p>
<p><strong>简单回路(简单环)</strong>:除路径起点和终点相同外，其余顶点均不相同的路径。</p>
<p><img src="/posts/79666db/image-20241107144251328.png" alt="image-20241107144251328"></p>
<p><strong>连通图(强连通图)</strong><br>在无(有)向图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3722.2,0)"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>中，若对任何两个顶点v、u都右在从v至到u的路径称G是连通图(裾连通图)</p>
<p><img src="/posts/79666db/image-20241107144721137.png" alt="image-20241107144721137"></p>
<p><strong>权与网</strong><br>图中边或弧所具有的相关数称为<strong>权</strong>。表明从一个顶点到另一个顶点的距离或耗费。<br>带权的图称为<strong>网</strong>。</p>
<p><strong>子图</strong><br>设有两个图G= (V，{E})、G1= (V1，{E1})，若V1⊆V,E1⊆E,则称G1是G的子图</p>
<p><img src="/posts/79666db/image-20241107145900753-1730962741866-1.png" alt="image-20241107145900753"></p>
<p><strong>连通分量（强连通分量)</strong><br>无向图G的<strong>极大连通子图</strong>称为G的<strong>连通分量</strong>。<br>极大连通子图意思是:该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。</p>
<p><img src="/posts/79666db/image-20241107150554317.png" alt="image-20241107150554317"></p>
<p>有向图G的极大强连通子图称为G的<strong>强连通分量</strong></p>
<p>极大强连通子图意思是:该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p>
<p><img src="/posts/79666db/image-20241107150813934.png" alt="image-20241107150813934"></p>
<p><strong>极小连通子图:</strong>该子图是G的连通子图，在该子图中删除任何一天边子图不再连通。<br><strong>生成树:</strong>包含无向图G所有顶点的极小连通子图。<br><strong>生成森林:</strong>对非连通图，由各个连通分量的生成树的集合。</p>
<p><img src="/posts/79666db/image-20241107151129261.png" alt="image-20241107151129261"></p>
<h3 id="2-图的类型定义"><a href="#2-图的类型定义" class="headerlink" title="2.图的类型定义"></a>2.图的类型定义</h3><h4 id="1-图的抽象数据类型定义如下"><a href="#1-图的抽象数据类型定义如下" class="headerlink" title="1.图的抽象数据类型定义如下:"></a>1.图的抽象数据类型定义如下:</h4><p>ADT Graph{<br>            <strong>数据对象V</strong>:具有相同特性的数据元素的集合，称为<strong>顶点集。</strong><br>            <strong>数据关系R:</strong> R={VR}<br>                        VR={<v,w>|<v,w> | v,w⊆V ^ p(v,w),<br>                                <v,w>表示从v到w的弧，P(v,w)定义了弧<v,w>的信息</v,w></v,w></v,w></v,w></p>
<p>}</p>
<h4 id="2-图的操作"><a href="#2-图的操作" class="headerlink" title="2. 图的操作"></a>2. 图的操作</h4><p><img src="/posts/79666db/image-20241107152052212.png" alt="image-20241107152052212"></p>
<h4 id="3-图的存储结构"><a href="#3-图的存储结构" class="headerlink" title="3.图的存储结构"></a>3.图的存储结构</h4><p><img src="/posts/79666db/image-20241107152459776.png" alt="image-20241107152459776"></p>
<h5 id="1-数组（邻接矩阵）表示法"><a href="#1-数组（邻接矩阵）表示法" class="headerlink" title="1.数组（邻接矩阵）表示法"></a>1.数组（邻接矩阵）表示法</h5><p><img src="/posts/79666db/image-20241107152717210.png" alt="image-20241107152717210"></p>
<h6 id="无向图邻接矩阵"><a href="#无向图邻接矩阵" class="headerlink" title="无向图邻接矩阵"></a>无向图邻接矩阵</h6><p><img src="/posts/79666db/image-20241107153625208.png" alt="image-20241107153625208"></p>
<p>分析1：无向图的邻接矩阵是对称的</p>
<p>分析2：顶点i的度=第i行（列）中的1的个数</p>
<p>特别：完全的邻接矩阵中，对角元素为0，其余为1</p>
<h6 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h6><p><img src="/posts/79666db/image-20241107155521228.png" alt="image-20241107155521228"></p>
<p>分析1：有向图的邻接矩阵可能不是对称的</p>
<p>分析2：顶点的出度=第i行元素之和（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1019.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container> 指向&amp;V_2&amp; 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container>）</p>
<p>顶点的出度=第i列元素之和</p>
<p>​              顶点的度=第i行元素之和+第i列元素之和</p>
<h5 id="有向网的邻接矩阵"><a href="#有向网的邻接矩阵" class="headerlink" title="有向网的邻接矩阵"></a>有向网的邻接矩阵</h5><p>网（即有权图)的邻接矩阵表示法</p>
<p>定义为</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.403ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9018 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1723.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2174.7,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(2607.7,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(3076.7,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3354.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3699.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3977.7,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(4255.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(4667.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(5223.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(6279.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(7550.2,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(8240,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g></g></g></svg></mjx-container>V_i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="0.629ex" height="0.713ex" role="img" focusable="false" viewbox="0 -121 278 315"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2444.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1055.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">或</text></g><g data-mml-node="mo" transform="translate(2055.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g></g></g></svg></mjx-container>V_i,V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.951ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3072.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(666.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1544.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2313.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></svg></mjx-container></p>
<p>​                  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"/></g></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">无</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">边</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">弧</text></g></g></g></svg></mjx-container></p>
<p>如果两个顶点之间存在弧或边，那么我就记录两个顶点为权<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="3.808ex" height="2.007ex" role="img" focusable="false" viewbox="0 -683 1683 887"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(1271,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>，如果不存在则记录无穷大</p>
<p><img src="/posts/79666db/image-20241109095058803.png" alt="image-20241109095058803"></p>
<h4 id="2-邻接矩阵的存储形式"><a href="#2-邻接矩阵的存储形式" class="headerlink" title="2.邻接矩阵的存储形式"></a>2.邻接矩阵的存储形式</h4><h6 id="1-用两个数组分别存储顶点表和邻接矩阵"><a href="#1-用两个数组分别存储顶点表和邻接矩阵" class="headerlink" title="1.用两个数组分别存储顶点表和邻接矩阵"></a>1.用两个数组分别存储顶点表和邻接矩阵</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//设顶点的娄文据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">VerTexType vexs[MVNum]; <span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前点数和边数</span></span><br><span class="line">}AMGraph; <span class="comment">// Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure>
<h5 id="2-采用邻接矩阵表示法创建无向网"><a href="#2-采用邻接矩阵表示法创建无向网" class="headerlink" title="2.采用邻接矩阵表示法创建无向网"></a>2.采用邻接矩阵表示法创建无向网</h5><h6 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h6><p>​    (1)输入总顶点数和总边数。</p>
<p>   (2)依次输点的信息存人顶点表中。</p>
<p>（3）初始化邻接矩阵，使每个权值初始化为极大值。</p>
<p>（4）构造邻接矩阵</p>
<p>代码先欠着</p>
<h5 id="3-邻接矩阵的好处和坏处"><a href="#3-邻接矩阵的好处和坏处" class="headerlink" title="3.邻接矩阵的好处和坏处"></a>3.邻接矩阵的好处和坏处</h5><h6 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h6><ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”(有边直接相连的顶点)</li>
<li>方便计算任一顶点的“度”(从该点发出的边数为“出度”，指向该点的边数为“入度”)·无向图:对应行（或列)非O元素的个数·有向图:对应行非0元素的个数是“出度”;对应列非0元素的个数是“入度”</li>
</ul>
<h6 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h6><ul>
<li>不便于增加和删除顶点</li>
<li><p>浪费空间——传稀疏图人点很多而边很少）有大量无效元素</p>
</li>
<li><p>​           对稠密图（特别是完全图)还是很合算的</p>
</li>
<li><p>浪费时间——统计稀疏图中一共有多少条边</p>
</li>
</ul>
<h4 id="3-邻接表表示法（链式）"><a href="#3-邻接表表示法（链式）" class="headerlink" title="3.邻接表表示法（链式）"></a>3.邻接表表示法（链式）</h4><h5 id="1-无向图的邻接表"><a href="#1-无向图的邻接表" class="headerlink" title="1.无向图的邻接表"></a>1.无向图的邻接表</h5><ul>
<li>·顶点:</li>
</ul>
<p>​             ·按编号顺序将顶点数据存储在一维数组中;·</p>
<ul>
<li><p>关联同一顶点的边(以顶点为尾的弧)︰</p>
<p>​      ·用线性链表存储</p>
</li>
</ul>
<p><img src="/posts/79666db/image-20241109105841878.png" alt="image-20241109105841878"></p>
<p>data表示顶点本身，firstarc表示第一条边的指针（以v1为例子，下标为3或为1的元素的指针）adjvex表示邻接的顶点，nextarc表示下一元素的指针</p>
<h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点:"></a>特点:</h6><ul>
<li>·邻接表不唯一</li>
<li>·若无向图中有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 466 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>条边，则其邻接表需<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个头结点和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container> 个表结点。适宜存储稀疏图。</li>
<li>无向图中顶点v的度为第i个单链表中的结点数。</li>
</ul>
<h5 id="2-有向图"><a href="#2-有向图" class="headerlink" title="2.有向图"></a>2.有向图</h5><p><img src="/posts/79666db/image-20241109111503505.png" alt="image-20241109111503505"></p>
<h6 id="特点-4"><a href="#特点-4" class="headerlink" title="特点:"></a>特点:</h6><blockquote>
<p>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>出度</strong>为第i个单链表中的结点个数。<br>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>入度</strong>为整个单链表中邻接点域值是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.677ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2067.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1567.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>的结点个数。</p>
</blockquote>
<p><img src="/posts/79666db/image-20241109112935783.png" alt="image-20241109112935783"></p>
<h5 id="3-链式代码"><a href="#3-链式代码" class="headerlink" title="3.链式代码"></a>3.链式代码</h5><h6 id="1-定义代码"><a href="#1-定义代码" class="headerlink" title="1.定义代码"></a>1.定义代码</h6><p>顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>{</span></span><br><span class="line">    </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息--类型自义定</span></span><br><span class="line">    ArcNode * firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">    </span><br><span class="line">}VNode,AdjList[MVNum]; <span class="comment">//AdjList表示邻接表类型,MVNUM为最大数组数</span></span><br></pre></td></tr></table></figure>
<p>边结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>{</span><span class="comment">//边结点</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">}ArcNode;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241109122123413.png" alt="image-20241109122123413"></p>
<p>图结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">     AdjList vertices;<span class="comment">//vertices--vertex的复数顶点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">} ALGraph;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p><img src="/posts/79666db/image-20241109123727673.png" alt="image-20241109123727673"></p>
<h6 id="2-采用邻接表表示法创建无向网的算法思想"><a href="#2-采用邻接表表示法创建无向网的算法思想" class="headerlink" title="2.采用邻接表表示法创建无向网的算法思想"></a>2.采用邻接表表示法创建无向网的算法思想</h6><p>【算法思想】</p>
<ol>
<li>输入总顶点数和总边数。</li>
<li>建立顶点表<br>依次输入点的信息存入顶点表中<br>使每个表头结点的指针域初始化为NULL</li>
<li>创建邻接表<br>依次输入每条边依附的两个顶点确定两个顶点的序号i和j，建立边结点<br>将此边结点分别插入到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="2.211ex" role="img" focusable="false" viewbox="0 -683 957.3 977.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>对应的两个边链表的头部</li>
</ol>
<h4 id="5-邻接表的特点"><a href="#5-邻接表的特点" class="headerlink" title="5.邻接表的特点"></a>5.邻接表的特点</h4><h5 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h5><ul>
<li><p>·方便找任一顶点的所有“邻接点”</p>
</li>
<li><p>·节约稀疏图的空间</p>
<p>​    需要N个头指针＋2E个结点(每个结点至少2个域)·</p>
</li>
<li><p>方便计算任一顶点的“度”?</p>
<pre><code>对无向图:是的
</code></pre><p>   对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算入度”</p>
</li>
<li><p>·不方便检查任意、对顶点间是否存在边</p>
</li>
</ul>
<h4 id="4-邻接矩阵与邻接表表示方法的关系"><a href="#4-邻接矩阵与邻接表表示方法的关系" class="headerlink" title="4.邻接矩阵与邻接表表示方法的关系"></a>4.邻接矩阵与邻接表表示方法的关系</h4><p><img src="/posts/79666db/image-20241109131228879.png" alt="image-20241109131228879"></p>
<h5 id="2-联系"><a href="#2-联系" class="headerlink" title="2.联系:"></a>2.<strong>联系:</strong></h5><p>邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p>
<h5 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别:"></a>2.区别:</h5><p>对于任一确定的无向图，邻接矩阵是唯一的(行列号与顶点编号一致)，但邻接表不唯一（链接次序与顶点编号无关）。</p>
<p>邻接矩阵的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>,而邻接表的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
<h5 id="3-用途"><a href="#3-用途" class="headerlink" title="3.用途:"></a>3.用途:</h5><p>邻接矩阵多用于榈密图;而邻接表多用于稀疏图</p>
<h4 id="5-十字链表"><a href="#5-十字链表" class="headerlink" title="5.十字链表"></a>5.十字链表</h4><p><img src="/posts/79666db/image-20241109132236978.png" alt="image-20241109132236978"></p>
<h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><p><strong>十字链表</strong>(Orthogonal List)是<strong>有向图</strong>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。<br>有向图中的每一条弧对应十字链表中的一个<strong>弧结点</strong>，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做<strong>顶点结点。</strong></p>
<h5 id="2-具体"><a href="#2-具体" class="headerlink" title="2.具体"></a>2.具体</h5><p>data:数据</p>
<p>firstin:第一个入度边</p>
<p>firstout:第一个出度边</p>
<p>tailvex:弧尾位置</p>
<p>headvex:弧头位置</p>
<p>hlink:弧头相同的下一条弧</p>
<p>tlink:弧尾相同的下一条弧</p>
<p><img src="/posts/79666db/image-20241109134222311.png" alt="image-20241109134222311"></p>
<h4 id="6-邻接多重表"><a href="#6-邻接多重表" class="headerlink" title="6.邻接多重表"></a>6.邻接多重表</h4><p>  <img src="/posts/79666db/image-20241109144018754.png" alt="image-20241109144018754"></p>
<p> <img src="/posts/79666db/image-20241109144858776.png" alt="image-20241109144858776"></p>
<h3 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4.图的遍历"></a>4.图的遍历</h3><h4 id="1-定义-7"><a href="#1-定义-7" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>遍历定义:</strong></p>
<p>从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做<strong>图的遍历</strong>，它是图的基本运算</p>
<p><strong>遍历实质</strong>:找每个顶点的邻接点的过程。</p>
<p><strong>图的特点</strong>:<br>图中可能存在<strong>回路</strong>，且图的任一顶点都可能与其它顶点相通在访问完某个顶点之后可能会沿着某些边<strong>又回到了曾经访问过的顶点。</strong></p>
<p><strong>如何避免回路</strong>:</p>
<p>解决思路:设置<strong>辅助数组</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.382ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4147 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3869,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，用来标记每个被访问过的顶点。</p>
<ul>
<li>初始状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为0</li>
<li>·顶点i被访问，改<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为1，防止被多次访问</li>
</ul>
<h4 id="2-深度优先-DFS"><a href="#2-深度优先-DFS" class="headerlink" title="2.深度优先(DFS)"></a>2.深度优先(DFS)</h4><h5 id="1-连通图的遍历"><a href="#1-连通图的遍历" class="headerlink" title="1.连通图的遍历"></a>1.连通图的遍历</h5><h6 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h6><ul>
<li>在访问图中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1</li>
<li>再从w出发，访问与w邻接但还未被访问过的顶点W2;</li>
<li>然后再从w出发，进行类似的访问，…</li>
<li>如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。</li>
<li>如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;</li>
<li>如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</li>
</ul>
<p><img src="/posts/79666db/image-20241109151227573.png" alt="image-20241109151227573"></p>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><img src="/posts/79666db/image-20241109154118743.png" alt="image-20241109154118743"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span><span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line">   <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G;v++)</span><br><span class="line">   {</span><br><span class="line">       visited[v]=<span class="literal">false</span>;<span class="comment">//初始化已访问数组</span></span><br><span class="line">       <span class="keyword">for</span> ( v = <span class="number">0</span>; v &lt; G; ++v) {<span class="comment">//从v0开始遍历</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[v])</span><br><span class="line">           {</span><br><span class="line">               DFS(G,v);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Grap G,<span class="type">int</span> V)</span><span class="comment">//从顶点v出发，深度遍历图G</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    visit(v);<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))<span class="comment">//依次检查邻接矩阵v所在的行 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])<span class="comment">//w为v还没访问的邻接顶点</span></span><br><span class="line">        {</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h6><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2577.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>用邻接表来表示图，虽然有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>.</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论:"></a><strong>结论</strong>:</h6><ul>
<li><strong>稠密图</strong>适于在邻接矩阵上进行深度遍历;</li>
<li><strong>稀疏图</strong>通于在邻接表上进行深度遍历。</li>
</ul>
<h4 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h4><h5 id="1-方法-1"><a href="#1-方法-1" class="headerlink" title="1.方法"></a>1.方法</h5><p>方法:从图的某一结点出发，首先依次访问该结点的所有邻接点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="13.127ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 5802 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1019.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1464.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2483.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2928.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(4267.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(4711.8,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>,再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点<br>重复此过程，直至所有顶点均被访问为止。</p>
<p><img src="/posts/79666db/image-20241110090045314.png" alt="image-20241110090045314"></p>
<h5 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"><span class="type">bool</span> visited [Max_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Grap G)</span>{<span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) {</span><br><span class="line">        visited[i]=<span class="literal">false</span>;<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    }</span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;G.vexnum ; ++i) {<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i]){<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>{<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//对v做以访问标志</span></span><br><span class="line">    Enqueue(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)){</span><br><span class="line">        DeQueue(Q,v);<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = FirstNeighbor(G,v); w&gt;<span class="number">0</span> ; w=NextNeighbor(G,v,w)) {</span><br><span class="line">                                           <span class="comment">//检测到v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w]){<span class="comment">//w为v未访问的邻接顶点</span></span><br><span class="line">                visit(w);<span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;<span class="comment">//对w做以访问标记</span></span><br><span class="line">                Enqueue(Q,w);<span class="comment">//顶点w入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-效率分析"><a href="#3-效率分析" class="headerlink" title="3.效率分析"></a>3.效率分析</h5><ul>
<li>如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要<br>循环检测矩阵中的整整一行（ n个元素)，总的时间代价为O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.912ex" role="img" focusable="false" viewbox="0 -833.9 1036.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>)。</li>
<li>用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li>
</ul>
<h5 id="4-效率比较"><a href="#4-效率比较" class="headerlink" title="4.效率比较"></a>4.效率比较</h5><ul>
<li>·空间复杂度相同，都是O(n)(借用了堆栈或队列) ;</li>
<li>·时间复杂度只与存储结构,(邻接矩阵或邻接表)有关，而与搜索路径无关。</li>
</ul>
<h3 id="5-图的应用"><a href="#5-图的应用" class="headerlink" title="5.图的应用"></a>5.图的应用</h3><h4 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1.最小生成树"></a>1.最小生成树</h4><h5 id="1-生成树的简介"><a href="#1-生成树的简介" class="headerlink" title="1.生成树的简介"></a>1.生成树的简介</h5><p><strong>生成树</strong>：所有顶点均由边连接在一起，但不存在回路</p>
<p><img src="/posts/79666db/image-20241110095716787.png" alt="image-20241110095716787"></p>
<blockquote>
<p>一个图可以有许多棵不同的生成树</p>
<p>所有生成树具有以下共同特点</p>
<ul>
<li>生成树的顶点个数与图的<strong>顶点个数相同;</strong></li>
<li>生成树是图的<strong>极小连通子图</strong>，去掉一条边则非连通;·</li>
<li>一个有n个顶点的连通图的生成树有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>条边;</li>
<li><strong>·在生成树中再加一条边必然形成回路。</strong></li>
<li>生成树中任意两个顶点间的<strong>路径是唯一</strong>的;</li>
</ul>
<p>含有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>条边的图不一定是最小生成树</p>
<p><img src="/posts/79666db/image-20241110095828535.png" alt="image-20241110095828535"></p>
</blockquote>
<h5 id="2-无向图的生成树"><a href="#2-无向图的生成树" class="headerlink" title="2.无向图的生成树"></a>2.无向图的生成树</h5><p><img src="/posts/79666db/image-20241110100335510.png" alt="image-20241110100335510"></p>
<h5 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3.最小生成树"></a>3.最小生成树</h5><p><strong>最小生成树</strong>:给定一个无向网络在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。</p>
<p><img src="/posts/79666db/image-20241110100803730.png" alt="image-20241110100803730"></p>
<h6 id="构造最小生成树"><a href="#构造最小生成树" class="headerlink" title="构造最小生成树"></a>构造最小生成树</h6><p>构造最小生成树的算法很多，其中多数算法都利用了<strong>MST</strong>的性质。</p>
<p><strong>MST性质</strong>:设N =(V, E)是一个连通网,U是顶点集V的一个非空子集。若边(u, v)是一条具有最小权值的边，其中u∈u,v∈V-U,则必存<br>在一棵包含边(u, v)的最小生成树。</p>
<h6 id="Prim-普里姆算法"><a href="#Prim-普里姆算法" class="headerlink" title="Prim-普里姆算法"></a>Prim-普里姆算法</h6><p>算法思想</p>
<blockquote>
<p>设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.229ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4963.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(4574.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>是连通网，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>是N上最小生成树中边的集合。</p>
<p>初 始 令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="7.01ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 3098.5 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2100.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.025ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3989.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1675.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(2553.1,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3322.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3711.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>TE=${ }。</p>
<p>在所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="5.644ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 2494.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(849.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1727.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.952ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4399 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(762.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1640.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(2631.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3632,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g></g></g></svg></mjx-container>的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.501ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4199.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(1890.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2557.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(3435.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>中，找一条代价最小的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>并入集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>，同时<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>并入U</p>
<p>重复上述操作直至<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.492ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 2869.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2100.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g></g></g></svg></mjx-container>，则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.437ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5497.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3640.2,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(4344.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(5108.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g></g></g></svg></mjx-container>的最小生成树。</p>
</blockquote>
<p>从顶点往下找最小的权</p>
<h6 id="Kruskal-克鲁斯卡尔算法"><a href="#Kruskal-克鲁斯卡尔算法" class="headerlink" title="Kruskal-克鲁斯卡尔算法"></a>Kruskal-克鲁斯卡尔算法</h6><p>所有边按权值排序,然后选择最小的</p>
<p>当有循环时舍弃这条边</p>
<p>当所有边连通时结束</p>
<p>与prim算法不同的是他是按排序来找最小,prim是依次选最小</p>
<blockquote>
<p>设连通网<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.261ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4977.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4588.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，令最小生D树初始状态为只有n个顶点而无边的非连通图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.116ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4029.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3640.2,0)"/><g data-mml-node="mo" transform="translate(3640.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>,每个顶点自成一个连通分量。</p>
<p>在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即:不能形成环)，则将此边加入到T中;否则，舍去此边，选取下一条代价最小的边。</p>
<p>依此类推，直至T中所有顶点都在同一连通分量上为止。</p>
</blockquote>
<p>最小生成树可能不唯一</p>
<h6 id="两种比较"><a href="#两种比较" class="headerlink" title="两种比较"></a>两种比较</h6><p><img src="/posts/79666db/image-20241110111651349.png" alt="image-20241110111651349"></p>
<h4 id="2-最短路径"><a href="#2-最短路径" class="headerlink" title="2.最短路径"></a>2.最短路径</h4><h5 id="1-定义-8"><a href="#1-定义-8" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>最短路径与最小生成树不同</strong>，路径上不一定包含n个顶点，也不一定包含n-1条边。</p>
<p>单源最短路径-Dijkstra迪杰斯特拉算法</p>
<p><img src="/posts/79666db/image-20241110112448263.png" alt="image-20241110112448263"></p>
<p>所有顶点间的最短路径—Floyd弗洛伊德算法</p>
<p><img src="/posts/79666db/image-20241110112715538-1731209239025-1.png" alt="image-20241110112715538"></p>
<h5 id="2-Dijkstra算法"><a href="#2-Dijkstra算法" class="headerlink" title="2.Dijkstra算法"></a>2.Dijkstra算法</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><blockquote>
<p>1.初始化:先找出从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到各终点v的直达路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.413ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3276.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1408.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1853.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2887.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, 即通过一条弧到达的路径。</p>
<p>2选择:从这些路径中找出一条长度最短的路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.121ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2705.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>3.更新:然后对其余各条路径进行适当调整:</p>
<p>​          若在图中存在弧<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.401ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2829.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1405.7,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2440.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> ，且<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="25.029ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11062.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2927.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(3928.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4317.1,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4889.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(5333.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(6270.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6936.9,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mo" transform="translate(7992.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(8381.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(9292.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(9737.3,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(10673.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>则以路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.689ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4282.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1397.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1842.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2414.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(2859.3,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(3893.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>代替<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3247.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2513.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2858.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<p>在调整后的各条路径中，再找长度最短的路径)依此类推。</p>
<p>(先找出直达的,然后与不直达的比较,有小的就更新被比较的)</p>
</blockquote>
<h6 id="具体-按路径长度递增次序产生最短路径"><a href="#具体-按路径长度递增次序产生最短路径" class="headerlink" title="具体-按路径长度递增次序产生最短路径"></a>具体-按路径长度递增次序产生最短路径</h6><blockquote>
<p>1、把V分成两组:辅助数组D存放。<br>       (1) S:已求出最短路径的顶点的集合。<br>       (2)T=V -s∶尚未确定最短路径的顶点集合。</p>
<p>2、将T中顶点按最短路径递增的次序加入到S中，</p>
<p>保证:(1）从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到S中各顶点的最短路径长度都不大于从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到T中任何顶点的最短路径长度。</p>
<p>(2)每个顶点对应一个距离值:<br>   S中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的最短路径长度。</p>
<p>​    T中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p>
</blockquote>
<p><img src="/posts/79666db/image-20241110143716951.png" alt="image-20241110143716951"></p>
<h5 id="3-Floyd-弗洛伊德算法"><a href="#3-Floyd-弗洛伊德算法" class="headerlink" title="3.Floyd 弗洛伊德算法"></a>3.Floyd 弗洛伊德算法</h5><h6 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h6><ul>
<li>·逐个顶点试探</li>
<li>·从到v,的所有可能存在的路径中·</li>
<li><p>选出一条长度最短的路径</p>
<p><img src="/posts/79666db/image-20241110151313801.png" alt="image-20241110151313801"></p>
</li>
</ul>
<h4 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h4><p>有向无环图：无环的有向图，简称DAG</p>
<p><img src="/posts/79666db/image-20241110151722949.png" alt="image-20241110151722949"></p>
<p>一个结点可能有多个前驱，但是没有回路</p>
<h5 id="1-AOV网"><a href="#1-AOV网" class="headerlink" title="1.AOV网"></a>1.AOV网</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p>用一个有向图表示一个工程的各子工程及其相冥制约的关系，其中<strong>以顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网(Activity On Vertex network)</p>
<h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><ul>
<li>若从i到j有一条有向路径，则i是j的前驱;j是i的后继。</li>
<li>若<i,j>是网中有向边，则i是j的直接前驱;j是i的直接后继</i,j></li>
<li>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</li>
</ul>
<h6 id="检测AOV-网中是否存在环方法"><a href="#检测AOV-网中是否存在环方法" class="headerlink" title="检测AOV 网中是否存在环方法:"></a>检测AOV 网中是否存在环方法:</h6><p>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV 网必定不存在环。</p>
<h5 id="2-AOE网"><a href="#2-AOE网" class="headerlink" title="2.AOE网"></a>2.AOE网</h5><p>用一个有向图表承一个工程的各子工程及其相互制约的关系,以<strong>弧表示活动</strong>，以<strong>顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网(Activity On Edge)。</p>
<h5 id="3-拓扑排序-1"><a href="#3-拓扑排序-1" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h5><p>在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列甲，I一疋排仕J的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序。</strong></i,j></p>
<p><img src="/posts/79666db/image-20241110160144846-1731225709478-3.png" alt="image-20241110160144846"></p>
<h4 id="4-关键路径"><a href="#4-关键路径" class="headerlink" title="4.关键路径"></a>4.关键路径</h4><p><img src="/posts/79666db/image-20241110165246291.png" alt="image-20241110165246291"></p>
<p>对于AOE网，我们关心两个问题:</p>
<p>(1)完成整项工程至少需要多少时间?</p>
<p>(2)哪些活动是影响工程进度的关键?</p>
<p>关键路径 ：路径长度最长的路径。<br>路径长度：路径上各活动持续时间之和。</p>
<p>———&gt;求解关键路径问题</p>
<p><img src="/posts/79666db/image-20241110171020097.png" alt="image-20241110171020097"></p>
<p>由若干个关键活动组成的就是关键路径</p>
<p><img src="/posts/79666db/image-20241110171553903.png" alt="image-20241110171553903"></p>
<p>ve(j)最早开始时间：从原点开始找到权的最大值</p>
<p> vl(n)最迟发生时间：从汇点向前，找到最小值</p>
<p><img src="/posts/79666db/image-20241110172431466-1731230673854-5.png" alt="image-20241110172431466"></p>
<p> 具体计算</p>
<p><img src="/posts/79666db/image-20241110173552506-1731231354674-9.png" alt="image-20241110173552506"></p>
<p>e(i)就是弧尾的长度</p>
<p>​        eg: v5就是6（v5连接的是v2，只用算v2），</p>
<p>l(i)就是vl-路径上的权值</p>
<p>​       eg: v5就是7-a4的权=7-1=6</p>
<p><img src="/posts/79666db/image-20241110174727136.png" alt="image-20241110174727136"></p>
<h5 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h5><p>1、若网中有几条关键路径,则需加快同时在几条关键路径上的关键活动。<br>           如: a11、a10、a8、a7。</p>
<p>2、如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。如: a1、a4。</p>
<p>3、处于所有的关键路径上的活动完成时间不能缩短太多)，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。      </p>
<p>​         如:a1由6天变成3天，就会改变关键路径。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://baskly.us.kg/">李阳</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lyay23.github.io/posts/79666db/">http://lyay23.github.io/posts/79666db/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lyay23.github.io" target="_blank">李阳的秘密小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/bg_4.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/c7b053e8/" title="java尚硅谷笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">java尚硅谷笔记</div></div><div class="info-2"><div class="info-item-1">Java 基础 第 1 阶段：基本语法——尚硅谷学习笔记（含面试题） 2023 年第 1 章 Java 语言概述 1.1 Java 基础阶段的学习内容1.1.1 第 1 阶段：Java...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李阳</div><div class="author-info-description">不积硅步 无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lyay23"><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lyay23" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3050681193@qq.com" target="_blank" title="icon-youxiang"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">要加油啦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">C语言—数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">一、数据结构之基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">1.数据结构的三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-text">数据的存储结构有几种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2、存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-text">索引存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%AD%98%E5%82%A8"><span class="toc-text">散列存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">3.算法特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">好算法特征：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">二、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">1.数组的优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-text">2.链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="toc-text">3.术语：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E8%8A%82%E7%82%B9"><span class="toc-text">首节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="toc-text">尾节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%9A"><span class="toc-text">头结点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88"><span class="toc-text">头指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">4.链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">5.分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95"><span class="toc-text">6.算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B9%B6%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA"><span class="toc-text">7.创建带头单链表并遍历输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E2%80%BB%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E2%80%BB"><span class="toc-text">8.※链表的基本操作※</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9D%8E%E9%98%B3%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">9.李阳的线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9D%8E%E9%98%B3%E7%9A%84%E5%B8%A6%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">10.李阳的带头单链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%88"><span class="toc-text">三、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB"><span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95"><span class="toc-text">3.算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8"><span class="toc-text">4.应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%88%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E2%80%94%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-text">5.栈的表达式求值—后缀表达式（逆波兰表达式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80"><span class="toc-text">6.后缀表达式转中缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9D%8E%E9%98%B3%E7%9A%84%E6%A0%88"><span class="toc-text">7.李阳的栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-text">四、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB-1"><span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81"><span class="toc-text">3.代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">4.队列的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9D%8E%E9%98%B3%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-text">5.李阳的队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9D%8E%E9%98%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">6.李阳的循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%92%E5%BD%92"><span class="toc-text">五、递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E2%80%94%E9%98%B6%E5%B1%82"><span class="toc-text">1.简单应用—阶层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%A6%81%E6%B1%82%EF%BC%8C%E6%84%8F%E4%B9%89"><span class="toc-text">2.定义，要求，意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">①定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-text">②递归需要满足的三个条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%84%8F%E4%B9%89"><span class="toc-text">③意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-text">④循环：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-text">六、串、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%B2%EF%BC%88string%EF%BC%89"><span class="toc-text">一、串（string）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%90%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.子串的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="toc-text">2.串的类型定义、存储结构及运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">3.串的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-1"><span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">4.串的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-BF%E7%AE%97%E6%B3%95%EF%BC%88%E7%A9%B7%E4%B8%BE%E6%B3%95%EF%BC%89"><span class="toc-text">1.BF算法（穷举法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E2%80%BB%E2%80%BB%E2%80%BB-KMP%E7%AE%97%E6%B3%95"><span class="toc-text">2.※※※ KMP算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-KMP%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-text">3.KMP算法改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">二、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">3.压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">1.对称矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">[特点]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="toc-text">[存储方法]</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-text">2.三角矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">[特点]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">[存储方法]</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%EF%BC%88%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="toc-text">3.对角矩阵（带状矩阵）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-text">4.稀疏矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">十字链表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-text">三.广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%A7%E8%B4%A8"><span class="toc-text">2.性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.广义表和线性表的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-text">4.广义表的基本运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%A0%91"><span class="toc-text">七、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-text">树的基本术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">树结构和线性结构的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.二叉树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="toc-text">树和二叉树区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%BC%95%E7%94%A8"><span class="toc-text">3.案例引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">4.树和二叉树的抽象数据类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.二叉树的性质和存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%A7%E8%B4%A8"><span class="toc-text">1.性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树与完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A81"><span class="toc-text">性质1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A82"><span class="toc-text">性质2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A83"><span class="toc-text">性质3</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A84"><span class="toc-text">性质4</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%A7%E8%B4%A85"><span class="toc-text">性质5</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2.存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2.二叉树的链式存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-text">3.三叉链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">3.遍历二叉树和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E2%80%94%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="toc-text">先—根左右</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E2%80%94%E5%B7%A6%E6%A0%B9%E5%8F%B3"><span class="toc-text">中—左根右</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E2%80%94%E5%B7%A6%E5%8F%B3%E6%A0%B9"><span class="toc-text">后—左右根</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%88-%E4%B8%AD-%E5%90%8E%E5%BA%8F%EF%BC%89"><span class="toc-text">2.根据遍历序列确定二叉树（先 中 后序）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-text">实例1：先序+中序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2%E2%80%94%E4%B8%AD%E5%BA%8F-%E5%90%8E%E7%BB%AD"><span class="toc-text">实例2—中序+后续</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">3.遍历的算法实现-先序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-text">递归代码解释</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">4.遍历的算法实现-中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">5.历的算法实现-后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">6.二叉树遍历小总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95-%E6%A0%88"><span class="toc-text">7.中序遍历非递归算法-栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">8.二叉树的层次遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">9.二叉树遍历算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">1.二叉树的建立</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">2.复制二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">3.计算二叉树的深度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%80%BB%E6%95%B0"><span class="toc-text">4.计算二叉树的结点总数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">5.计算叶子结点的个数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">10.线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-3"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%94%BB%E6%B3%95"><span class="toc-text">2.线索二叉树画法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">3.遍历算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%9D%8E%E9%98%B3%E7%9A%84%E4%BA%A4%E6%8D%A2%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91"><span class="toc-text">11.李阳的交换左右子树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-text">6.树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-4"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">2.双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-text">3.孩子链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%8C%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%89"><span class="toc-text">4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-5"><span class="toc-text">1.定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">5.*树与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-6"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C"><span class="toc-text">2.操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%B0%86%E6%A0%91%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.将树转为二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E6%A0%91"><span class="toc-text">2.将二叉树转为树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%A4%9A%E6%A3%B5%E6%A0%91%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.森林转化为二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-text">2.二叉树转为森林</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">7.树与森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%85%88%E6%A0%B9%EF%BC%88%E6%AC%A1%E5%BA%8F-%EF%BC%8C%E5%90%8E%E6%A0%B9%EF%BC%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">1.树的遍历的三种方式{先根（次序)，后根，层次遍历}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">2.森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">1.先序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">2.中序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-text">3.小案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-text">7.*哈夫曼树及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95"><span class="toc-text">2.哈夫曼算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">1.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">2.哈夫曼树的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">顺序结构（一维数组）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">3.哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95"><span class="toc-text">1.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BC%96%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.编码的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9B%BE"><span class="toc-text">八、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-text">1.图的定义和基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.图的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">2.图的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%A6%82%E4%B8%8B"><span class="toc-text">1.图的抽象数据类型定义如下:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 图的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3.图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.数组（邻接矩阵）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">无向图邻接矩阵</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">有向图的邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">有向网的邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-text">2.邻接矩阵的存储形式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%88%86%E5%88%AB%E5%AD%98%E5%82%A8%E9%A1%B6%E7%82%B9%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1.用两个数组分别存储顶点表和邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%87%87%E7%94%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%88%9B%E5%BB%BA%E6%97%A0%E5%90%91%E7%BD%91"><span class="toc-text">2.采用邻接矩阵表示法创建无向网</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-text">3.邻接矩阵的好处和坏处</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-text">好处</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9D%8F%E5%A4%84"><span class="toc-text">坏处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89"><span class="toc-text">3.邻接表表示法（链式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">1.无向图的邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">2.有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%93%BE%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">3.链式代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81"><span class="toc-text">1.定义代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%87%87%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%88%9B%E5%BB%BA%E6%97%A0%E5%90%91%E7%BD%91%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">2.采用邻接表表示法创建无向网的算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">5.邻接表的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%89%B9%E7%82%B9"><span class="toc-text">1.特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">4.邻接矩阵与邻接表表示方法的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%81%94%E7%B3%BB"><span class="toc-text">2.联系:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-text">2.区别:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%A8%E9%80%94"><span class="toc-text">3.用途:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">5.十字链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93"><span class="toc-text">2.具体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-text">6.邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-7"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88-DFS"><span class="toc-text">2.深度优先(DFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">1.连通图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-text">效率分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">2.广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95-1"><span class="toc-text">1.方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-text">3.效率分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-text">4.效率比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">5.图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">1.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">1.生成树的简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">2.无向图的生成树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">3.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">构造最小生成树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Prim-%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-text">Prim-普里姆算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Kruskal-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskal-克鲁斯卡尔算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83"><span class="toc-text">两种比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">2.最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-8"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">2.Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E4%BD%93-%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E9%80%92%E5%A2%9E%E6%AC%A1%E5%BA%8F%E4%BA%A7%E7%94%9F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">具体-按路径长度递增次序产生最短路径</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Floyd-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="toc-text">3.Floyd 弗洛伊德算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-text">算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">3.拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AOV%E7%BD%91"><span class="toc-text">1.AOV网</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BAOV-%E7%BD%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF%E6%96%B9%E6%B3%95"><span class="toc-text">检测AOV 网中是否存在环方法:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AOE%E7%BD%91"><span class="toc-text">2.AOE网</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1"><span class="toc-text">3.拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">4.关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-text">讨论</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/79666db/" title="数据结构"><img src="/img/bg_4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/posts/79666db/" title="数据结构">数据结构</a><time datetime="2024-11-20T13:34:21.000Z" title="发表于 2024-11-20 21:34:21">2024-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c7b053e8/" title="java尚硅谷笔记">java尚硅谷笔记</a><time datetime="2024-11-05T13:34:21.000Z" title="发表于 2024-11-05 21:34:21">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66e64d45/" title="考研408大纲">考研408大纲</a><time datetime="2024-11-04T13:34:21.000Z" title="发表于 2024-11-04 21:34:21">2024-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6ead9846/" title="力扣">力扣</a><time datetime="2024-10-21T13:34:21.000Z" title="发表于 2024-10-21 21:34:21">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9ec06885/" title="C语言基础">C语言基础</a><time datetime="2024-10-10T07:34:21.000Z" title="发表于 2024-10-10 15:34:21">2024-10-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 李阳</div><div class="footer_custom_text">下次再见！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"placeholder":"留下足迹吧！"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'baskly.baskly.us.kg',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/footer.js"></script><script src="/js/countup.js"></script><script src="/js/APlayer.min.js"></script><script src="/js/Meting2.min.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script> LA.init({id:"{3KOJne8bzHjejaBV}",ck:"{3KOJne8bzHjejaBV}"})</script><script>new LingQue.Monitor().init({id:"3KOJne8bzHjejaBV",sendSuspicious:true});</script><script async data-pjax src="/js/anzhiyu.js"></script><script async data-pjax src="/js/anzhiyufunction.js"></script><script async src="/js/anzhiyuOnlyOne.js"></script><script async src="/js/player.js"></script><script async src="/js/utill.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐<div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"placeholder":"留下足迹吧！"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'baskly.baskly.us.kg',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/footer.js"></script><script src="/js/countup.js"></script><script src="/js/APlayer.min.js"></script><script src="/js/Meting2.min.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script> LA.init({id:"{3KOJne8bzHjejaBV}",ck:"{3KOJne8bzHjejaBV}"})</script><script>new LingQue.Monitor().init({id:"3KOJne8bzHjejaBV",sendSuspicious:true});</script><script async data-pjax src="/js/anzhiyu.js"></script><script async data-pjax src="/js/anzhiyufunction.js"></script><script async src="/js/anzhiyuOnlyOne.js"></script><script async src="/js/player.js"></script><script async src="/js/utill.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left"},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body></html>