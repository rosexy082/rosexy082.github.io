<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/sun-touch.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sun-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sun-16x16.png">
  <link rel="mask-icon" href="/images/sun.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flash.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lyay23.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C语言—数据结构———————————————————-内容参考《郝斌数据结构》，《王道》《王卓》">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言数据结构">
<meta property="og:url" content="http://lyay23.github.io/posts/18d54854/index.html">
<meta property="og:site_name" content="李阳的秘密小屋">
<meta property="og:description" content="C语言—数据结构———————————————————-内容参考《郝斌数据结构》，《王道》《王卓》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20240911162821303.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241009153911315.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20240911163008131.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20240911172342285.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241010163206657-1729000222964-1.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241015182021998.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241015220006062.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241016164724670.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017130343420.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017144344602.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017154244958.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017155259933.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017155934811.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017160251060.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017160553699.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017160653491.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017161616371.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017161810079.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017162515773.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017162538457.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017163651081.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017164155126.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241017170321265.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031143536962.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031144308247.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031144903388.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031152141050.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031154837095.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031160124987.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031160854242.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031161122434.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031161802875.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031161947956.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031162420574.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031162925621.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031170614463.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031204537868.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031173605833.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241031214118623.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102133931076.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102134705813.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102135937947.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102144633249.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102150119954.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102150600713.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102151437701.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/6E50FE1F8569BEB2D29488718E198F13.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102154045025.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102180223951.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102180244711.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102181222814.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102181439508.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102181539924.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102183841772.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241102201045571.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241103142345827.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241103143731170.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241103154648957.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241103154702890.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241103164836364.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104153725343.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104155234167.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104155240636.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104155253366.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104155331910.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104162141056.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104164756540.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104171329061.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104173140758.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104173843558.png">
<meta property="og:image" content="http://lyay23.github.io/posts/18d54854/image-20241104173926325.png">
<meta property="article:published_time" content="2024-10-15T07:34:21.000Z">
<meta property="article:modified_time" content="2024-11-04T09:52:20.004Z">
<meta property="article:author" content="李阳">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lyay23.github.io/posts/18d54854/image-20240911162821303.png">


<link rel="canonical" href="http://lyay23.github.io/posts/18d54854/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lyay23.github.io/posts/18d54854/","path":"posts/18d54854/","title":"C语言数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言数据结构 | 李阳的秘密小屋</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="李阳的秘密小屋" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">李阳的秘密小屋</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">C语言—数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">一、数据结构之基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">1.数据结构的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-text">数据的存储结构有几种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2、存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">链式存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="nav-text">索引存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%AD%98%E5%82%A8"><span class="nav-text">散列存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="nav-text">3.算法特征：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%BD%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="nav-text">好算法特征：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">二、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-text">1.数组的优缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="nav-text">2.链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="nav-text">3.术语：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E8%8A%82%E7%82%B9"><span class="nav-text">首节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="nav-text">尾节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%9A"><span class="nav-text">头结点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88"><span class="nav-text">头指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">4.链表的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-text">5.分类：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%AE%97%E6%B3%95"><span class="nav-text">6.算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B9%B6%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA"><span class="nav-text">7.创建带头单链表并遍历输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E2%80%BB%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E2%80%BB"><span class="nav-text">8.※链表的基本操作※</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%88"><span class="nav-text">三、栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E7%B1%BB"><span class="nav-text">2.分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%97%E6%B3%95"><span class="nav-text">3.算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%BA%94%E7%94%A8"><span class="nav-text">4.应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A0%88%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E2%80%94%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="nav-text">5.栈的表达式求值—后缀表达式（逆波兰表达式）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%98%9F%E5%88%97"><span class="nav-text">四、队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E7%B1%BB-1"><span class="nav-text">2.分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81"><span class="nav-text">3.代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">4.队列的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-text">五、递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E2%80%94%E9%98%B6%E5%B1%82"><span class="nav-text">1.简单应用—阶层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%A6%81%E6%B1%82%EF%BC%8C%E6%84%8F%E4%B9%89"><span class="nav-text">2.定义，要求，意义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-text">①定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-text">②递归需要满足的三个条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%84%8F%E4%B9%89"><span class="nav-text">③意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="nav-text">④循环：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">六、串、数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%B8%B2%EF%BC%88string%EF%BC%89"><span class="nav-text">一、串（string）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AD%90%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.子串的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="nav-text">2.串的类型定义、存储结构及运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">3.串的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-1"><span class="nav-text">链式存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">4.串的模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-BF%E7%AE%97%E6%B3%95%EF%BC%88%E7%A9%B7%E4%B8%BE%E6%B3%95%EF%BC%89"><span class="nav-text">1.BF算法（穷举法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E2%80%BB%E2%80%BB%E2%80%BB-KMP%E7%AE%97%E6%B3%95"><span class="nav-text">2.※※※ KMP算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-KMP%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="nav-text">3.KMP算法改进</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">二、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.存储位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">3.压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">1.对称矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">[特点]</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-text">[存储方法]</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-text">2.三角矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">[特点]</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95-1"><span class="nav-text">[存储方法]</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%EF%BC%88%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="nav-text">3.对角矩阵（带状矩阵）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-text">4.稀疏矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-text">十字链表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">三.广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%80%A7%E8%B4%A8"><span class="nav-text">2.性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.广义表和线性表的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-text">4.广义表的基本运算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%A0%91"><span class="nav-text">七、树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">树的基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">树结构和线性结构的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.二叉树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="nav-text">树和二叉树区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A1%88%E4%BE%8B%E5%BC%95%E7%94%A8"><span class="nav-text">3.案例引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">4.树和二叉树的抽象数据类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.二叉树的性质和存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%80%A7%E8%B4%A8"><span class="nav-text">1.性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">满二叉树与完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%A7%E8%B4%A81"><span class="nav-text">性质1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%A7%E8%B4%A82"><span class="nav-text">性质2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%A7%E8%B4%A83"><span class="nav-text">性质3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%A7%E8%B4%A84"><span class="nav-text">性质4</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%A7%E8%B4%A85"><span class="nav-text">性质5</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">1.二叉树的顺序存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.二叉树的链式存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-text">3.三叉链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">3.遍历二叉树和线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%88%E2%80%94%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="nav-text">先—根左右</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E2%80%94%E5%B7%A6%E6%A0%B9%E5%8F%B3"><span class="nav-text">中—左根右</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E%E2%80%94%E5%B7%A6%E5%8F%B3%E6%A0%B9"><span class="nav-text">后—左右根</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%85%88-%E4%B8%AD-%E5%90%8E%E5%BA%8F%EF%BC%89"><span class="nav-text">2.根据遍历序列确定二叉树（先 中 后序）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="nav-text">实例1：先序+中序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B2%E2%80%94%E4%B8%AD%E5%BA%8F-%E5%90%8E%E7%BB%AD"><span class="nav-text">实例2—中序+后续</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">3.遍历的算法实现-先序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="nav-text">递归代码解释</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">4.遍历的算法实现-中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.历的算法实现-后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-text">6.二叉树遍历小总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95-%E6%A0%88"><span class="nav-text">7.中序遍历非递归算法-栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-text">8.二叉树的层次遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">9.二叉树遍历算法的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-text">1.二叉树的建立</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">2.复制二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">3.计算二叉树的深度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%80%BB%E6%95%B0"><span class="nav-text">4.计算二叉树的结点总数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">5.计算叶子结点的个数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">10.线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-3"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%94%BB%E6%B3%95"><span class="nav-text">2.线索二叉树画法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-text">3.遍历算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-text">4.树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-4"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">2.双亲表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="nav-text">3.孩子链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%8C%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%89"><span class="nav-text">4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-5"><span class="nav-text">1.定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">5.*树与二叉树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-6"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%93%8D%E4%BD%9C"><span class="nav-text">2.操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%B0%86%E6%A0%91%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1.将树转为二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E4%B8%BA%E6%A0%91"><span class="nav-text">2.将二叉树转为树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%A4%9A%E6%A3%B5%E6%A0%91%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-7"><span class="nav-text">1.定义</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李阳"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">李阳</p>
  <div class="site-description" itemprop="description">不积硅步无以至千里</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lyay23" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyay23" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3050681193@qq.com" title="E-Mail → 3050681193@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
<!--近期文章 -->


  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <!-- modify icon to fire by szw -->
      <i class="fa fa-history fa-" aria-hidden="true"></i>
      近期文章
    </div>
    <ul class="links-of-blogroll-list">
      
      
        <li class="recent_posts_li">
          <a href="/" title="" target="_blank"></a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/" title="" target="_blank"></a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/" title="" target="_blank"></a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/" title="" target="_blank"></a>
        </li>
      
    </ul>
  </div>

<!--近期文章 -->
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lyay23.github.io/posts/18d54854/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="李阳">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李阳的秘密小屋">
      <meta itemprop="description" content="不积硅步无以至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言数据结构 | 李阳的秘密小屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-15 15:34:21" itemprop="dateCreated datePublished" datetime="2024-10-15T15:34:21+08:00">2024-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-04 17:52:20" itemprop="dateModified" datetime="2024-11-04T17:52:20+08:00">2024-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/c%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">c语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="C语言—数据结构"><a href="#C语言—数据结构" class="headerlink" title="C语言—数据结构"></a>C语言—数据结构</h1><p>———————————————————-内容参考《郝斌数据结构》，《王道》《王卓》</p>
<span id="more"></span>
<h2 id="一、数据结构之基础"><a href="#一、数据结构之基础" class="headerlink" title="一、数据结构之基础"></a>一、数据结构之基础</h2><h3 id="1-数据结构的三要素"><a href="#1-数据结构的三要素" class="headerlink" title="1.数据结构的三要素"></a>1.数据结构的三要素</h3><p><img src="/posts/18d54854/image-20240911162821303.png" alt="image-20240911162821303"></p>
<p>1.若采用顺序存储，则各个数据元素在物理上必须是连续的;若采用非顺序存储，则各个数据元素在物理上可以是离散的。<br>2.数据的存储结构会影响存储空间分配的方便程度<br>3数椐的存储结构会影响对数据运算的速度</p>
<p><img src="/posts/18d54854/image-20241009153911315.png" alt="image-20241009153911315"></p>
<h4 id="数据的存储结构有几种"><a href="#数据的存储结构有几种" class="headerlink" title="数据的存储结构有几种"></a><strong>数据的存储结构有几种</strong></h4><p>​    线性</p>
<p>​          连续存储（数组）</p>
<p>​                   优点：存储速度很快</p>
<p>​                   缺点：插入和删除元素很慢，空间通常是有限的</p>
<p>​           离散存储（链表）</p>
<p>​                    优点：空间没有限制，插入删除元素很快</p>
<p>​                    缺点：存取速度很慢</p>
<h3 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><p><img src="/posts/18d54854/image-20240911163008131.png" alt="image-20240911163008131"></p>
<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>顺序存储,把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>链式存储，逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。（指针链接指针）</p>
<h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p>索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)离散的</p>
<h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><p>散列存储。根据元素的夭键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p>
<h3 id="3-算法特征："><a href="#3-算法特征：" class="headerlink" title="3.算法特征："></a>3.算法特征：</h3><p>确定性，可行性，输入，输出</p>
<h4 id="好算法特征："><a href="#好算法特征：" class="headerlink" title="好算法特征："></a>好算法特征：</h4><p>正确性，可读性，健壮性，高效率与低存储需求（时间，空间复杂度低）</p>
<p><img src="/posts/18d54854/image-20240911172342285.png" alt="image-20240911172342285"></p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1-数组的优缺点："><a href="#1-数组的优缺点：" class="headerlink" title="1.数组的优缺点："></a>1.数组的优缺点：</h3><p>优点：存储速度快</p>
<p>缺点：需要一个连续很大的内存，插入和删除元素的效率很低</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>优点：插入 删除元素效率高，不需要一个连续的很大内存</p>
<p>缺点：查找某个元素的效率低</p>
<h3 id="3-术语："><a href="#3-术语：" class="headerlink" title="3.术语："></a>3.术语：</h3><h4 id="首节点"><a href="#首节点" class="headerlink" title="首节点"></a><strong>首节点</strong></h4><ul>
<li>存放第一个有效数据的节点</li>
</ul>
<h4 id="尾节点"><a href="#尾节点" class="headerlink" title="尾节点"></a><strong>尾节点</strong></h4><ul>
<li>存放最后一个元素的有效数据节点</li>
</ul>
<h4 id="头结点："><a href="#头结点：" class="headerlink" title="头结点："></a><strong>头结点：</strong></h4><ol>
<li>头结点的数据类型和首节点的类型是一样的</li>
<li>头结点是首结点前面的那个节点</li>
<li>头结点里面不存放有效数据</li>
<li>设置结点是为了方便对链表经行操作</li>
</ol>
<h4 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a><strong>头指针</strong></h4><ul>
<li>存放头结点的地址的指针变量</li>
<li>可以通过头指针推算出链表的其他信息</li>
</ul>
<h3 id="4-链表的定义"><a href="#4-链表的定义" class="headerlink" title="4.链表的定义"></a>4.链表的定义</h3><ul>
<li>n个节点离散分配</li>
<li>彼此通过指针相连接</li>
<li>每个节点只有一个前驱节点和后驱节点</li>
<li>首节点没有前驱节点，  尾节点没有后续节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> date;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,*pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-分类："><a href="#5-分类：" class="headerlink" title="5.分类："></a>5.分类：</h3><ul>
<li><p>单链表</p>
</li>
<li><p>双链表</p>
<p>​        每一个节点都有两个指针域</p>
</li>
<li><p>循环链表</p>
<p>​       能通过任何一个节点找到其他所有节点</p>
</li>
<li><p>非循环链表</p>
</li>
</ul>
<h3 id="6-算法"><a href="#6-算法" class="headerlink" title="6.算法"></a>6.算法</h3><p>遍历</p>
<p>查找</p>
<p>清空</p>
<p>销毁</p>
<p>排序</p>
<p>删除节点</p>
<p>插入节点 </p>
<h3 id="7-创建带头单链表并遍历输出"><a href="#7-创建带头单链表并遍历输出" class="headerlink" title="7.创建带头单链表并遍历输出"></a>7.创建带头单链表并遍历输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义单链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（带头）</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-※链表的基本操作※"><a href="#8-※链表的基本操作※" class="headerlink" title="8.※链表的基本操作※"></a>8.※链表的基本操作※</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之单链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode,<span class="type">int</span> ,<span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //判断链表是否为空</span></span><br><span class="line"><span class="comment">    if(is_empty(pHead))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表为空！\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表不空");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //返回链表长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int len= length_list(pHead);</span></span><br><span class="line"><span class="comment">    printf("链表长度是 %d\n",len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //排序</span></span><br><span class="line"><span class="comment">    printf("从小到大排序后的代码是：\n");</span></span><br><span class="line"><span class="comment">    sort_list(pHead);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //插入</span></span><br><span class="line"><span class="comment">    insert_list(pHead,3,44);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //删除</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    if(delete_list(pHead,3,&amp;val))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("删除成功，您删除的元素是%d\n",val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    } else</span></span><br><span class="line"><span class="comment">        printf("删除未成功\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead-&gt;pNext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将头节点的地址给他</span></span><br><span class="line">    <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p)<span class="comment">//如果这里面是空的</span></span><br><span class="line">    {</span><br><span class="line">        ++len;<span class="comment">//++</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向下一个元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i,j,t;</span><br><span class="line"><span class="type">int</span> len = length_list(pHead);</span><br><span class="line">pNode p,q;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>,p=pHead-&gt;pNext; i &lt;len<span class="number">-1</span> ; ++i,p=p-&gt;pNext) {<span class="comment">//p放的是第一个元素，</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>,q=p-&gt;pNext; j &lt;len ; ++j,q=q-&gt;pNext) {<span class="comment">//q放的是p的后面的一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            {</span><br><span class="line">                t=p-&gt;data;</span><br><span class="line">                p-&gt;data=q-&gt;data;</span><br><span class="line">                q-&gt;data=t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入--在第pos的前面插入一个新的节点val，pos从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNew -&gt;data=val;<span class="comment">//定义了一个新节点，将val先放进去</span></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//p此时已经来到了pos-1的地方，也就是他的前面，</span></span><br><span class="line">    p-&gt;pNext=pNew;<span class="comment">//将他的地址给pNew</span></span><br><span class="line">    pNew-&gt;pNext=q;<span class="comment">//再将pNew的下一元素的地址给next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> * pval)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p-&gt;pNext &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p-&gt;pNext)<span class="comment">//pos-1:eg:删除第3个必须要知道第二个</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//第pos个节点</span></span><br><span class="line">    *pval=q-&gt;data;<span class="comment">//将要删除的节点保存下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除p节点后面的节点</span></span><br><span class="line">    p-&gt;pNext=p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​             一种可以实现“先进后出”的存储结构</p>
<p>​            栈类似于一个箱子，先放进去的后拿出来，后进去的先拿出来</p>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><p>   静态栈</p>
<p>   动态栈</p>
<h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h3><p>​      出栈</p>
<p>​      压栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构之栈 o.O</span></span><br><span class="line"><span class="comment"> *  Created by 李阳 on 2024/10/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pNext</span>;</span></span><br><span class="line">}Node,*pNode;</span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    pNode pTop;<span class="comment">//元素顶部</span></span><br><span class="line">    pNode pBottom;<span class="comment">//元素底部</span></span><br><span class="line">}sTack,*pStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">   sTack S;<span class="comment">//sTack等价于 struct Stack--建立了一个名为S的成员变量，里面有两个元素，ptop和pbottom，里面暂时没有有效数据</span></span><br><span class="line"></span><br><span class="line">   initStack(&amp;S);<span class="comment">//初始化-造出空栈</span></span><br><span class="line">   pushStack(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">2</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">3</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">4</span>);<span class="comment">//压栈</span></span><br><span class="line"></span><br><span class="line">    traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    clear(&amp;S);</span><br><span class="line">   <span class="comment">// traverse(&amp;S);//输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>( popStack(&amp;S,&amp;val))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈成功，出栈的元素是：%d\n"</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈失败\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pS-&gt;pTop=(pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));<span class="comment">//将top指向一个新造的空节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pS-&gt;pTop)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pS-&gt;pBottom=pS-&gt;pTop;<span class="comment">//地址都指向空节点</span></span><br><span class="line">        pS-&gt;pTop-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//将新造的节点的指针域为空--因为他是最后一个元素的下一个元素，因此没有指针域</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈--进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pNode pNew=(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line">    pNew-&gt;data=val;</span><br><span class="line">    pNew-&gt;pNext=pS-&gt;pTop;<span class="comment">//此时ptoop里面放的是初始化时的临时变量地址，这里调用，将新建的栈的指针域指向初始化的元素地址</span></span><br><span class="line">    pS-&gt;pTop=pNew;<span class="comment">//再将新的节点地址给top</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pS-&gt;pTop;<span class="comment">//定义个临时指针变量p，将头的值给p，</span></span><br><span class="line">    <span class="keyword">while</span> (p!=pS-&gt;pBottom)<span class="comment">//当p为底部元素时程序终止</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向p的下一元素地址</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop==pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack pS,<span class="type">int</span> * pVal)</span><span class="comment">//把ps所指向的栈出栈一次，并将出栈元素存入pval新参所指向的变量中，成功返回true，否则false</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(empty(pS))</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">        pNode r=pS-&gt;pTop;<span class="comment">//定义一个变量r，将顶元素给r</span></span><br><span class="line">        *pVal=r-&gt;data;</span><br><span class="line">        pS-&gt;pTop=r-&gt;pNext;<span class="comment">//再将top指向下一元素，这样r就被孤立了</span></span><br><span class="line">         <span class="built_in">free</span>(r);</span><br><span class="line">         r=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    pNode p=pS-&gt;pTop;</span><br><span class="line">    pNode q=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=pS-&gt;pBottom)</span><br><span class="line">        {</span><br><span class="line">            q=p-&gt;pNext;<span class="comment">//q指向第二个</span></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p=q;<span class="comment">//p又指向了下一个元素了</span></span><br><span class="line">        }</span><br><span class="line">        pS-&gt;pTop=pS-&gt;pBottom;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>函数调用</p>
<p>中断</p>
<p>表达式求值</p>
<p>内存分配</p>
<p>缓存处理</p>
<p>迷宫</p>
<h3 id="5-栈的表达式求值—后缀表达式（逆波兰表达式）"><a href="#5-栈的表达式求值—后缀表达式（逆波兰表达式）" class="headerlink" title="5.栈的表达式求值—后缀表达式（逆波兰表达式）"></a>5.栈的表达式求值—后缀表达式（逆波兰表达式）</h3><p><strong>1.例如：1+2*3</strong></p>
<p>​     后缀表达式为 1 2 3 * +</p>
<p>​             遇到一个运算符他会在前面两个数字间运算 </p>
<ol>
<li>​          2 *3</li>
<li>然后向后移到+    </li>
<li>6+1</li>
</ol>
<p><strong>2、(a + b) * (c - (d / e)) + f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b + c d e / - * f +</span><br></pre></td></tr></table></figure>
<p><strong>3.、a * (b + c) - (d / e)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c + * d e / -</span><br></pre></td></tr></table></figure>
<p><strong>4、a + b * (c - d / e) ^ f</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d e / - f ^ * +</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 操作数和运算符</span><br><span class="line">操作数（如变量和常数）直接添加到输出列表中。</span><br><span class="line">运算符则需要根据优先级和括号来决定是否入栈、弹出或保持在栈中。</span><br><span class="line">2. 运算符优先级</span><br><span class="line">运算符的优先级从高到低一般为：</span><br><span class="line">* 和 / （乘法和除法）优先级高</span><br><span class="line">+ 和 - （加法和减法）优先级低</span><br><span class="line">在遇到相同优先级的运算符时，按照左结合性处理（从左到右）。</span><br><span class="line">3. 括号的处理</span><br><span class="line">遇到左括号 ( 时，直接入栈。</span><br><span class="line">遇到右括号 ) 时，弹出栈中的运算符到输出，直到遇到对应的左括号为止，左括号被丢弃。</span><br><span class="line">4. 栈的使用</span><br><span class="line">当一个运算符被处理时，检查栈顶运算符的优先级：</span><br><span class="line">如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</span><br><span class="line">否则，将当前运算符入栈。</span><br><span class="line">5. 表达式结束时的处理</span><br><span class="line">当整个中序表达式处理完毕后，仍有运算符在栈中时，将它们全部弹出到输出。</span><br><span class="line">6. 后缀表达式的特征</span><br><span class="line">后缀表达式不需要括号，因为运算符的顺序和位置已经明确了运算的优先级和关联性。</span><br></pre></td></tr></table></figure>
<p><strong>当一个运算符被处理时，检查栈顶运算符的优先级：</strong><br><strong>如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</strong><br><strong>否则，将当前运算符入栈。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">当然可以，关于将中序表达式转换为后缀表达式（也称为逆波兰表达式）时处理括号和运算符的一些规律，可以总结如下：</span><br><span class="line"></span><br><span class="line">括号处理：</span><br><span class="line">左括号 (：在遇到左括号时，通常不需要立即进行任何操作，但可以将其视为一个标记，表示一个新的运算范围的开始。在某些实现中，可能会使用一个辅助栈来跟踪左括号的位置或数量。</span><br><span class="line">右括号 )：当遇到右括号时，需要开始从运算符栈中弹出运算符，并将它们添加到后缀表达式中，直到遇到对应的左括号或栈为空。弹出的运算符应该按照它们被压入栈的顺序的逆序添加到后缀表达式中。</span><br><span class="line">运算符栈：</span><br><span class="line">运算符栈用于存储等待处理的运算符。当遇到一个新的运算符时，需要将其与栈顶的运算符进行比较，以确定是否需要弹出栈顶的运算符（基于运算符的优先级）。</span><br><span class="line">栈顶的运算符具有更高的优先级时（或者当前运算符需要右结合时），它应该被弹出并添加到后缀表达式中。这个过程一直持续到栈顶的运算符优先级低于或等于当前运算符，或者栈为空。</span><br><span class="line">操作数处理：</span><br><span class="line">操作数（如变量、常量等）直接添加到后缀表达式中，不需要经过运算符栈的处理。</span><br><span class="line">运算符优先级和结合性：</span><br><span class="line">运算符的优先级决定了在相同位置上的运算符哪个应该先被处理。例如，乘法和除法的优先级高于加法和减法。</span><br><span class="line">运算符的结合性决定了当两个运算符具有相同的优先级时，它们应该如何组合。例如，加法和乘法都是从左到右结合的。</span><br><span class="line">后缀表达式的构建：</span><br><span class="line">后缀表达式是通过从左到右扫描中序表达式，并根据上述规则处理运算符和括号来构建的。</span><br><span class="line">最终的后缀表达式应该只包含操作数和运算符，并且运算符的顺序应该反映了它们在中序表达式中的计算顺序。</span><br><span class="line">验证：</span><br><span class="line">一个简单的方法来验证后缀表达式是否正确是将其转换回中序表达式（这通常涉及使用一个额外的栈来模拟计算过程），并检查转换后的中序表达式是否与原始表达式相同。</span><br><span class="line">另一种方法是直接计算后缀表达式和原始中序表达式的值，并检查它们是否相等。</span><br><span class="line">这些规律是理解和实现中序表达式到后缀表达式转换的关键。通过遵循这些规律，可以确保转换过程的正确性和效率。</span><br></pre></td></tr></table></figure>
<h2 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>​        一种可以实现“先进先出”的存储结构—排队买票进站 </p>
<h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><p>​    链式队列（链表）</p>
<p>​    静态队列（数组）</p>
<p>​            静态队列通常都必须是循环队列</p>
<p>​                      <img src="/posts/18d54854/image-20241010163206657-1729000222964-1.png" alt="image-20241010163206657">        </p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by 李阳 on 2024/10/14.</span></span><br><span class="line"><span class="comment"> * 数据结构之静态循环队列o.O</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> *pBase;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//首</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾</span></span><br><span class="line">} QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;<span class="comment">//改变实参的值所以要加*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *,<span class="type">int</span>)</span>;<span class="comment">//入队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *,<span class="type">int</span> *pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    init(&amp;Q);<span class="comment">//调用初始化函数</span></span><br><span class="line">    en_queue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (out_queue(&amp;Q, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队成功: %d\n"</span>, val); <span class="comment">// 修正输出格式</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队失败\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    pQ-&gt;pBase=(<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)*<span class="number">6</span>);<span class="comment">//定义了6个数据的数组</span></span><br><span class="line">    pQ-&gt;front=pQ-&gt;rear=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *pQ,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear]=val;<span class="comment">//将值放入尾部，并且尾部要+1</span></span><br><span class="line">        pQ-&gt;rear=(pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;<span class="comment">//尾部+1--因为是循环队列，当他满的时候会又从0开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>==pQ-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> ((i!=pQ-&gt;rear))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> *pVal)</span><span class="comment">//因为要带回来值，所以要*</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">if</span>(emput_queue(pQ))</span><br><span class="line">   {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"表是空的"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   } <span class="keyword">else</span></span><br><span class="line">   {</span><br><span class="line">     *pVal=pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">     pQ-&gt;front=(pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="4-队列的操作"><a href="#4-队列的操作" class="headerlink" title="4.队列的操作"></a>4.队列的操作</h3><p>所有和时间有关的操作</p>
<h2 id="五、递归"><a href="#五、递归" class="headerlink" title="五、递归"></a>五、递归</h2><p><img src="/posts/18d54854/image-20241015182021998.png" alt="image-20241015182021998"></p>
<h3 id="1-简单应用—阶层"><a href="#1-简单应用—阶层" class="headerlink" title="1.简单应用—阶层"></a>1.简单应用—阶层</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之递归</span></span><br><span class="line"><span class="comment"> * Created by 李阳 on 2024/10/15.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo1--求阶层</span></span><br><span class="line"><span class="comment">/* for循环版</span></span><br><span class="line"><span class="comment">int jiec(int a)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=1;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for ( i=1; i &lt;=a; ++i)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        b=b*i;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    return b;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=5;</span></span><br><span class="line"><span class="comment">    int a= jiec(b);</span></span><br><span class="line"><span class="comment">    printf("%d 的阶层是 %d",b,a);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">long</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要求的阶层"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    b= f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld 的阶层是 %ld"</span>,a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现1+2+...</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="2-定义，要求，意义"><a href="#2-定义，要求，意义" class="headerlink" title="2.定义，要求，意义"></a>2.定义，要求，意义</h3><h4 id="①定义："><a href="#①定义：" class="headerlink" title="①定义："></a>①<strong>定义：</strong></h4><p>一个函数间接或直接调用自己</p>
<h4 id="②递归需要满足的三个条件"><a href="#②递归需要满足的三个条件" class="headerlink" title="②递归需要满足的三个条件"></a>②<strong>递归需要满足的三个条件</strong></h4><ol>
<li>递归必须要有一个明确的终止条件</li>
<li>该函数所处理的数据规模必须在递减</li>
<li>这个转化必须是可解的</li>
</ol>
<h4 id="③意义"><a href="#③意义" class="headerlink" title="③意义"></a>③<strong>意义</strong></h4><p>优点：易于理解</p>
<p>缺点：速度慢，存储空间大</p>
<h4 id="④循环："><a href="#④循环：" class="headerlink" title="④循环："></a>④<strong>循环</strong>：</h4><p>不易理解，速度快，存储空间小</p>
<h2 id="六、串、数组和广义表"><a href="#六、串、数组和广义表" class="headerlink" title="六、串、数组和广义表"></a>六、串、数组和广义表</h2><h3 id="一、串（string）"><a href="#一、串（string）" class="headerlink" title="一、串（string）"></a>一、串（string）</h3><p>0个或多个任意字符组成的有限序列</p>
<h4 id="1-子串的定义"><a href="#1-子串的定义" class="headerlink" title="1.子串的定义"></a>1.子串的定义</h4><p>一个串中任意个连续字符组成的子序列（含空串）称为该串的子串</p>
<p>例如：“abcd”的子串有 </p>
<p>“ ”，“a”,”ab”,”abc”,”abcd”</p>
<p><strong>真子串</strong>：是指不包含自身的所有子串</p>
<p><strong>主串</strong>:包含子串的串相应的称为主串</p>
<p><strong>字符位置</strong>:字符在序列中的序号为该字符串中的位置</p>
<p><strong>子串位置</strong>：子串第一个字符在主串中的位置</p>
<p><strong>空格串：</strong>由一个或多个空格组成的串，与空串不同</p>
<p><img src="/posts/18d54854/image-20241015220006062.png" alt="image-20241015220006062"></p>
<p><strong>串相等:</strong>当且仅当两个串的长度相等并且各个对应立置上的字符都相同时，这两个串才是相等的。</p>
<h4 id="2-串的类型定义、存储结构及运算"><a href="#2-串的类型定义、存储结构及运算" class="headerlink" title="2.串的类型定义、存储结构及运算"></a>2.串的类型定义、存储结构及运算</h4><p>顺序存储结构-顺序串</p>
<p>链式存储结构-链式串</p>
<h4 id="3-串的表示"><a href="#3-串的表示" class="headerlink" title="3.串的表示"></a>3.串的表示</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串的顺序存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组1-255</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串的链式存储结构--块链结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE]; <span class="comment">// 存储字符块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个块的指针</span></span><br><span class="line">} Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    Chunk *head;  <span class="comment">// 串的首指针</span></span><br><span class="line">    Chunk *tail;  <span class="comment">// 串的尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;   <span class="comment">// 串的当前长度</span></span><br><span class="line">} LString;</span><br></pre></td></tr></table></figure>
<h4 id="4-串的模式匹配"><a href="#4-串的模式匹配" class="headerlink" title="4.串的模式匹配"></a>4.串的模式匹配</h4><h5 id="1-BF算法（穷举法）"><a href="#1-BF算法（穷举法）" class="headerlink" title="1.BF算法（穷举法）"></a>1.BF算法（穷举法）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_BF</span><span class="params">(SString S,SString T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i=(i-j)+<span class="number">2</span>;j=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">      <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/posts/18d54854/image-20241016164724670.png" alt="image-20241016164724670"></p>
<h5 id="2-※※※-KMP算法"><a href="#2-※※※-KMP算法" class="headerlink" title="2.※※※ KMP算法"></a>2.<strong>※※※ KMP</strong>算法</h5><p><img src="/posts/18d54854/image-20241017130343420.png" alt="image-20241017130343420"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算模式串 T 的 next 数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j; <span class="comment">// 注意：next[i] 是 i 位置的前缀长度</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 算法实现，返回模式串 T 在主串 S 中首次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// S 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S.ch[i] == T.ch[j]) { <span class="comment">// j = -1 表示需要跳过</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == T.length) <span class="keyword">return</span> i - T.length; <span class="comment">// 匹配成功，返回匹配位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 匹配失败，返回 -1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="3-KMP算法改进"><a href="#3-KMP算法改进" class="headerlink" title="3.KMP算法改进"></a>3.KMP算法改进</h5><p><img src="/posts/18d54854/image-20241017144344602.png" alt="image-20241017144344602"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = nextval[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><p>按照一点格式排列起来的具有相同的数据元素集合</p>
<p><strong>一维数组</strong>：若线性表中的元素为非结构的简单元素，则称为一维数组（线性结构，定长的线性表）</p>
<p><strong>二维数组</strong>：若一维数组中的元素又是一维数组结构，则称为二维数组</p>
<p><strong>二维数组逻辑结构：</strong></p>
<ul>
<li>非线性结构： 每一个元素既在一个行表中，又在一个列表中</li>
<li>线性结构：该线性表的每一个元素也是一个定长的线性表</li>
</ul>
<p><strong>数组特点</strong>：结构固定—定义后，维度和为界不再改变</p>
<p><strong>结论</strong>:</p>
<ul>
<li>线性表结构是数组的一个特例</li>
<li>而数组结构又是线性表结构的扩展</li>
</ul>
<p><strong>基本操作</strong>：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p>
<p>一般采用顺序结构来表示数组</p>
<h4 id="2-存储位置"><a href="#2-存储位置" class="headerlink" title="2.存储位置"></a>2.存储位置</h4><p><img src="/posts/18d54854/image-20241017154244958.png" alt="image-20241017154244958"></p>
<p>数组元素a[i] [j] 的存储位置是 LOC(i,j)=LOC(0,0)+n <em> i+j </em> L(L是存储每个元素所需要L个存储单元)</p>
<h4 id="3-压缩存储"><a href="#3-压缩存储" class="headerlink" title="3.压缩存储"></a>3.压缩存储</h4><ol>
<li>什么是压缩存储?<br>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</li>
<li>什么样的矩阵能够压缩?<br>一些特殊矩阵，如:对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</li>
<li>什么叫稀疏矩阵?<br>矩阵中非零元素的个数较少（一般小于5%)</li>
</ol>
<h5 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a><strong>1.对称矩阵</strong></h5><ol>
<li><h6 id="特点"><a href="#特点" class="headerlink" title="[特点]"></a>[特点]</h6><p>沿着对角线对称</p>
<p>在nxn的矩阵a中，满足如下性质:    aij=aji (1 ≤i, j &lt;n)</p>
</li>
<li><h6 id="存储方法"><a href="#存储方法" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p>
</li>
</ol>
<p><img src="/posts/18d54854/image-20241017155259933.png" alt="image-20241017155259933"></p>
<p><img src="/posts/18d54854/image-20241017155934811.png" alt="image-20241017155934811"></p>
<h5 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a><strong>2.三角矩阵</strong></h5><ol>
<li><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="[特点]"></a>[特点]</h6><p>对角线以下(或者以上)的数据元素(不包括对角线)全部为常数co</p>
</li>
<li><h6 id="存储方法-1"><a href="#存储方法-1" class="headerlink" title="[存储方法]"></a>[存储方法]</h6><p>重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间: sa[1.. n(n+1)/2+1]</p>
</li>
</ol>
<p><img src="/posts/18d54854/image-20241017160251060.png" alt="image-20241017160251060"></p>
<h5 id="3-对角矩阵（带状矩阵）"><a href="#3-对角矩阵（带状矩阵）" class="headerlink" title="3.对角矩阵（带状矩阵）"></a><strong>3.对角矩阵（带状矩阵）</strong></h5><p>[特点]在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p>
<p><img src="/posts/18d54854/image-20241017160553699.png" alt="image-20241017160553699"></p>
<p><img src="/posts/18d54854/image-20241017160653491.png" alt="image-20241017160653491"></p>
<h5 id="4-稀疏矩阵"><a href="#4-稀疏矩阵" class="headerlink" title="4.稀疏矩阵"></a><strong>4.稀疏矩阵</strong></h5><p>稀疏矩阵:设在mxn的矩阵中有t个非零元素。<br>令ɸ= t/(mxn)<br>当ɸ≤0.05时称为稀疏矩阵。</p>
<p><img src="/posts/18d54854/image-20241017161616371.png" alt="image-20241017161616371" style="zoom:67%;"></p>
<p><img src="/posts/18d54854/image-20241017161810079.png" alt="image-20241017161810079" style="zoom:67%;"></p>
<p>三元组顺序表又称有序的双下标法。</p>
<ol>
<li><p>三元组顺序表的优点:非零元在表中按行序有序存储，因此便于进</p>
<p>行依行顺序处理的矩阵运算。</p>
</li>
<li><p>三元组顺序表的缺点:不能随机存取。若按行号存取某一行中的非</p>
<p>零元，则需从头开始进行查找。</p>
</li>
</ol>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a><strong>十字链表</strong></h6><p>优点:它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算<br><img src="/posts/18d54854/image-20241017162515773.png" alt="image-20241017162515773"></p>
<p><img src="/posts/18d54854/image-20241017162538457.png" alt="image-20241017162538457"></p>
<p> <img src="/posts/18d54854/image-20241017163651081.png" alt="image-20241017163651081"></p>
<h3 id="三-广义表"><a href="#三-广义表" class="headerlink" title="三.广义表"></a>三.广义表</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><p>广义表 （又称列表Lists）是n≧0个元素 a0,a1…..an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表</p>
<p><img src="/posts/18d54854/image-20241017164155126.png" alt="image-20241017164155126"></p>
<ul>
<li><p>广义表通常记作:Ls=(a1, a2,..，an)</p>
<p>其中:LS为表名，n为表的长度，每一个ai为表的元素</p>
</li>
<li><p>习惯上，一般用<strong>大写字母</strong>表示<strong>广义表</strong>，<strong>小写字母</strong>表示<strong>原子。</strong></p>
</li>
<li><p><strong>表头：</strong>若LS非空(n≥1)，则其第一个元素a1就是表头。<br>记作head(LS) = a1。<strong>注</strong>:表头可以是原子，也可以是子表。</p>
</li>
<li><p><strong>表尾</strong>：除<strong>表头</strong>之外的<strong>其它元素</strong>组成的<strong>表</strong>。</p>
<p>​      记作tail(LS） = (a2, …. an)。</p>
<p>​     注:表尾不是最后一个元素，而是一个<strong>子表。</strong></p>
<p><img src="/posts/18d54854/image-20241017170321265.png" alt="image-20241017170321265"></p>
</li>
</ul>
<h4 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h4><ul>
<li><p>(1)广义表中的数据元素有相对<strong>次序;一个直接前驱和一个直接后驱</strong></p>
</li>
<li><p>(2)广义表的<strong>长度</strong>定义为最外层所包含元素的个数;</p>
<p>​     如: C=(a (b, q))是长度为2的广义表。</p>
</li>
<li><p>(3)广义表的<strong>深度</strong>定义为该广义表<strong>展开后所含括号的重数</strong>;</p>
<p>​     A=(b ,c)的深度为1,B=(A,d)的深度为2，C=(f, B,h)的深度为3。</p>
<p>​     <strong>注意</strong>:“原子”的深度为0;“空表”的深度为1。</p>
</li>
<li><p>广义表可以为其他广义表<strong>共享</strong>，如：广义表B就共享了广义表A。在b中不必列出A的值，而是通过名称来引用，B=(A)</p>
</li>
<li><p>广义表可以是一个递归的表。如：F=（a,F=(a,(a,(a,…)))</p>
</li>
</ul>
<p>​               注意：递归表的深度是无穷值，长度是有限值，这里长度是2</p>
<ul>
<li>广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，….。<br>可以用图形象地表示。<br>例:D=(E，F）其中:E=(a, (b,c)）F=(d,(e))</li>
</ul>
<h4 id="3-广义表和线性表的区别"><a href="#3-广义表和线性表的区别" class="headerlink" title="3.广义表和线性表的区别"></a>3.广义表和线性表的区别</h4><ol>
<li>广义表可以看成是线性表的推广，线性表是广义表的特例。</li>
<li>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</li>
<li>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</li>
<li>另外，树和有向图也可以用广义表来表示。</li>
<li>由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</li>
</ol>
<h4 id="4-广义表的基本运算"><a href="#4-广义表的基本运算" class="headerlink" title="4.广义表的基本运算"></a>4.广义表的基本运算</h4><p> <img src="/posts/18d54854/image-20241031143536962.png" alt="image-20241031143536962"></p>
<p>案例分析</p>
<p><img src="/posts/18d54854/image-20241031144308247.png" alt="image-20241031144308247"></p>
<p>代码实现</p>
<h2 id="七、树"><a href="#七、树" class="headerlink" title="七、树"></a>七、树</h2><h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1.树的定义"></a>1.树的定义</h3><p><img src="/posts/18d54854/image-20241031144903388.png" alt="image-20241031144903388"></p>
<h4 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h4><p><strong>树</strong>(Tree)是n (n≥0)个结点的有限集。(递归)<br>       若n =0，称为<strong>空树</strong>;<br>        若n &gt;0，则它满足如下两个条件:<br>              (1)<strong>有且仅有一个</strong>特定的称为<strong>根</strong>(Root)的结点;<br>              (2)<strong>其余结点</strong>可分为m (m≥0)个互不相交的<strong>有限集</strong>T1,T2,T3,…Tm，其中每一个集合本身又是一棵树，并称为根的<strong>子树</strong>(SubTree)。 </p>
<h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><p><strong>结点</strong>：数据元素以及指向树的分支</p>
<p><strong>根结点</strong>：非空树中无前驱点的结点</p>
<p><strong>结点的度</strong>：结点拥有的子树数</p>
<p>​    eg: A 3,B 2,F 1</p>
<p><img src="/posts/18d54854/image-20241031152141050.png" alt="image-20241031152141050"></p>
<p><strong>树的度</strong>： 数内各结点的度的最大值</p>
<p><strong>叶子结点：</strong>终端结点（度为0）</p>
<p>​          eg: k L G M J</p>
<p><strong>分支结点：</strong>非终端结点</p>
<p>​            eg: B,C,D…</p>
<p><strong>内部结点：</strong>根节点以外的分支结点称为内部结点 </p>
<p><strong>孩子结点：</strong>结点的子树的根称为孩子</p>
<p><strong>双亲结点</strong>：孩子结点的前驱</p>
<p><img src="/posts/18d54854/image-20241031154837095.png" alt="image-20241031154837095"></p>
<p>​       eg: BCD是A的孩子结点，A是bcd的双亲结点</p>
<p><strong>兄弟结点</strong>：同级的结点</p>
<p><strong>祖先结点：</strong>从根到该结点所经分支上的所有结点</p>
<p>​           eg: M的祖先结点为H,D,A</p>
<p><strong>子孙结点：</strong>从某结点为根的子树的任意结点</p>
<p>​          eg: D的孙子有HM</p>
<p><strong>树的深度：</strong>树中结点的最大层次</p>
<p><strong>有序树：</strong>树中的各子树从左至右有次序(最左边为第一个孩子)</p>
<p><strong>无序树：</strong>树中结点的各子树无次序</p>
<p><strong>森林：</strong>是m（m&gt;=0)棵互不相交的树的集合</p>
<p><img src="/posts/18d54854/image-20241031160124987.png" alt="image-20241031160124987"></p>
<p>​              树一定是森林，森林不一定是树</p>
<h4 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a>树结构和线性结构的比较</h4><p><img src="/posts/18d54854/image-20241031160854242.png" alt="image-20241031160854242"></p>
<h3 id="2-二叉树的定义"><a href="#2-二叉树的定义" class="headerlink" title="2.二叉树的定义"></a>2.二叉树的定义</h3><p><img src="/posts/18d54854/image-20241031161122434.png" alt="image-20241031161122434"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​    二叉树是n(n&gt;=0)个结点的有限集，它或者是空集(n= 0),或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li>每个结点最多有俩孩子(二叉树中不存在度大于2的结点)。</li>
<li>子树有左右之分，其次序不能颠倒。</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树。</li>
</ol>
<h4 id="树和二叉树区别"><a href="#树和二叉树区别" class="headerlink" title="树和二叉树区别"></a><strong>树和二叉树区别</strong></h4><ul>
<li>二叉树不是树的特殊情况，它们是两个概念</li>
<li>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也经行区分，说明它是左子树，还是右子树。</li>
<li>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</li>
<li>(也就是二叉树每个结点位置或者次序都是固定的，可以是空，但是个可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时.它就无所谓左右了)</li>
</ul>
<p><img src="/posts/18d54854/image-20241031161802875.png" alt="image-20241031161802875"></p>
<p><img src="/posts/18d54854/image-20241031161947956.png" alt="image-20241031161947956"></p>
<h3 id="3-案例引用"><a href="#3-案例引用" class="headerlink" title="3.案例引用"></a>3.案例引用</h3><p><img src="/posts/18d54854/image-20241031162420574.png" alt="image-20241031162420574"></p>
<h3 id="4-树和二叉树的抽象数据类型定义"><a href="#4-树和二叉树的抽象数据类型定义" class="headerlink" title="4.树和二叉树的抽象数据类型定义"></a>4.树和二叉树的抽象数据类型定义</h3><p><img src="/posts/18d54854/image-20241031162925621.png" alt="image-20241031162925621"></p>
<p><img src="/posts/18d54854/image-20241031170614463.png" alt="image-20241031170614463"></p>
<h3 id="5-二叉树的性质和存储结构"><a href="#5-二叉树的性质和存储结构" class="headerlink" title="5.二叉树的性质和存储结构"></a>5.二叉树的性质和存储结构</h3><h4 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h4><h5 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p><strong>满二叉树</strong>：一颗深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>且有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点的二叉树就叫满二叉树</p>
<p><strong>完全二叉树：</strong>深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的具有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的二叉树，当且仅当每一个结点都与深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的<strong>满二叉树</strong>中的<strong>编号</strong>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 1350 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的结点一一对应时，称为<strong>完全二叉树</strong>（叶子结点的编号是连续的,<strong>左侧树必须满元素</strong>)</p>
<ul>
<li>叶子只可能分布在层次最大的两层上，</li>
<li>对任意结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1</li>
</ul>
<p><img src="/posts/18d54854/image-20241031204537868.png" alt="image-20241031204537868"></p>
<h6 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h6><p>​      在二叉树的第i层上至多有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.915ex" height="1.887ex" role="img" focusable="false" viewbox="0 -833.9 1730.6 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>个结点</p>
<h6 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h6><p>​     深度为k的二叉树至多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点(k&gt;=1)</p>
<h6 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h6><p>​      对任何一个二叉树<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.871ex" role="img" focusable="false" viewbox="0 -677 1020.6 827"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>,如果其叶子为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 1036.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>,度为2的结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.339ex" role="img" focusable="false" viewbox="0 -442 1036.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>，\则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="11.604ex" height="1.881ex" role="img" focusable="false" viewbox="0 -666 5129.1 831.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1314.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2370.1,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3628.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4629.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<p><img src="/posts/18d54854/image-20241031173605833.png" alt="image-20241031173605833"></p>
<p>​        eg:这里叶子结点7 8 9 10 11 12有6个,度为2的有1 2 3 4 5 有五个</p>
<p>总结点数n  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="20.578ex" height="1.846ex" role="img" focusable="false" viewbox="0 -666 9095.6 816"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(2970.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3542.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4264.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5264.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6301.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(6873.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7595.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8595.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 又 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="16.941ex" height="1.694ex" role="img" focusable="false" viewbox="0 -583 7488.1 748.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3192.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4192.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(5451.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(6451.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container></p>
<p>总边个数B <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="9.989ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4415 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2092.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2914.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3915,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>  =  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="17.041ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 7532.1 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2092.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(3129.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3701.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4423.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5423.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6460.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(7032.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h6 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h6><p>具有n个结点的<strong>完全二叉树</strong>的深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.239ex" role="img" focusable="false" viewbox="0 -694 3489.7 989.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1989.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2989.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h6 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h6><p>如果有一颗<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的<strong>完全二叉树(</strong>深度为 [<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>)的结点按层编号(从第1层到第[<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>层，每层从左到右)，对<strong>任一结点i</strong>(1&lt;=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>&lt;=n),有</p>
<ol>
<li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>=1，则结点i是二叉树的根，无双亲;如果i&gt;1，则其<strong>双亲是结点[i /2]。</strong></li>
<li>如果2<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="5.155ex" height="1.586ex" role="img" focusable="false" viewbox="0 -661 2278.6 701"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1678.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点i为叶子结点，无左孩子;否则，<br>其<strong>左孩子是结点2i。</strong></li>
<li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.183ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 4501 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2845.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(3901,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>无右孩子;否则，其<strong>右孩</strong><br><strong>子是结点2i + 1。</strong></li>
</ol>
<p><strong>总结</strong>: 编号为i，他的父结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.043ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1345 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(345,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(845,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>,左结点为2i，右节点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.809ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2567.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<h4 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h4><p><img src="/posts/18d54854/image-20241031214118623.png" alt="image-20241031214118623"></p>
<h5 id="1-二叉树的顺序存储结构"><a href="#1-二叉树的顺序存储结构" class="headerlink" title="1.二叉树的顺序存储结构"></a>1.二叉树的顺序存储结构</h5><ul>
<li><p>实现：按满二叉树的结点层次编号，依次存放在二叉树的数据元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> SqBiTree[MAXTSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/18d54854/image-20241102133931076.png" alt="image-20241102133931076"></p>
</li>
<li><p>缺点： <img src="/posts/18d54854/image-20241102134705813.png" alt="image-20241102134705813"></p>
<p>结点间的关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树</p>
</li>
</ul>
<h5 id="2-二叉树的链式存储结构"><a href="#2-二叉树的链式存储结构" class="headerlink" title="2.二叉树的链式存储结构"></a>2.二叉树的链式存储结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchile</span>;</span><span class="comment">//左右孩子</span></span><br><span class="line">}BiNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/18d54854/image-20241102135937947.png" alt="image-20241102135937947"></p>
<p>在n个结点的二叉链表中，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个空指针域</p>
<p>必有2n个链域，除根节点外，每个结点有且仅有一个双亲，所有只会有n-1个结点的链域存放指针，指向非空子女结点</p>
<h5 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">Ichild</span>,*<span class="title">parent</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向双亲结点</span></span><br><span class="line">}TriTNode,*TriTree;</span><br></pre></td></tr></table></figure>
<h4 id="3-遍历二叉树和线索二叉树"><a href="#3-遍历二叉树和线索二叉树" class="headerlink" title="3.遍历二叉树和线索二叉树"></a>3.遍历二叉树和线索二叉树</h4><h5 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h5><p>先序遍历：根左右</p>
<p>中序遍历：左根右</p>
<p>后续遍历：左右根</p>
<p><img src="/posts/18d54854/image-20241102144633249.png" alt="image-20241102144633249">       </p>
<h6 id="先—根左右"><a href="#先—根左右" class="headerlink" title="先—根左右"></a>先—根左右</h6><p><img src="/posts/18d54854/image-20241102150119954.png" alt="image-20241102150119954"></p>
<p>ABELDHMIJ</p>
<h6 id="中—左根右"><a href="#中—左根右" class="headerlink" title="中—左根右"></a>中—左根右</h6><p><img src="/posts/18d54854/image-20241102150600713.png" alt="image-20241102150600713"></p>
<p>ELBAMHIDJ</p>
<h6 id="后—左右根"><a href="#后—左右根" class="headerlink" title="后—左右根"></a>后—左右根</h6><p><img src="/posts/18d54854/image-20241102151437701.png" alt="image-20241102151437701"></p>
<p>LEBMIHJDA </p>
<p>实例：<img src="/posts/18d54854/6E50FE1F8569BEB2D29488718E198F13.png" alt="6E50FE1F8569BEB2D29488718E198F13"></p>
<p><img src="/posts/18d54854/image-20241102154045025.png" alt="image-20241102154045025"></p>
<h5 id="2-根据遍历序列确定二叉树（先-中-后序）"><a href="#2-根据遍历序列确定二叉树（先-中-后序）" class="headerlink" title="2.根据遍历序列确定二叉树（先 中 后序）"></a>2.根据遍历序列确定二叉树（先 中 后序）</h5><ul>
<li><p>若二叉树中的各结点均不相同，则二叉树结点的先徐序列、中序序列和后序序列都是唯一的</p>
</li>
<li><p>由二叉树的先序和中序序列，或由二叉树的后序和中序序列可以确定唯一一颗二叉树</p>
</li>
</ul>
<h6 id="实例1：先序-中序"><a href="#实例1：先序-中序" class="headerlink" title="实例1：先序+中序"></a>实例1：先序+中序</h6><p>先：A B C D E F G H I</p>
<p>中：C D B F E A I H G J</p>
<p>解题思路</p>
<ol>
<li><p>由先知A必为根，B必为左   由中知 CDBFE在左部，IHGJ在右边</p>
<p><img src="/posts/18d54854/image-20241102180223951.png" alt="image-20241102180223951"></p>
</li>
<li><p>由先序知道B为根，由中序知道CD为左子树，FE为右子树</p>
<p><img src="/posts/18d54854/image-20241102180244711.png" alt="image-20241102180244711"></p>
</li>
<li><p>由先序知道G是根，那么I H为左子树，J为右子树</p>
<p><img src="/posts/18d54854/image-20241102181222814.png" alt="image-20241102181222814"></p>
</li>
<li><p>由中序CD左根右知道，c为左，d为右，先序知道E为根，中序知道F为左</p>
<p><img src="/posts/18d54854/image-20241102181439508.png" alt="image-20241102181439508"></p>
</li>
<li><p>由中序知道I为左子树</p>
<p><img src="/posts/18d54854/image-20241102181539924.png" alt="image-20241102181539924"></p>
</li>
</ol>
<h6 id="实例2—中序-后续"><a href="#实例2—中序-后续" class="headerlink" title="实例2—中序+后续"></a>实例2—中序+后续</h6><ol>
<li>中序序列:BDCEAFHG</li>
<li>后序序列:DECBHGFA</li>
<li>由中序后续知道根为A，BDCE为左根 FHG为右根</li>
<li>后序知道B为根，中序推出没有左根，c为下一个根</li>
<li>左右根D为左，E为右边</li>
<li>后序知道F为根</li>
<li>由中序知道F没有左，那么H为左，G为根</li>
</ol>
<p><img src="/posts/18d54854/image-20241102183841772.png" alt="image-20241102183841772"></p>
<h5 id="3-遍历的算法实现-先序遍历"><a href="#3-遍历的算法实现-先序遍历" class="headerlink" title="3.遍历的算法实现-先序遍历"></a>3.遍历的算法实现-先序遍历</h5><p><img src="/posts/18d54854/image-20241102201045571.png" alt="image-20241102201045571"></p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);</span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="递归代码解释"><a href="#递归代码解释" class="headerlink" title="递归代码解释"></a>递归代码解释</h6><ol>
<li><p>首先进入函数，此时T为传入的根结点</p>
</li>
<li><p>打印根节点</p>
</li>
<li><p>第一次调用：<strong>根左右</strong>函数指向根B</p>
</li>
<li><p>进入第二层循环 遍历左，左为空此时返回</p>
</li>
<li><p>回到第二层循环此时 PerOrderTraverse(T-&gt;lchild);为空，那么自动执行下一条语句PerOrderTraverse(T-&gt;rchile);</p>
</li>
<li><p>进入循环，执行到D</p>
</li>
<li><p>再向下执行为空返回到第一次循环</p>
</li>
<li><p>再执行C</p>
<p><img src="/posts/18d54854/image-20241103142345827.png" alt="image-20241103142345827"></p>
</li>
</ol>
<p>(●ˇ∀ˇ●)明白了吗！</p>
<h5 id="4-遍历的算法实现-中序遍历"><a href="#4-遍历的算法实现-中序遍历" class="headerlink" title="4.遍历的算法实现-中序遍历"></a>4.遍历的算法实现-中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="5-历的算法实现-后序遍历"><a href="#5-历的算法实现-后序遍历" class="headerlink" title="5.历的算法实现-后序遍历"></a>5.历的算法实现-后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         </span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="6-二叉树遍历小总结"><a href="#6-二叉树遍历小总结" class="headerlink" title="6.二叉树遍历小总结"></a>6.二叉树遍历小总结</h5><p><img src="/posts/18d54854/image-20241103143731170.png" alt="image-20241103143731170"></p>
<p>时间复杂度O(n)//每个结点只访问一次</p>
<p>空间复杂度O(n)//栈占用的最大辅助空间</p>
<h5 id="7-中序遍历非递归算法-栈"><a href="#7-中序遍历非递归算法-栈" class="headerlink" title="7.中序遍历非递归算法-栈"></a>7.中序遍历非递归算法-栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    BiTree P;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化</span></span><br><span class="line">    P=T;</span><br><span class="line">    <span class="keyword">while</span> (p||StackEmpty(S))<span class="comment">//遇到的是根的时候</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(P)<span class="comment">//不为空</span></span><br><span class="line">        {</span><br><span class="line">            Push(S,p);<span class="comment">//入栈</span></span><br><span class="line">            p=p-&gt;Ichild;<span class="comment">//访问左子树</span></span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Pop(S,q);<span class="comment">//出栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data);<span class="comment">//输出根</span></span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="8-二叉树的层次遍历"><a href="#8-二叉树的层次遍历" class="headerlink" title="8.二叉树的层次遍历"></a>8.二叉树的层次遍历</h5><p><img src="/posts/18d54854/image-20241103154648957.png" alt="image-20241103154648957"></p>
<p><img src="/posts/18d54854/image-20241103154702890.png" alt="image-20241103154702890"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    BTNode data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rar;</span><br><span class="line">    </span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">{</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化</span></span><br><span class="line">    enQuenue(qu,b);<span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu)){<span class="comment">//队不为空则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出栈结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);访问结点p</span><br><span class="line">        <span class="title function_">if</span><span class="params">(p-&gt;Ichild!=<span class="literal">NULL</span>)</span><span class="title function_">enQueue</span><span class="params">(qu,p-&gt;Ichild)</span>;<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)enqueue(qu,p-&gt;rchild);<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="9-二叉树遍历算法的应用"><a href="#9-二叉树遍历算法的应用" class="headerlink" title="9.二叉树遍历算法的应用"></a>9.二叉树遍历算法的应用</h5><h6 id="1-二叉树的建立"><a href="#1-二叉树的建立" class="headerlink" title="1.二叉树的建立"></a>1.二叉树的建立</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">"#"</span>) T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">if</span>(!(T=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">        <span class="built_in">exit</span>(OVRTFLOW);</span><br><span class="line">    T-&gt;data=ch;<span class="comment">//生成根节点</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;Ichild);<span class="comment">//构造左子树</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}<span class="comment">//CreateBiTree</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/18d54854/image-20241103164836364.png" alt="image-20241103164836364"></p>
<h6 id="2-复制二叉树"><a href="#2-复制二叉树" class="headerlink" title="2.复制二叉树"></a>2.复制二叉树</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T,BiTree &amp;newT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">        NewT=new BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line"></span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="3-计算二叉树的深度"><a href="#3-计算二叉树的深度" class="headerlink" title="3.计算二叉树的深度"></a>3.计算二叉树的深度</h6><ul>
<li><p>如果是空树，则深度为0</p>
</li>
<li><p>否则，递归计算左子树的深度计为m，递归计算右子树的深度计为n，二叉树的深度则为m与n的较大者<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        m= Depth(T-&gt;lchild);</span><br><span class="line">        n= Depth(T-&gt;rchile);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="4-计算二叉树的结点总数"><a href="#4-计算二叉树的结点总数" class="headerlink" title="4.计算二叉树的结点总数"></a>4.计算二叉树的结点总数</h6><ul>
<li>如果为空树则结点为0</li>
<li>否则，结点个数为左子树个数+右子树结点个数再+1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(Bitree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild)+ NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="5-计算叶子结点的个数"><a href="#5-计算叶子结点的个数" class="headerlink" title="5.计算叶子结点的个数"></a>5.计算叶子结点的个数</h6><ul>
<li>如果是空树返回0</li>
<li>否则，为左子树的叶子结点+右子树的叶子结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchile==<span class="literal">NULL</span>)<span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+leafCount(T-&gt;rchile);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="10-线索二叉树"><a href="#10-线索二叉树" class="headerlink" title="10.线索二叉树"></a>10.线索二叉树</h5><ul>
<li>如果某个结点的左孩子为空，则将空的左孩子指针域改为<strong>指向其前驱</strong>；</li>
<li>如果某孩子的右结点为空，则将空的右孩子的指针域改为<strong>指向其后继</strong>；</li>
</ul>
<p><img src="/posts/18d54854/image-20241104153725343.png" alt="image-20241104153725343"></p>
<p>这里是依照遍历来判断前驱后继，而不是图</p>
<h6 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;<span class="comment">//0表示是左/右孩子，1表示是前/后继</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><img src="/posts/18d54854/image-20241104155234167.png" alt="image-20241104155234167"></p>
<p><img src="/posts/18d54854/image-20241104155240636.png" alt="image-20241104155240636"></p>
<p><img src="/posts/18d54854/image-20241104155253366.png" alt="image-20241104155253366"></p>
<hr>
<h6 id="2-线索二叉树画法"><a href="#2-线索二叉树画法" class="headerlink" title="2.线索二叉树画法"></a>2.线索二叉树画法</h6><p><img src="/posts/18d54854/image-20241104155331910.png" alt="image-20241104155331910"></p>
<h6 id="3-遍历算法"><a href="#3-遍历算法" class="headerlink" title="3.遍历算法"></a>3.遍历算法</h6><p>408不要求掌握</p>
<h3 id="4-树和森林"><a href="#4-树和森林" class="headerlink" title="4.树和森林"></a>4.树和森林</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">408要求</span><br><span class="line">2森林与二叉树的转换</span><br><span class="line">3树和森林的遍历</span><br></pre></td></tr></table></figure>
<h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>森林：</strong>是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.642ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5145.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1267,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2422.8,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mn" transform="translate(4256.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4756.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>棵互不相交的树的集合</p>
<h4 id="2-双亲表示法"><a href="#2-双亲表示法" class="headerlink" title="2.双亲表示法"></a>2.双亲表示法</h4><ul>
<li><p><strong>实现</strong>：定义结构数组</p>
<p>​            存放树的结点</p>
<p>​             每个结点含两个域</p>
</li>
<li><p><strong>数据域</strong>：存放结点本身信息</p>
</li>
<li><p><strong>双亲域</strong>：指示本结点的双亲结点在数组中的位置</p>
</li>
</ul>
<p><img src="/posts/18d54854/image-20241104162141056.png" alt="image-20241104162141056"></p>
<p><strong>特点：</strong>找双亲容易，找孩子难</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>{</span><span class="comment">//树的结点定义</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAXTSIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数,根节点位置</span></span><br><span class="line">}PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-孩子链表"><a href="#3-孩子链表" class="headerlink" title="3.孩子链表"></a>3.孩子链表</h4><p>把每个结点的孩子结点排列起来，看成是一个线性表， 用单链表存储，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。</p>
<p><strong>解释</strong>：每个结点都有一个单链表，叶子节点的单链表是空表，然后再将这些链表的头指针存放在数组中</p>
<p><img src="/posts/18d54854/image-20241104164756540.png" alt="image-20241104164756540"></p>
<p>孩子结点结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> child;<span class="comment">//整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个孩子的地址</span></span><br><span class="line">}* ChildPrt;</span><br></pre></td></tr></table></figure>
<p>双亲结点结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    ChildPrt firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">}CTBox;</span><br></pre></td></tr></table></figure>
<p>树结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    CTBox nodes[MAXTSIZE];<span class="comment">//头指针数组</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数和根节点位置下标</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></table></figure>
<p><strong>特点:</strong>找孩子容易，找双亲难</p>
<h4 id="4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）"><a href="#4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）" class="headerlink" title="4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）"></a>4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>实现：</strong>用二叉链表作树的存储结构，链表中的美观结点的指针域分别指向其<strong>第一个孩子节点</strong>和<strong>下一个兄弟节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>{</span></span><br><span class="line">    ELemtype data;<span class="comment">//元素类型 数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子，下一个兄弟</span></span><br><span class="line">}CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<p>左孩子 右兄弟，是兄弟的就来砍我</p>
<p><img src="/posts/18d54854/image-20241104171329061.png" alt="image-20241104171329061"></p>
<p>特点：找孩子，找兄弟简单，找双亲难</p>
<h4 id="5-树与二叉树的转换"><a href="#5-树与二叉树的转换" class="headerlink" title="5.*树与二叉树的转换"></a>5.*树与二叉树的转换</h4><h5 id="1-定义-6"><a href="#1-定义-6" class="headerlink" title="1.定义"></a>1.定义</h5><ul>
<li>将树转化为二叉树，利用二叉树的算法实现对树的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则以二叉树链表作媒介可以导出树与二叉树之间的对应关系</li>
</ul>
<p><img src="/posts/18d54854/image-20241104173140758.png" alt="image-20241104173140758"></p>
<h5 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h5><h6 id="1-将树转为二叉树"><a href="#1-将树转为二叉树" class="headerlink" title="1.将树转为二叉树"></a>1.将树转为二叉树</h6><ol>
<li><p>加线:在兄弟之间加一连线</p>
</li>
<li><p>抹线:对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
</li>
<li>旋转:以树的根结点为轴心，将整树顺时针转45°</li>
</ol>
<p><img src="/posts/18d54854/image-20241104173843558.png" alt="image-20241104173843558"></p>
<h6 id="2-将二叉树转为树"><a href="#2-将二叉树转为树" class="headerlink" title="2.将二叉树转为树"></a>2.将二叉树转为树</h6><ol>
<li>加线:若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩….沿分支找到的所有右孩子，都与p的双亲用线连起来</li>
<li>抹线:抹掉原二叉树中双亲与右孩子之间的连线</li>
<li>调整:将结点按层次排列，形成树结构</li>
</ol>
<p><img src="/posts/18d54854/image-20241104173926325.png" alt="image-20241104173926325"></p>
<h4 id="6-森林和二叉树的转换（二叉树与多棵树之间的关系"><a href="#6-森林和二叉树的转换（二叉树与多棵树之间的关系" class="headerlink" title="6.*森林和二叉树的转换（二叉树与多棵树之间的关系)"></a>6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</h4><h5 id="1-定义-7"><a href="#1-定义-7" class="headerlink" title="1.定义"></a>1.定义</h5><ol>
<li><p>将各棵树分别转换成二叉树</p>
</li>
<li><p>将每棵树的根结点用线相连</p>
</li>
<li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer"><div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>谢谢你的观看-------------</div>
    
</div>



          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>李阳
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://lyay23.github.io/posts/18d54854/" title="C语言数据结构">http://lyay23.github.io/posts/18d54854/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> C语言</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/9ec06885/" rel="prev" title="C语言基础">
                  <i class="fa fa-angle-left"></i> C语言基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/6ead9846/" rel="next" title="力扣">
                  力扣 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC82MDIyMS8zNjY4OQ"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李阳</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">41k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:15</span>
  </span>
</div><div>
<!--添加网站运行时间-->
<span>我已经陪伴你</span>
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    function createtime() {
        const startTime = '10/27/2024 00:00:00',
            start = new Date(startTime)
        let mill = new Date() - start,
            seconds = Math.floor(mill / 1000),
            mins = Math.floor(seconds / 60),
            hours = Math.floor(mins / 60),
            days = Math.floor(hours / 24)
        const time = {
            seconds: seconds - mins * 60,
            mins: mins - hours * 60,
            hours: hours - days * 24,
        }
        for (const k in time) {
            time[k] = `${time[k]}`.padStart(2, '0')
        }
        document.getElementById("timeDate").innerHTML = ` ${days} 天`
        document.getElementById("times").innerHTML = ` ${time.hours} 小时 ${time.mins} 分 ${time.seconds} 秒`
    }
    setInterval(createtime, 500)
</script>
</div>





    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>


<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","mache":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '100px',
  right: 'unset',
  left: '10px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script src="/js/third-party/comments/livere.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right"},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
