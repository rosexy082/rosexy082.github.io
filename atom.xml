<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李阳的秘密小屋</title>
  
  <subtitle>欢迎光临！</subtitle>
  <link href="http://lyay23.github.io/atom.xml" rel="self"/>
  
  <link href="http://lyay23.github.io/"/>
  <updated>2024-11-20T05:28:35.167Z</updated>
  <id>http://lyay23.github.io/</id>
  
  <author>
    <name>李阳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="http://lyay23.github.io/posts/79666db/"/>
    <id>http://lyay23.github.io/posts/79666db/</id>
    <published>2024-11-15T13:34:21.000Z</published>
    <updated>2024-11-20T05:28:35.167Z</updated>
    
    <content type="html"><![CDATA[<h1>C语言–数据结构</h1><p>---------------------------------------内容参考《郝斌数据结构》，《王道》《王卓》</p><span id="more"></span><p>文章被隐藏目录</p><ul><li><a href="#7.%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86">树与森林的遍历</a></li><li><a href="#7.*%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8">哈夫曼树</a></li></ul><h2 id="一、数据结构之基础">一、数据结构之基础</h2><h3 id="1-数据结构的三要素">1.数据结构的三要素</h3><p><img src="/posts/79666db/image-20240911162821303-1731069393910-1.png" alt="image-20240911162821303"></p><p>1.若采用顺序存储，则各个数据元素在物理上必须是连续的;若采用非顺序存储，则各个数据元素在物理上可以是离散的。<br>2.数据的存储结构会影响存储空间分配的方便程度<br>3数椐的存储结构会影响对数据运算的速度</p><p><img src="/posts/79666db/image-20241009153911315-1731069393910-2.png" alt="image-20241009153911315"></p><h4 id="数据的存储结构有几种"><strong>数据的存储结构有几种</strong></h4><p>​    线性</p><p>​          连续存储（数组）</p><p>​                   优点：存储速度很快</p><p>​                   缺点：插入和删除元素很慢，空间通常是有限的</p><p>​           离散存储（链表）</p><p>​                    优点：空间没有限制，插入删除元素很快</p><p>​                    缺点：存取速度很慢</p><h3 id="2、存储结构">2、存储结构</h3><p><img src="/posts/79666db/image-20240911163008131-1731069393910-3.png" alt="image-20240911163008131"></p><h4 id="顺序结构">顺序结构</h4><p>顺序存储,把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><h4 id="链式存储">链式存储</h4><p>链式存储，逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。（指针链接指针）</p><h4 id="索引存储">索引存储</h4><p>索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)离散的</p><h4 id="散列存储">散列存储</h4><p>散列存储。根据元素的夭键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p><h3 id="3-算法特征：">3.算法特征：</h3><p>确定性，可行性，输入，输出</p><h4 id="好算法特征：">好算法特征：</h4><p>正确性，可读性，健壮性，高效率与低存储需求（时间，空间复杂度低）</p><p><img src="/posts/79666db/image-20240911172342285-1731069393910-4.png" alt="image-20240911172342285"></p><h2 id="二、链表">二、链表</h2><h3 id="1-数组的优缺点：">1.数组的优缺点：</h3><p>优点：存储速度快</p><p>缺点：需要一个连续很大的内存，插入和删除元素的效率很低</p><h3 id="2-链表">2.链表</h3><p>优点：插入 删除元素效率高，不需要一个连续的很大内存</p><p>缺点：查找某个元素的效率低</p><h3 id="3-术语：">3.术语：</h3><h4 id="首节点"><strong>首节点</strong></h4><ul><li>存放第一个有效数据的节点</li></ul><h4 id="尾节点"><strong>尾节点</strong></h4><ul><li>存放最后一个元素的有效数据节点</li></ul><h4 id="头结点："><strong>头结点：</strong></h4><ol><li>头结点的数据类型和首节点的类型是一样的</li><li>头结点是首结点前面的那个节点</li><li>头结点里面不存放有效数据</li><li>设置结点是为了方便对链表经行操作</li></ol><h4 id="头指针"><strong>头指针</strong></h4><ul><li>存放头结点的地址的指针变量</li><li>可以通过头指针推算出链表的其他信息</li></ul><h3 id="4-链表的定义">4.链表的定义</h3><ul><li>n个节点离散分配</li><li>彼此通过指针相连接</li><li>每个节点只有一个前驱节点和后驱节点</li><li>首节点没有前驱节点，  尾节点没有后续节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> date;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,*pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-分类：">5.分类：</h3><ul><li><p>单链表</p></li><li><p>双链表</p><p>​        每一个节点都有两个指针域</p></li><li><p>循环链表</p><p>​       能通过任何一个节点找到其他所有节点</p></li><li><p>非循环链表</p></li></ul><h3 id="6-算法">6.算法</h3><p>遍历</p><p>查找</p><p>清空</p><p>销毁</p><p>排序</p><p>删除节点</p><p>插入节点</p><h3 id="7-创建带头单链表并遍历输出">7.创建带头单链表并遍历输出</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义单链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表（带头）</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-※链表的基本操作※">8.※链表的基本操作※</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by 李阳 on 2024/9/26.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之单链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一元素的指针域-递归（相同类型的指针)</span></span><br><span class="line">}Node,* pNode;<span class="comment">//node等价于struct Node,pNode等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pNode)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode,<span class="type">int</span> ,<span class="type">int</span> )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    pNode pHead =<span class="literal">NULL</span>;<span class="comment">//等价于struct Node * pHead =NULL;</span></span><br><span class="line">    pHead = creat_list();<span class="comment">//创建一个非循环的单链表，并将该链表的头结点的地址给pHead</span></span><br><span class="line">    traverse_list(pHead);<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //判断链表是否为空</span></span><br><span class="line"><span class="comment">    if(is_empty(pHead))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表为空！\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("链表不空");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //返回链表长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int len= length_list(pHead);</span></span><br><span class="line"><span class="comment">    printf("链表长度是 %d\n",len);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //排序</span></span><br><span class="line"><span class="comment">    printf("从小到大排序后的代码是：\n");</span></span><br><span class="line"><span class="comment">    sort_list(pHead);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //插入</span></span><br><span class="line"><span class="comment">    insert_list(pHead,3,44);</span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //删除</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    if(delete_list(pHead,3,&amp;val))</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        printf("删除成功，您删除的元素是%d\n",val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    } else</span></span><br><span class="line"><span class="comment">        printf("删除未成功\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    traverse_list(pHead);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pNode <span class="title function_">creat_list</span><span class="params">()</span> {<span class="comment">//返回值是一个地址</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//用来临时存放用户输入的节点值</span></span><br><span class="line">  <span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">    pNode pHead =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNode pTail=pHead;<span class="comment">//定义了一个指针变量，首先分配一个头节点 pHead。然后，将 pTail 初始化为指向这个头节点。由于此时链表为空，头节点也是尾节点。</span></span><br><span class="line">    pTail-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//地址为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表的节点个数：len ="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个节点的值"</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line">        pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        pNew-&gt;data=val;<span class="comment">//将临时val的值放给新创的节点</span></span><br><span class="line">        pTail-&gt;pNext=pNew;<span class="comment">// 设置为指向新节点的指针，这样新节点就被添加到了链表的末尾</span></span><br><span class="line">        pNew-&gt;pNext=<span class="literal">NULL</span>;</span><br><span class="line">        pTail=pNew;<span class="comment">//pTail 将指向链表的最后一个节点(更新，向后移）</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">      pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将链表的头指针给p</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> !=p)<span class="comment">//p不为NULL时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,p-&gt;data);<span class="comment">//打印p的数据</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p向后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pHead-&gt;pNext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pHead-&gt;pNext;<span class="comment">//定义了一个指针变量p，将头节点的地址给他</span></span><br><span class="line">    <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p)<span class="comment">//如果这里面是空的</span></span><br><span class="line">    {</span><br><span class="line">        ++len;<span class="comment">//++</span></span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向下一个元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(pNode pHead)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i,j,t;</span><br><span class="line"><span class="type">int</span> len = length_list(pHead);</span><br><span class="line">pNode p,q;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>,p=pHead-&gt;pNext; i &lt;len<span class="number">-1</span> ; ++i,p=p-&gt;pNext) {<span class="comment">//p放的是第一个元素，</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>,q=p-&gt;pNext; j &lt;len ; ++j,q=q-&gt;pNext) {<span class="comment">//q放的是p的后面的一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            {</span><br><span class="line">                t=p-&gt;data;</span><br><span class="line">                p-&gt;data=q-&gt;data;</span><br><span class="line">                q-&gt;data=t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入--在第pos的前面插入一个新的节点val，pos从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pNode pNew =(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pNew)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    pNew -&gt;data=val;<span class="comment">//定义了一个新节点，将val先放进去</span></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//p此时已经来到了pos-1的地方，也就是他的前面，</span></span><br><span class="line">    p-&gt;pNext=pNew;<span class="comment">//将他的地址给pNew</span></span><br><span class="line">    pNew-&gt;pNext=q;<span class="comment">//再将pNew的下一元素的地址给next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(pNode pHead,<span class="type">int</span> pos,<span class="type">int</span> * pval)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    pNode p=pHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span>!=p-&gt;pNext &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span> ==p-&gt;pNext)<span class="comment">//pos-1:eg:删除第3个必须要知道第二个</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode q=p-&gt;pNext;<span class="comment">//第pos个节点</span></span><br><span class="line">    *pval=q-&gt;data;<span class="comment">//将要删除的节点保存下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除p节点后面的节点</span></span><br><span class="line">    p-&gt;pNext=p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="9-李阳的线性表">9.李阳的线性表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/11.--线性表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DateType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    DateType data[MAXNUM];<span class="comment">//定义了一个数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span> <span class="params">(SqList *L)</span>{</span><br><span class="line">      L-&gt;length=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType d)</span><span class="comment">//第i位置插入d</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;MAXNUM)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表满了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = L-&gt;length; k &gt;=i ; k--) <span class="comment">//依次向后移</span></span><br><span class="line">    {</span><br><span class="line">        L-&gt;data[k]=L-&gt;data[k<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=d;<span class="comment">//当用户输入在3的位置插入，其实是在索引2的位置，如果想</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//修改，可以将k&gt;=i改为k&gt;i即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListDelete</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType *d)</span><span class="comment">//删除第i个元素并保存在d中</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *d=L-&gt;data[i<span class="number">-1</span>];<span class="comment">//保存被删除的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;L-&gt;length;k++)<span class="comment">//找到被删除元素位置</span></span><br><span class="line">    {</span><br><span class="line">       L-&gt;data[k<span class="number">-1</span>]= L-&gt;data[k];<span class="comment">//向前移</span></span><br><span class="line">    }</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseList</span><span class="params">(SqList L)</span><span class="comment">//这里传的L而不是*L是值传递，不需要对数据进行修改</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,L.data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指定位置元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListUpdate</span><span class="params">(SqList *L,<span class="type">int</span> i,DateType e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找索引为i的指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListGit</span><span class="params">(SqList L,<span class="type">int</span> i,DateType *x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    *x=L.data[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素的位置（返回第一个匹配元素的位置）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, DateType e)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回的是位置索引，从1开始计数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    SqList  L;</span><br><span class="line">    initList(&amp;L);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    ListInsert(&amp;L,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    ListInsert(&amp;L,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">    DateType d;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    ListDelete(&amp;L,<span class="number">2</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除的元素是：%d "</span>,d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    TraverseList(L);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-李阳的带头单链表">10.李阳的带头单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/12.</span></span><br><span class="line"><span class="comment">//带头单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Node * <span class="title function_">initList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">     Node * head=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">instertATEnd</span><span class="params">(Node * head ,<span class="type">int</span> date)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode -&gt;data=date;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node *temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertATHead</span><span class="params">(Node * head,<span class="type">int</span>  data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=head-&gt;next;<span class="comment">//尾巴结点为NULL</span></span><br><span class="line">    head-&gt;next=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node * head)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node * head, <span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp;temp-&gt;next-&gt;data!=data)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        Node * current=temp-&gt;next;</span><br><span class="line">        temp-&gt;next=current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没找到哦"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(Node* head, <span class="type">int</span> index)</span> {</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; count &lt; index) {</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"索引 %d 越界\n"</span>, index);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 或者返回一个特殊值表示错误，比如 INT_MIN 或 -1（需要包含 &lt;limits.h&gt;）</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getListLength</span><span class="params">(Node* head)</span> {</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 不计算头结点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        length++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表内存的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(Node* head)</span> {</span><br><span class="line">    Node* current = head-&gt;next; <span class="comment">// 从头结点的下一个节点开始释放</span></span><br><span class="line">    Node* nextNode;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) {</span><br><span class="line">        nextNode = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">        current = nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(head); <span class="comment">// 最后释放头结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置添加数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertList</span><span class="params">(Node * head,<span class="type">int</span> i,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node * newNode =(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊情况：在头部插入</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span> &amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != i - <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 位置超出链表长度</span></span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置超出链表长度\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=temp-&gt;next;</span><br><span class="line">    temp-&gt;next=newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引删除元素，并将值保存在data中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteList</span><span class="params">(Node* head,<span class="type">int</span> i,<span class="type">int</span> *data)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// 链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空，无法删除\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=head;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp; index&lt;i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index!=i<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      Node * current=temp-&gt;next;</span><br><span class="line">    *data=current-&gt;data;</span><br><span class="line"></span><br><span class="line">    temp-&gt;next=current-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    Node * head=initList();</span><br><span class="line"></span><br><span class="line">    instertATEnd(head,<span class="number">1</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">2</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">3</span>);</span><br><span class="line">    instertATEnd(head,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"尾插法"</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"头插法\n"</span>);</span><br><span class="line"></span><br><span class="line">    insertATHead(head,<span class="number">5</span>);</span><br><span class="line">    insertATHead(head,<span class="number">4</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    deleteNode(head,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表长度</span></span><br><span class="line">    <span class="type">int</span> length = getListLength(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Linked list length: %d\n"</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、栈">三、栈</h2><h3 id="1-定义">1.定义</h3><p>​             一种可以实现“先进后出”的存储结构</p><p>​            栈类似于一个箱子，先放进去的后拿出来，后进去的先拿出来</p><h3 id="2-分类">2.分类</h3><p>静态栈</p><p>动态栈</p><h3 id="3-算法">3.算法</h3><p>​      出栈</p><p>​      压栈</p><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构之栈 o.O</span></span><br><span class="line"><span class="comment"> *  Created by 李阳 on 2024/10/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pNext</span>;</span></span><br><span class="line">}Node,*pNode;</span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    pNode pTop;<span class="comment">//元素顶部</span></span><br><span class="line">    pNode pBottom;<span class="comment">//元素底部</span></span><br><span class="line">}sTack,*pStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">   sTack S;<span class="comment">//sTack等价于 struct Stack--建立了一个名为S的成员变量，里面有两个元素，ptop和pbottom，里面暂时没有有效数据</span></span><br><span class="line"></span><br><span class="line">   initStack(&amp;S);<span class="comment">//初始化-造出空栈</span></span><br><span class="line">   pushStack(&amp;S,<span class="number">1</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">2</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">3</span>);<span class="comment">//压栈</span></span><br><span class="line">    pushStack(&amp;S,<span class="number">4</span>);<span class="comment">//压栈</span></span><br><span class="line"></span><br><span class="line">    traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    clear(&amp;S);</span><br><span class="line">   <span class="comment">// traverse(&amp;S);//输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>( popStack(&amp;S,&amp;val))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈成功，出栈的元素是：%d\n"</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈失败\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   traverse(&amp;S);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pS-&gt;pTop=(pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));<span class="comment">//将top指向一个新造的空节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pS-&gt;pTop)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pS-&gt;pBottom=pS-&gt;pTop;<span class="comment">//地址都指向空节点</span></span><br><span class="line">        pS-&gt;pTop-&gt;pNext=<span class="literal">NULL</span>;<span class="comment">//将新造的节点的指针域为空--因为他是最后一个元素的下一个元素，因此没有指针域</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈--进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(pStack pS,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pNode pNew=(pNode) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (Node));</span><br><span class="line">    pNew-&gt;data=val;</span><br><span class="line">    pNew-&gt;pNext=pS-&gt;pTop;<span class="comment">//此时ptoop里面放的是初始化时的临时变量地址，这里调用，将新建的栈的指针域指向初始化的元素地址</span></span><br><span class="line">    pS-&gt;pTop=pNew;<span class="comment">//再将新的节点地址给top</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    pNode p=pS-&gt;pTop;<span class="comment">//定义个临时指针变量p，将头的值给p，</span></span><br><span class="line">    <span class="keyword">while</span> (p!=pS-&gt;pBottom)<span class="comment">//当p为底部元素时程序终止</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;<span class="comment">//p指向p的下一元素地址</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop==pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(pStack pS,<span class="type">int</span> * pVal)</span><span class="comment">//把ps所指向的栈出栈一次，并将出栈元素存入pval新参所指向的变量中，成功返回true，否则false</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span>(empty(pS))</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     {</span><br><span class="line">        pNode r=pS-&gt;pTop;<span class="comment">//定义一个变量r，将顶元素给r</span></span><br><span class="line">        *pVal=r-&gt;data;</span><br><span class="line">        pS-&gt;pTop=r-&gt;pNext;<span class="comment">//再将top指向下一元素，这样r就被孤立了</span></span><br><span class="line">         <span class="built_in">free</span>(r);</span><br><span class="line">         r=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(pStack pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    pNode p=pS-&gt;pTop;</span><br><span class="line">    pNode q=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=pS-&gt;pBottom)</span><br><span class="line">        {</span><br><span class="line">            q=p-&gt;pNext;<span class="comment">//q指向第二个</span></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p=q;<span class="comment">//p又指向了下一个元素了</span></span><br><span class="line">        }</span><br><span class="line">        pS-&gt;pTop=pS-&gt;pBottom;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-应用">4.应用</h3><p>函数调用</p><p>中断</p><p>表达式求值</p><p>内存分配</p><p>缓存处理</p><p>迷宫</p><h3 id="5-栈的表达式求值–后缀表达式（逆波兰表达式）">5.栈的表达式求值–后缀表达式（逆波兰表达式）</h3><p><strong>1.例如：1+2*3</strong></p><p>​     后缀表达式为 1 2 3 * +</p><p>​             遇到一个运算符他会在前面两个数字间运算</p><ol><li>​          2 *3</li><li>然后向后移到+</li><li>6+1</li></ol><p><strong>2、(a + b) * (c - (d / e)) + f</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b + c d e / - * f +</span><br></pre></td></tr></table></figure><p><strong>3.、a * (b + c) - (d / e)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c + * d e / -</span><br></pre></td></tr></table></figure><p><strong>4、a + b * (c - d / e) ^ f</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d e / - f ^ * +</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 操作数和运算符</span><br><span class="line">操作数（如变量和常数）直接添加到输出列表中。</span><br><span class="line">运算符则需要根据优先级和括号来决定是否入栈、弹出或保持在栈中。</span><br><span class="line">2. 运算符优先级</span><br><span class="line">运算符的优先级从高到低一般为：</span><br><span class="line">* 和 / （乘法和除法）优先级高</span><br><span class="line">+ 和 - （加法和减法）优先级低</span><br><span class="line">在遇到相同优先级的运算符时，按照左结合性处理（从左到右）。</span><br><span class="line">3. 括号的处理</span><br><span class="line">遇到左括号 ( 时，直接入栈。</span><br><span class="line">遇到右括号 ) 时，弹出栈中的运算符到输出，直到遇到对应的左括号为止，左括号被丢弃。</span><br><span class="line">4. 栈的使用</span><br><span class="line">当一个运算符被处理时，检查栈顶运算符的优先级：</span><br><span class="line">如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</span><br><span class="line">否则，将当前运算符入栈。</span><br><span class="line">5. 表达式结束时的处理</span><br><span class="line">当整个中序表达式处理完毕后，仍有运算符在栈中时，将它们全部弹出到输出。</span><br><span class="line">6. 后缀表达式的特征</span><br><span class="line">后缀表达式不需要括号，因为运算符的顺序和位置已经明确了运算的优先级和关联性。</span><br></pre></td></tr></table></figure><p><strong>当一个运算符被处理时，检查栈顶运算符的优先级：</strong><br><strong>如果栈顶运算符的优先级高于或等于当前运算符，则弹出栈顶运算符到输出。</strong><br><strong>否则，将当前运算符入栈。</strong></p><p>总结：</p><ul><li>栈底部的运算符永远是最低的</li><li>遇到括号先输出括号里的运算符，但不保留括号</li><li>当有刚入栈的运算符小于或等于当前栈中的运算符，那直接将栈出到小于此运算符的位置</li><li>来看个小例子吧：</li><li>1.当栈低为+或-时，来了个*或/时可以留着栈中，当此时又来了一个新运算符，假设为-，此时栈中的为+和*，那么将*和+直接出栈，-再放入栈中</li><li>2.假设栈底运算符为*或者/，当入栈为+或-时，那么将*或\出栈，将+或-压入栈底部</li><li>3.当栈低为+和*时，此时入栈了一个/那么将*出栈，+留在栈中，/也压入栈中</li></ul><p>特别注意：* / ^的运算符是在两个运算的字母后的</p><p>例题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eg:1. (A + B) * (C - D) / E ^ F </span><br><span class="line"> 遇到括号左括号进栈A输出+进栈B输出，扫描到右括号+出栈，此时为AB+</span><br><span class="line"> *入栈，左括号入栈C输出-入栈D输出右括号出栈，此时变为AB+CD-,栈低为*</span><br><span class="line"> 扫描/入栈，因为/的优先级不大于*，因此*出栈，此时变为AB+CD-*，栈低为/</span><br><span class="line"> E输出，^进栈^的优先级不大于/要出栈，但是因为我们的运算符要相匹配，因此F输出在依次输出栈/^,这里E F ^ 表示 E 和 F 进行指数运算。/ 表示乘法结果除以 E F ^ 的结果</span><br><span class="line"> AB+CD-*EF/^</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2. A + B * (C ^ D - E) ^ F / G</span><br><span class="line">   输出A,+进栈，输出B，此时为AB，+在栈里面</span><br><span class="line">   扫描左括号入栈，C输出，^进栈D输出，-进栈，因为我们的-优先级低于^,所以^的位置上移动，出栈，E输出扫描到又括号^出栈，-出栈，栈低为+和*，此时为ABCD^E-</span><br><span class="line">   ^入栈,因为^的优先级不大于*，所以*出栈，^入栈，栈里为+^，F输出,/进栈，因为FG是个组合，所以输出*FG/^  </span><br><span class="line">   结果是ABCD^E-*FG/^  </span><br></pre></td></tr></table></figure><h3 id="6-后缀表达式转中缀">6.后缀表达式转中缀</h3><p>我们学完了中缀转后缀下面来试一试后缀表达式转中缀吧！</p><p>我们先来看题吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AB+CD-*EF/^</span><br><span class="line"></span><br><span class="line">首先我们的ab进栈，这时我们扫描到运算符+，这时候就变成a+b，然后入栈（遇到运算符要与他的前两位进行计算）</span><br><span class="line">cd进栈，扫描到运算符-，就变成c-d然后入栈，此时栈里存放的是a+b 和c-d </span><br><span class="line">然后扫描到运算符* ，就变成 a+b * c-d ，因为我们左右两边是个整体，所以要加括号（a+b） * （c-d），然后再入栈</span><br><span class="line">EF进栈，扫描到/，就变成E/F,此时栈里存放的是（a+b） * （c-d） 和 （E/F）</span><br><span class="line">扫描到^ 就变成 （a+b） * （c-d） ^ （E/F）</span><br><span class="line">本题结束(●'◡'●)</span><br></pre></td></tr></table></figure><p>由此我们可以反推出 ：</p><p>字母总是两两存在的因此在中序转后缀需要考虑组合</p><p>后缀转中缀的是运算符之前的两位数字/字母进行计算</p><h3 id="7-李阳的栈">7.李阳的栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式栈</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span>{</span></span><br><span class="line">    Node * top;<span class="comment">//栈顶指针，初始化为NULL表示空栈</span></span><br><span class="line">} LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedStack * <span class="title function_">initStack</span><span class="params">()</span>{</span><br><span class="line">    LinkedStack * <span class="built_in">stack</span>=(LinkedStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=<span class="literal">NULL</span>; <span class="comment">// 初始化栈顶指针为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top==<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * 解析：让我来为你解析吧！</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个链表，然后一个空栈，里面有一个top指向NULL</span></span><br><span class="line"><span class="comment"> * 然后我们传入一个元素假设为1</span></span><br><span class="line"><span class="comment"> * 然后newNode-&gt;next=stack-&gt;top;// 新节点的next指向当前栈顶</span></span><br><span class="line"><span class="comment">    stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> *这俩是核心代码 我们直接说这个</span></span><br><span class="line"><span class="comment"> * stack-&gt;top上面初始化为NULL</span></span><br><span class="line"><span class="comment"> * 所以newNode-&gt;next里面就是NULL</span></span><br><span class="line"><span class="comment"> * 然后newNode为指针类型的， stack-&gt;top=newNode;就是将top指向了他的指针</span></span><br><span class="line"><span class="comment"> * 我理解的是双胞胎，栈的top的指针就指向了NewNode</span></span><br><span class="line"><span class="comment"> * 假设我们现在又传入了一个2</span></span><br><span class="line"><span class="comment"> * newNode-&gt;next=stack-&gt;top</span></span><br><span class="line"><span class="comment"> * 2的next里面放的是1的地址</span></span><br><span class="line"><span class="comment"> * stack-&gt;top=newNode;</span></span><br><span class="line"><span class="comment"> * 我们又将2的地址给了top，类似top再向上移动</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LinkedStack* <span class="built_in">stack</span>,<span class="type">int</span> data)</span>{</span><br><span class="line">    Node * newNode=(Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next=<span class="built_in">stack</span>-&gt;top;<span class="comment">// 新节点的next指向当前栈顶</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param stack</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * 我又来啦，现在由李阳为你解析链栈的出栈</span></span><br><span class="line"><span class="comment"> * 我们这个是有返回值的，首先传入一个栈是毋庸置疑的</span></span><br><span class="line"><span class="comment"> * 还需要一个小小的判断-如果栈里面没有元素呢</span></span><br><span class="line"><span class="comment"> * -------核心代码----</span></span><br><span class="line"><span class="comment"> * 首先我们定义了一个临时变量temp用于存放栈顶，</span></span><br><span class="line"><span class="comment"> * 这里top里面放的是最后一个元素的地址</span></span><br><span class="line"><span class="comment"> * 根据地址可以找到元素没问题吧</span></span><br><span class="line"><span class="comment"> * 然后我们再将栈顶的元素的下一个地址重新给top</span></span><br><span class="line"><span class="comment"> * 我们之前top里面放的是栈顶的地址，现在我们变成传入栈顶</span></span><br><span class="line"><span class="comment"> * 的下一元素的地址，也就是将top向下移动</span></span><br><span class="line"><span class="comment"> * o.O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span>{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">stack</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="type">int</span>  popData=temp-&gt;data;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top=temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> popData;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(LinkedStack *<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackTop</span><span class="params">(LinkedStack*<span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> topdata=temp-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> topdata;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span><br><span class="line">{</span><br><span class="line">      Node * temp=<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">      Node *nextNode;<span class="comment">//下一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//来检验一下吧^_^</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedStack *<span class="built_in">stack</span>=initStack();<span class="comment">//初始化</span></span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">1</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">2</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">3</span>);</span><br><span class="line">    push(<span class="built_in">stack</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a=  StackTop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈顶元素是：%d "</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> b= pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d出栈了"</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    printStack(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    freeStack(<span class="built_in">stack</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、队列">四、队列</h2><h3 id="1、定义">1、定义</h3><p>​        一种可以实现“先进先出”的存储结构–排队买票进站</p><h3 id="2-分类-2">2.分类</h3><p>​    链式队列（链表）</p><p>​    静态队列（数组）</p><p>​            静态队列通常都必须是循环队列</p><p>​                      <img src="/posts/79666db/image-20241010163206657-1729000222964-1.png" alt="image-20241010163206657"></p><h3 id="3-代码">3.代码</h3><p>郝斌老师代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by 李阳 on 2024/10/14.</span></span><br><span class="line"><span class="comment"> * 数据结构之静态循环队列o.O</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> *pBase;</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">//首</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//尾</span></span><br><span class="line">} QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;<span class="comment">//改变实参的值所以要加*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *,<span class="type">int</span>)</span>;<span class="comment">//入队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *,<span class="type">int</span> *pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    init(&amp;Q);<span class="comment">//调用初始化函数</span></span><br><span class="line">    en_queue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (out_queue(&amp;Q, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队成功: %d\n"</span>, val); <span class="comment">// 修正输出格式</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队失败\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    pQ-&gt;pBase=(<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)*<span class="number">6</span>);<span class="comment">//定义了6个数据的数组</span></span><br><span class="line">    pQ-&gt;front=pQ-&gt;rear=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *pQ,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear]=val;<span class="comment">//将值放入尾部，并且尾部要+1</span></span><br><span class="line">        pQ-&gt;rear=(pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;<span class="comment">//尾部+1--因为是循环队列，当他满的时候会又从0开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>==pQ-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> ((i!=pQ-&gt;rear))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> *pVal)</span><span class="comment">//因为要带回来值，所以要*</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">if</span>(emput_queue(pQ))</span><br><span class="line">   {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"表是空的"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   } <span class="keyword">else</span></span><br><span class="line">   {</span><br><span class="line">     *pVal=pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">     pQ-&gt;front=(pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="4-队列的操作">4.队列的操作</h3><p>所有和时间有关的操作</p><h3 id="5-李阳的队列">5.李阳的队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/13.--链式队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span> {</span></span><br><span class="line">    Node* front;  <span class="comment">// 队头指针</span></span><br><span class="line">    Node* rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">} LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">LinkedQueue * <span class="title function_">initQueue</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    LinkedQueue * <span class="built_in">queue</span>=(LinkedQueue*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="comment">//返回0为空，1不为空所以为int类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span> <span class="params">(LinkedQueue * <span class="built_in">queue</span>,<span class="type">int</span> data)</span></span><br><span class="line">{</span><br><span class="line">    Node *newNode=(Node* ) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next=newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue * <span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列是空的"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;<span class="comment">//先进先出</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">deque</span>=temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front=<span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;front==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node *temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,temp-&gt;data);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NUll\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    Node * temp=<span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    Node * nextNode;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        nextNode=temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        temp=nextNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFront</span><span class="params">(LinkedQueue*<span class="built_in">queue</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">queue</span>-&gt;front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    LinkedQueue* <span class="built_in">queue</span> = initQueue();</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 打印队列内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="type">int</span> temp = getFront(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"队头%d \n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue(<span class="built_in">queue</span>));</span><br><span class="line"></span><br><span class="line">    printQueue(<span class="built_in">queue</span>);  <span class="comment">// 再次打印队列内容</span></span><br><span class="line"></span><br><span class="line">    freeQueue(<span class="built_in">queue</span>);  <span class="comment">// 释放队列内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-李阳的循环队列">6.李阳的循环队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/16.-循环队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义循环队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> *data;  <span class="comment">// 指向队列数组的指针</span></span><br><span class="line">    <span class="type">int</span> max_size;  <span class="comment">// 队列的最大容量</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头索引</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾索引（指向下一个入队位置）</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 队列中当前元素的数量</span></span><br><span class="line">} CircularQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化循环队列</span></span><br><span class="line">CircularQueue* <span class="title function_">create_circular_queue</span><span class="params">(<span class="type">int</span> max_size)</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = (CircularQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularQueue));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_size = max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(max_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存分配失败\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查队列是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">enqueue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满，无法入队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = value;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dequeue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>, <span class="type">int</span> *value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空，无法出队\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    *value = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear) {</span><br><span class="line">        <span class="comment">// 队列中只有一个元素，出队后队列为空</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列中的所有元素（用于调试）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; <span class="built_in">queue</span>-&gt;size; count++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;max_size;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列占用的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_circular_queue</span><span class="params">(CircularQueue *<span class="built_in">queue</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data) {</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    CircularQueue *<span class="built_in">queue</span> = create_circular_queue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">20</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">30</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    dequeue(<span class="built_in">queue</span>, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队元素: %d\n"</span>, value);</span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">50</span>);</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, <span class="number">60</span>);  <span class="comment">// 这将导致队列满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次入队会失败，因为队列已满</span></span><br><span class="line">    <span class="comment">// enqueue(queue, 70);</span></span><br><span class="line"></span><br><span class="line">    print_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    free_circular_queue(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="五、递归">五、递归</h2><p><img src="/posts/79666db/image-20241015182021998-1731069393910-5.png" alt="image-20241015182021998"></p><h3 id="1-简单应用–阶层">1.简单应用–阶层</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构之递归</span></span><br><span class="line"><span class="comment"> * Created by 李阳 on 2024/10/15.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo1--求阶层</span></span><br><span class="line"><span class="comment">/* for循环版</span></span><br><span class="line"><span class="comment">int jiec(int a)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=1;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for ( i=1; i &lt;=a; ++i)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        b=b*i;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    return b;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int b=5;</span></span><br><span class="line"><span class="comment">    int a= jiec(b);</span></span><br><span class="line"><span class="comment">    printf("%d 的阶层是 %d",b,a);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>)*n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">long</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要求的阶层"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    b= f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld 的阶层是 %ld"</span>,a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现1+2+...</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="2-定义，要求，意义">2.定义，要求，意义</h3><h4 id="①定义：">①<strong>定义：</strong></h4><p>一个函数间接或直接调用自己</p><h4 id="②递归需要满足的三个条件">②<strong>递归需要满足的三个条件</strong></h4><ol><li>递归必须要有一个明确的终止条件</li><li>该函数所处理的数据规模必须在递减</li><li>这个转化必须是可解的</li></ol><h4 id="③意义">③<strong>意义</strong></h4><p>优点：易于理解</p><p>缺点：速度慢，存储空间大</p><h4 id="④循环：">④<strong>循环</strong>：</h4><p>不易理解，速度快，存储空间小</p><h2 id="六、串、数组和广义表">六、串、数组和广义表</h2><h3 id="一、串（string）">一、串（string）</h3><p>0个或多个任意字符组成的有限序列</p><h4 id="1-子串的定义">1.子串的定义</h4><p>一个串中任意个连续字符组成的子序列（含空串）称为该串的子串</p><p>例如：“abcd”的子串有</p><p>“ ”，“a",“ab”,“abc”,“abcd”</p><p><strong>真子串</strong>：是指不包含自身的所有子串</p><p><strong>主串</strong>:包含子串的串相应的称为主串</p><p><strong>字符位置</strong>:字符在序列中的序号为该字符串中的位置</p><p><strong>子串位置</strong>：子串第一个字符在主串中的位置</p><p>**空格串：**由一个或多个空格组成的串，与空串不同</p><p><img src="/posts/79666db/image-20241015220006062-1731069393910-6.png" alt="image-20241015220006062"></p><p>**串相等:**当且仅当两个串的长度相等并且各个对应立置上的字符都相同时，这两个串才是相等的。</p><h4 id="2-串的类型定义、存储结构及运算">2.串的类型定义、存储结构及运算</h4><p>顺序存储结构-顺序串</p><p>链式存储结构-链式串</p><h4 id="3-串的表示">3.串的表示</h4><h5 id="顺序存储">顺序存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串的顺序存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组1-255</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="链式存储-2">链式存储</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串的链式存储结构--块链结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> {</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE]; <span class="comment">// 存储字符块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个块的指针</span></span><br><span class="line">} Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    Chunk *head;  <span class="comment">// 串的首指针</span></span><br><span class="line">    Chunk *tail;  <span class="comment">// 串的尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;   <span class="comment">// 串的当前长度</span></span><br><span class="line">} LString;</span><br></pre></td></tr></table></figure><h4 id="4-串的模式匹配">4.串的模式匹配</h4><h5 id="1-BF算法（穷举法）">1.BF算法（穷举法）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_BF</span><span class="params">(SString S,SString T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i=(i-j)+<span class="number">2</span>;j=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">      <span class="keyword">return</span> i-T.length;<span class="comment">//匹配成功</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241016164724670-1731069393910-7.png" alt="image-20241016164724670"></p><h5 id="2-※※※-KMP算法">2.<strong>※※※ KMP</strong>算法</h5><p><img src="/posts/79666db/image-20241017130343420-1731069393910-8.png" alt="image-20241017130343420"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算模式串 T 的 next 数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j; <span class="comment">// 注意：next[i] 是 i 位置的前缀长度</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 算法实现，返回模式串 T 在主串 S 中首次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// S 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S.ch[i] == T.ch[j]) { <span class="comment">// j = -1 表示需要跳过</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == T.length) <span class="keyword">return</span> i - T.length; <span class="comment">// 匹配成功，返回匹配位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 匹配失败，返回 -1</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="3-KMP算法改进">3.KMP算法改进</h5><p><img src="/posts/79666db/image-20241017144344602-1731069393910-9.png" alt="image-20241017144344602"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// T 的当前位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">// 前缀的长度</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// next[0] 通常设为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = nextval[j]; <span class="comment">// 使用 next 数组回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="二、数组">二、数组</h3><h4 id="1-定义-2">1.定义</h4><p>按照一点格式排列起来的具有相同的数据元素集合</p><p><strong>一维数组</strong>：若线性表中的元素为非结构的简单元素，则称为一维数组（线性结构，定长的线性表）</p><p><strong>二维数组</strong>：若一维数组中的元素又是一维数组结构，则称为二维数组</p><p><strong>二维数组逻辑结构：</strong></p><ul><li>非线性结构： 每一个元素既在一个行表中，又在一个列表中</li><li>线性结构：该线性表的每一个元素也是一个定长的线性表</li></ul><p><strong>数组特点</strong>：结构固定–定义后，维度和为界不再改变</p><p><strong>结论</strong>:</p><ul><li>线性表结构是数组的一个特例</li><li>而数组结构又是线性表结构的扩展</li></ul><p><strong>基本操作</strong>：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作</p><p>一般采用顺序结构来表示数组</p><h4 id="2-存储位置">2.存储位置</h4><p><img src="/posts/79666db/image-20241017154244958-1731069393910-10.png" alt="image-20241017154244958"></p><p>数组元素a[i] [j] 的存储位置是 LOC(i,j)=LOC(0,0)+n * i+j * L(L是存储每个元素所需要L个存储单元)</p><h4 id="3-压缩存储">3.压缩存储</h4><ol><li>什么是压缩存储?<br>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间</li><li>什么样的矩阵能够压缩?<br>一些特殊矩阵，如:对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</li><li>什么叫稀疏矩阵?<br>矩阵中非零元素的个数较少（一般小于5%)</li></ol><h5 id="1-对称矩阵"><strong>1.对称矩阵</strong></h5><ol><li><h6 id="特点">[特点]</h6><p>沿着对角线对称</p><p>在nxn的矩阵a中，满足如下性质:    aij=aji (1 ≤i, j &lt;n)</p></li><li><h6 id="存储方法">[存储方法]</h6><p>只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p></li></ol><p><img src="/posts/79666db/image-20241017155259933-1731069393910-11.png" alt="image-20241017155259933"></p><p><img src="/posts/79666db/image-20241017155934811-1731069393910-12.png" alt="image-20241017155934811"></p><h5 id="2-三角矩阵"><strong>2.三角矩阵</strong></h5><ol><li><h6 id="特点-2">[特点]</h6><p>对角线以下(或者以上)的数据元素(不包括对角线)全部为常数co</p></li><li><h6 id="存储方法-2">[存储方法]</h6><p>重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间: sa[1… n(n+1)/2+1]</p></li></ol><p><img src="/posts/79666db/image-20241017160251060-1731069393911-13.png" alt="image-20241017160251060"></p><h5 id="3-对角矩阵（带状矩阵）"><strong>3.对角矩阵（带状矩阵）</strong></h5><p>[特点]在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p><img src="/posts/79666db/image-20241017160553699-1731069393911-14.png" alt="image-20241017160553699"></p><p><img src="/posts/79666db/image-20241017160653491-1731069393911-15.png" alt="image-20241017160653491"></p><h5 id="4-稀疏矩阵"><strong>4.稀疏矩阵</strong></h5><p>稀疏矩阵:设在mxn的矩阵中有t个非零元素。<br>令ɸ= t/(mxn)<br>当ɸ≤0.05时称为稀疏矩阵。</p><img src="/posts/79666db/image-20241017161616371-1731069393911-16.png" alt="image-20241017161616371" style="zoom:67%;"><img src="/posts/79666db/image-20241017161810079-1731069393911-17.png" alt="image-20241017161810079" style="zoom:67%;"><p>三元组顺序表又称有序的双下标法。</p><ol><li><p>三元组顺序表的优点:非零元在表中按行序有序存储，因此便于进</p><p>行依行顺序处理的矩阵运算。</p></li><li><p>三元组顺序表的缺点:不能随机存取。若按行号存取某一行中的非</p><p>零元，则需从头开始进行查找。</p></li></ol><h6 id="十字链表"><strong>十字链表</strong></h6><p>优点:它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算<br><img src="/posts/79666db/image-20241017162515773-1731069393911-18.png" alt="image-20241017162515773"></p><p><img src="/posts/79666db/image-20241017162538457-1731069393911-19.png" alt="image-20241017162538457"></p><p><img src="/posts/79666db/image-20241017163651081-1731069393911-20.png" alt="image-20241017163651081"></p><h3 id="三-广义表">三.广义表</h3><h4 id="1-定义-3">1.定义</h4><p>广义表 （又称列表Lists）是n≧0个元素 a0,a1…an-1的有限序列，其中每一个ai或者是原子，或者是一个广义表</p><p><img src="/posts/79666db/image-20241017164155126-1731069393911-21.png" alt="image-20241017164155126"></p><ul><li><p>广义表通常记作:Ls=(a1, a2,…，an)</p><p>其中:LS为表名，n为表的长度，每一个ai为表的元素</p></li><li><p>习惯上，一般用<strong>大写字母</strong>表示<strong>广义表</strong>，<strong>小写字母</strong>表示<strong>原子。</strong></p></li><li><p>**表头：**若LS非空(n≥1)，则其第一个元素a1就是表头。<br>记作head(LS) = a1。<strong>注</strong>:表头可以是原子，也可以是子表。</p></li><li><p><strong>表尾</strong>：除<strong>表头</strong>之外的<strong>其它元素</strong>组成的<strong>表</strong>。</p><p>​      记作tail(LS） = (a2, … an)。</p><p>​     注:表尾不是最后一个元素，而是一个<strong>子表。</strong></p></li></ul><p><img src="/posts/79666db/image-20241017170321265-1731069393911-22.png" alt="image-20241017170321265"></p><h4 id="2-性质">2.性质</h4><ul><li><p>(1)广义表中的数据元素有相对<strong>次序;一个直接前驱和一个直接后驱</strong></p></li><li><p>(2)广义表的<strong>长度</strong>定义为最外层所包含元素的个数;</p><p>​     如: C=(a (b, q))是长度为2的广义表。</p></li><li><p>(3)广义表的<strong>深度</strong>定义为该广义表<strong>展开后所含括号的重数</strong>;</p><p>​     A=(b ,c)的深度为1,B=(A,d)的深度为2，C=(f, B,h)的深度为3。</p><p>​     <strong>注意</strong>:“原子”的深度为0;“空表”的深度为1。</p></li><li><p>广义表可以为其他广义表<strong>共享</strong>，如：广义表B就共享了广义表A。在b中不必列出A的值，而是通过名称来引用，B=(A)</p></li><li><p>广义表可以是一个递归的表。如：F=（a,F=(a,(a,(a,…)))</p></li></ul><p>​               注意：递归表的深度是无穷值，长度是有限值，这里长度是2</p><ul><li>广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，….。<br>可以用图形象地表示。<br>例:D=(E，F）其中:E=(a, (b,c)）F=(d,(e))</li></ul><h4 id="3-广义表和线性表的区别">3.广义表和线性表的区别</h4><ol><li>广义表可以看成是线性表的推广，线性表是广义表的特例。</li><li>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</li><li>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</li><li>另外，树和有向图也可以用广义表来表示。</li><li>由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</li></ol><h4 id="4-广义表的基本运算">4.广义表的基本运算</h4><p><img src="/posts/79666db/image-20241031143536962-1731069393911-23.png" alt="image-20241031143536962"></p><p>案例分析</p><p><img src="/posts/79666db/image-20241031144308247-1731069393911-24.png" alt="image-20241031144308247"></p><p>代码实现</p><h2 id="七、树">七、树</h2><h3 id="1-树的定义">1.树的定义</h3><p><img src="/posts/79666db/image-20241031144903388-1731069393911-25.png" alt="image-20241031144903388"></p><h4 id="树的定义">树的定义</h4><p><strong>树</strong>(Tree)是n (n≥0)个结点的有限集。(递归)<br>若n =0，称为<strong>空树</strong>;<br>若n &gt;0，则它满足如下两个条件:<br>(1)<strong>有且仅有一个</strong>特定的称为<strong>根</strong>(Root)的结点;<br>(2)<strong>其余结点</strong>可分为m (m≥0)个互不相交的<strong>有限集</strong>T1,T2,T3,…Tm，其中每一个集合本身又是一棵树，并称为根的<strong>子树</strong>(SubTree)。</p><h4 id="树的基本术语">树的基本术语</h4><p><strong>结点</strong>：数据元素以及指向树的分支</p><p><strong>根结点</strong>：非空树中无前驱点的结点</p><p><strong>结点的度</strong>：结点拥有的子树数</p><p>​    eg: A 3,B 2,F 0</p><p><img src="/posts/79666db/image-20241031152141050-1731069393911-26.png" alt="image-20241031152141050"></p><p><strong>树的度</strong>： 数内各结点的度的最大值</p><p><strong>叶子结点</strong>:终端结点（度为0）</p><p>​          eg: k L G M J</p><p><strong>分支结点</strong>:非终端结点</p><p>​            eg: B,C,D…</p><p><strong>内部结点</strong>:根节点以外的分支结点称为内部结点</p><p><strong>孩子结点</strong>：结点的子树的根称为孩子</p><p><strong>双亲结点</strong>：孩子结点的前驱</p><p><img src="/posts/79666db/image-20241031154837095-1731069393911-27.png" alt="image-20241031154837095"></p><p>​       eg: BCD是A的孩子结点，A是bcd的双亲结点</p><p><strong>兄弟结点</strong>：同级的结点</p><p><strong>祖先结点</strong>：从根到该结点所经分支上的所有结点</p><p>​           eg: M的祖先结点为H,D,A</p><p><strong>子孙结点</strong>:从某结点为根的子树的任意结点</p><p>​          eg: D的孙子有HM</p><p><strong>树的深度</strong>：树中结点的最大层次</p><p><strong>有序树</strong>：树中的各子树从左至右有次序(最左边为第一个孩子)</p><p><strong>无序树</strong>：树中结点的各子树无次序</p><p><strong>森林</strong>：是m（m&gt;=0)棵互不相交的树的集合</p><p><img src="/posts/79666db/image-20241031160124987-1731069393911-28.png" alt="image-20241031160124987"></p><p>​              树一定是森林，森林不一定是树</p><h4 id="树结构和线性结构的比较">树结构和线性结构的比较</h4><p><img src="/posts/79666db/image-20241031160854242-1731069393911-29.png" alt="image-20241031160854242"></p><h3 id="2-二叉树的定义">2.二叉树的定义</h3><p><img src="/posts/79666db/image-20241031161122434-1731069393911-30.png" alt="image-20241031161122434"></p><h4 id="定义">定义</h4><p>​    二叉树是n(n&gt;=0)个结点的有限集，它或者是空集(n= 0),或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p><h4 id="特点-3">特点</h4><ol><li>每个结点最多有俩孩子(二叉树中不存在度大于2的结点)。</li><li>子树有左右之分，其次序不能颠倒。</li><li>二叉树可以是空集合，根可以有空的左子树或空的右子树。</li></ol><h4 id="树和二叉树区别"><strong>树和二叉树区别</strong></h4><ul><li>二叉树不是树的特殊情况，它们是两个概念</li><li>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也经行区分，说明它是左子树，还是右子树。</li><li>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</li><li>(也就是二叉树每个结点位置或者次序都是固定的，可以是空，但是个可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时.它就无所谓左右了)</li></ul><p><img src="/posts/79666db/image-20241031161802875-1731069393911-31.png" alt="image-20241031161802875"></p><p><img src="/posts/79666db/image-20241031161947956-1731069393911-32.png" alt="image-20241031161947956"></p><h3 id="3-案例引用">3.案例引用</h3><p><img src="/posts/79666db/image-20241031162420574-1731069393911-33.png" alt="image-20241031162420574"></p><h3 id="4-树和二叉树的抽象数据类型定义">4.树和二叉树的抽象数据类型定义</h3><p><img src="/posts/79666db/image-20241031162925621-1731069393911-34.png" alt="image-20241031162925621"></p><p><img src="/posts/79666db/image-20241031170614463-1731069393911-35.png" alt="image-20241031170614463"></p><h3 id="5-二叉树的性质和存储结构">5.二叉树的性质和存储结构</h3><h4 id="1-性质">1.性质</h4><h5 id="满二叉树与完全二叉树">满二叉树与完全二叉树</h5><p><strong>满二叉树</strong>：一颗深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>且有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点的二叉树就叫满二叉树</p><p><strong>完全二叉树</strong>：深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的具有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的二叉树，当且仅当每一个结点都与深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>的<strong>满二叉树</strong>中的<strong>编号</strong>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 1350 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mtext" transform="translate(500,0)"><path data-c="A0" d=""/></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的结点一一对应时，称为<strong>完全二叉树</strong>（叶子结点的编号是连续的,<strong>左侧树必须满元素</strong>)</p><ul><li>叶子只可能分布在层次最大的两层上，</li><li>对任意结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1</li></ul><p><img src="/posts/79666db/image-20241031204537868-1731069393911-36.png" alt="image-20241031204537868"></p><h6 id="性质1">性质1</h6><p>​      在二叉树的第i层上至多有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.915ex" height="1.887ex" role="img" focusable="false" viewbox="0 -833.9 1730.6 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>个结点</p><h6 id="性质2">性质2</h6><p>​     深度为k的二叉树至多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.049ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2673.8 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(1173.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2173.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点(k&gt;=1)</p><h6 id="性质3">性质3</h6><p>​      对任何一个二叉树<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.871ex" role="img" focusable="false" viewbox="0 -677 1020.6 827"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>,如果其叶子为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.375ex" role="img" focusable="false" viewbox="0 -442 1036.6 607.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>,度为2的结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.339ex" role="img" focusable="false" viewbox="0 -442 1036.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>，\则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="11.604ex" height="1.881ex" role="img" focusable="false" viewbox="0 -666 5129.1 831.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1314.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2370.1,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3628.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4629.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p><p><img src="/posts/79666db/image-20241031173605833-1731069393911-37.png" alt="image-20241031173605833"></p><p>​        eg:这里叶子结点7 8 9 10 11 12有6个,度为2的有1 2 3 4 5 有五个</p><p>总结点数n  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="20.578ex" height="1.846ex" role="img" focusable="false" viewbox="0 -666 9095.6 816"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(2970.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3542.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4264.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5264.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6301.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(6873.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7595.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(8595.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 又 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="16.941ex" height="1.694ex" role="img" focusable="false" viewbox="0 -583 7488.1 748.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1933.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3192.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4192.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(5451.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(6451.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container></p><p>总边个数B <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="9.989ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4415 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2092.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2914.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3915,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>  =  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="17.041ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 7532.1 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(1036.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2092.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mi" transform="translate(3129.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3701.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4423.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(5423.6,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mi" transform="translate(6460.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(7032.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p><h6 id="性质4">性质4</h6><p>具有n个结点的<strong>完全二叉树</strong>的深度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.239ex" role="img" focusable="false" viewbox="0 -694 3489.7 989.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1989.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2989.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p><h6 id="性质5">性质5</h6><p>如果有一颗<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个结点的<strong>完全二叉树(<strong>深度为 [<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>)的结点按层编号(从第1层到第[<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.669ex;" xmlns="http://www.w3.org/2000/svg" width="8.524ex" height="2.366ex" role="img" focusable="false" viewbox="0 -750 3767.7 1045.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="msubsup" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(510,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(510,-295.7) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1767.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(2267.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3267.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>层，每层从左到右)，对</strong>任一结点i</strong>(1&lt;=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>&lt;=n),有</p><ol><li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>=1，则结点i是二叉树的根，无双亲;如果i&gt;1，则其<strong>双亲是结点[i /2]。</strong></li><li>如果2<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="5.155ex" height="1.586ex" role="img" focusable="false" viewbox="0 -661 2278.6 701"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1678.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点i为叶子结点，无左孩子;否则，<br>其<strong>左孩子是结点2i。</strong></li><li>如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.183ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 4501 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2845.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(3901,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>无右孩子;否则，其<strong>右孩</strong><br><strong>子是结点2i + 1。</strong></li></ol><p><strong>总结</strong>: 编号为i，他的父结点为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.043ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1345 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(345,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(845,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>,左结点为2i，右节点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.809ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2567.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1067.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2067.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p><h4 id="2-存储结构">2.存储结构</h4><p><img src="/posts/79666db/image-20241031214118623-1731069393911-38.png" alt="image-20241031214118623"></p><h5 id="1-二叉树的顺序存储结构">1.二叉树的顺序存储结构</h5><ul><li><p>实现：按满二叉树的结点层次编号，依次存放在二叉树的数据元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> SqBiTree[MAXTSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241102133931076.png" alt="image-20241102133931076"></p></li><li><p>缺点： <img src="/posts/79666db/image-20241102134705813.png" alt="image-20241102134705813"></p><p>结点间的关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树</p></li></ul><h5 id="2-二叉树的链式存储结构">2.二叉树的链式存储结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchile</span>;</span><span class="comment">//左右孩子</span></span><br><span class="line">}BiNode,*BiTree;</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241102135937947.png" alt="image-20241102135937947"></p><p>在n个结点的二叉链表中，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个空指针域</p><p>必有2n个链域，除根节点外，每个结点有且仅有一个双亲，所有只会有n-1个结点的链域存放指针，指向非空子女结点</p><h5 id="3-三叉链表">3.三叉链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">Ichild</span>,*<span class="title">parent</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向双亲结点</span></span><br><span class="line">}TriTNode,*TriTree;</span><br></pre></td></tr></table></figure><h4 id="3-遍历二叉树和线索二叉树">3.遍历二叉树和线索二叉树</h4><h5 id="1-类型">1.类型</h5><p>先序遍历：根左右</p><p>中序遍历：左根右</p><p>后续遍历：左右根</p><p><img src="/posts/79666db/image-20241102144633249.png" alt="image-20241102144633249"></p><h6 id="先–根左右">先–根左右</h6><p><img src="/posts/79666db/image-20241102150119954.png" alt="image-20241102150119954"></p><p>ABELDHMIJ</p><h6 id="中–左根右">中–左根右</h6><p><img src="/posts/79666db/image-20241102150600713.png" alt="image-20241102150600713"></p><p>ELBAMHIDJ</p><h6 id="后–左右根">后–左右根</h6><p><img src="/posts/79666db/image-20241102151437701.png" alt="image-20241102151437701"></p><p>LEBMIHJDA</p><p>实例：<img src="/posts/79666db/6E50FE1F8569BEB2D29488718E198F13.png" alt="6E50FE1F8569BEB2D29488718E198F13"></p><p><img src="/posts/79666db/image-20241102154045025.png" alt="image-20241102154045025"></p><h5 id="2-根据遍历序列确定二叉树（先-中-后序）">2.根据遍历序列确定二叉树（先 中 后序）</h5><ul><li><p>若二叉树中的各结点均不相同，则二叉树结点的先徐序列、中序序列和后序序列都是唯一的</p></li><li><p>由二叉树的先序和中序序列，或由二叉树的后序和中序序列可以确定唯一一颗二叉树</p></li></ul><h6 id="实例1：先序-中序">实例1：先序+中序</h6><p>先：A B C D E F G H I</p><p>中：C D B F E A I H G J</p><p>解题思路</p><ol><li><p>由先知A必为根，B必为左   由中知 CDBFE在左部，IHGJ在右边</p><p><img src="/posts/79666db/image-20241102180223951.png" alt="image-20241102180223951"></p></li><li><p>由先序知道B为根，由中序知道CD为左子树，FE为右子树</p><p><img src="/posts/79666db/image-20241102180244711.png" alt="image-20241102180244711"></p></li><li><p>由先序知道G是根，那么I H为左子树，J为右子树</p><p><img src="/posts/79666db/image-20241102181222814.png" alt="image-20241102181222814"></p></li><li><p>由中序CD左根右知道，c为左，d为右，先序知道E为根，中序知道F为左</p><p><img src="/posts/79666db/image-20241102181439508.png" alt="image-20241102181439508"></p></li><li><p>由中序知道I为左子树</p><p><img src="/posts/79666db/image-20241102181539924.png" alt="image-20241102181539924"></p></li></ol><h6 id="实例2–中序-后续">实例2–中序+后续</h6><ol><li>中序序列:BDCEAFHG</li><li>后序序列:DECBHGFA</li><li>由中序后续知道根为A，BDCE为左根 FHG为右根</li><li>后序知道B为根，中序推出没有左根，c为下一个根</li><li>左右根D为左，E为右边</li><li>后序知道F为根</li><li>由中序知道F没有左，那么H为左，G为根</li></ol><p><img src="/posts/79666db/image-20241102183841772.png" alt="image-20241102183841772"></p><h5 id="3-遍历的算法实现-先序遍历">3.遍历的算法实现-先序遍历</h5><p><img src="/posts/79666db/image-20241102201045571.png" alt="image-20241102201045571"></p><h6 id="代码实现">代码实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);</span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="递归代码解释">递归代码解释</h6><ol><li><p>首先进入函数，此时T为传入的根结点</p></li><li><p>打印根节点</p></li><li><p>第一次调用：<strong>根左右</strong>函数指向根B</p></li><li><p>进入第二层循环 遍历左，左为空此时返回</p></li><li><p>回到第二层循环此时 PerOrderTraverse(T-&gt;lchild);为空，那么自动执行下一条语句PerOrderTraverse(T-&gt;rchile);</p></li><li><p>进入循环，执行到D</p></li><li><p>再向下执行为空返回到第一次循环</p></li><li><p>再执行C</p><p><img src="/posts/79666db/image-20241103142345827.png" alt="image-20241103142345827"></p></li></ol><p>(●ˇ∀ˇ●)明白了吗！</p><h5 id="4-遍历的算法实现-中序遍历">4.遍历的算法实现-中序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="5-历的算法实现-后序遍历">5.历的算法实现-后序遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">PerOrderTraverse</span><span class="params">(BiTree T)</span><span class="comment">//指向根节点的指针T</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>){</span><br><span class="line">       </span><br><span class="line">        PerOrderTraverse(T-&gt;lchild);</span><br><span class="line">         </span><br><span class="line">        PerOrderTraverse(T-&gt;rchile);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;data);<span class="comment">//可替换(访问根节点)</span></span><br><span class="line">        <span class="comment">// visit(T)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="6-二叉树遍历小总结">6.二叉树遍历小总结</h5><p><img src="/posts/79666db/image-20241103143731170.png" alt="image-20241103143731170"></p><p>时间复杂度O(n)//每个结点只访问一次</p><p>空间复杂度O(n)//栈占用的最大辅助空间</p><h5 id="7-中序遍历非递归算法-栈">7.中序遍历非递归算法-栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>{</span><br><span class="line">    BiTree P;</span><br><span class="line">    InitStack(S);<span class="comment">//初始化</span></span><br><span class="line">    P=T;</span><br><span class="line">    <span class="keyword">while</span> (p||StackEmpty(S))<span class="comment">//遇到的是根的时候</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(P)<span class="comment">//不为空</span></span><br><span class="line">        {</span><br><span class="line">            Push(S,p);<span class="comment">//入栈</span></span><br><span class="line">            p=p-&gt;Ichild;<span class="comment">//访问左子树</span></span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            Pop(S,q);<span class="comment">//出栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data);<span class="comment">//输出根</span></span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="8-二叉树的层次遍历">8.二叉树的层次遍历</h5><p><img src="/posts/79666db/image-20241103154648957.png" alt="image-20241103154648957"></p><p><img src="/posts/79666db/image-20241103154702890.png" alt="image-20241103154702890"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    BTNode data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rar;</span><br><span class="line">    </span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span></span><br><span class="line">{</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    initQueue(qu);<span class="comment">//初始化</span></span><br><span class="line">    enQuenue(qu,b);<span class="comment">//根节点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu)){<span class="comment">//队不为空则循环</span></span><br><span class="line">        deQueue(qu,p);<span class="comment">//出栈结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);访问结点p</span><br><span class="line">        <span class="title function_">if</span><span class="params">(p-&gt;Ichild!=<span class="literal">NULL</span>)</span><span class="title function_">enQueue</span><span class="params">(qu,p-&gt;Ichild)</span>;<span class="comment">//有左孩子时将其进队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)enqueue(qu,p-&gt;rchild);<span class="comment">//有右孩子时将其进队</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="9-二叉树遍历算法的应用">9.二叉树遍历算法的应用</h5><h6 id="1-二叉树的建立">1.二叉树的建立</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">"#"</span>) T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">if</span>(!(T=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))</span><br><span class="line">        <span class="built_in">exit</span>(OVRTFLOW);</span><br><span class="line">    T-&gt;data=ch;<span class="comment">//生成根节点</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;Ichild);<span class="comment">//构造左子树</span></span><br><span class="line"></span><br><span class="line">CreateBiTree(T-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}<span class="comment">//CreateBiTree</span></span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241103164836364.png" alt="image-20241103164836364"></p><h6 id="2-复制二叉树">2.复制二叉树</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T,BiTree &amp;newT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">        NewT=new BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line"></span><br><span class="line">        Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="3-计算二叉树的深度">3.计算二叉树的深度</h6><ul><li><p>如果是空树，则深度为0</p></li><li><p>否则，递归计算左子树的深度计为m，递归计算右子树的深度计为n，二叉树的深度则为m与n的较大者<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        m= Depth(T-&gt;lchild);</span><br><span class="line">        n= Depth(T-&gt;rchile);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-计算二叉树的结点总数">4.计算二叉树的结点总数</h6><ul><li>如果为空树则结点为0</li><li>否则，结点个数为左子树个数+右子树结点个数再+1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(Bitree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild)+ NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h6 id="5-计算叶子结点的个数">5.计算叶子结点的个数</h6><ul><li>如果是空树返回0</li><li>否则，为左子树的叶子结点+右子树的叶子结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BiTree T)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;T-&gt;rchile==<span class="literal">NULL</span>)<span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+leafCount(T-&gt;rchile);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="10-线索二叉树">10.线索二叉树</h5><ul><li>如果某个结点的左孩子为空，则将空的左孩子指针域改为<strong>指向其前驱</strong>；</li><li>如果某孩子的右结点为空，则将空的右孩子的指针域改为<strong>指向其后继</strong>；</li></ul><p><img src="/posts/79666db/image-20241104153725343.png" alt="image-20241104153725343"></p><p>这里是依照遍历来判断前驱后继，而不是图</p><h6 id="1-定义-4">1.定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span>{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;<span class="comment">//0表示是左/右孩子，1表示是前/后继</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241104155234167.png" alt="image-20241104155234167"></p><p><img src="/posts/79666db/image-20241104155240636.png" alt="image-20241104155240636"></p><p><img src="/posts/79666db/image-20241104155253366.png" alt="image-20241104155253366"></p><hr><h6 id="2-线索二叉树画法">2.线索二叉树画法</h6><p><img src="/posts/79666db/image-20241104155331910.png" alt="image-20241104155331910"></p><h6 id="3-遍历算法">3.遍历算法</h6><p>408不要求掌握</p><h5 id="11-李阳的交换左右子树">11.李阳的交换左右子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 李阳 on 2024/11/14.树的交换左右子树</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line"></span><br><span class="line">}TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode * <span class="title function_">creatNode</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * newNode=(TreeNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span>(!newNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"失败的树 "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    newNode-&gt;val=val;</span><br><span class="line">    newNode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换左右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swaplr</span><span class="params">(TreeNode * root)</span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode * temp=root-&gt;left;</span><br><span class="line">    root-&gt;left=root-&gt;right;</span><br><span class="line">    root-&gt;right=temp;</span><br><span class="line">    swaplr(root-&gt;left);<span class="comment">//交换左半树</span></span><br><span class="line">    swaplr(root-&gt;right);<span class="comment">//右半边树</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历打印二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode*root)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;val);</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    TreeNode * root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个简单的二叉树</span></span><br><span class="line">    <span class="comment">//       1</span></span><br><span class="line">    <span class="comment">//      / \</span></span><br><span class="line"><span class="comment">    //     2   3</span></span><br><span class="line">    <span class="comment">//    / \</span></span><br><span class="line"><span class="comment">    //   4   5</span></span><br><span class="line"></span><br><span class="line">    root= creatNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = creatNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = creatNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = creatNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = creatNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    swaplr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Pre-order traversal after swapping:\n"</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    freeTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-树和森林">6.树和森林</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">408要求</span><br><span class="line">2森林与二叉树的转换</span><br><span class="line">3树和森林的遍历</span><br></pre></td></tr></table></figure><h4 id="1-定义-5">1.定义</h4><p><strong>森林</strong>：是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.642ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5145.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1267,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2422.8,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mn" transform="translate(4256.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4756.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>棵互不相交的树的集合</p><h4 id="2-双亲表示法">2.双亲表示法</h4><ul><li><p><strong>实现</strong>：定义结构数组</p><p>​            存放树的结点</p><p>​             每个结点含两个域</p></li><li><p><strong>数据域</strong>：存放结点本身信息</p></li><li><p><strong>双亲域</strong>：指示本结点的双亲结点在数组中的位置</p></li></ul><p><img src="/posts/79666db/image-20241104162141056.png" alt="image-20241104162141056"></p><p><strong>特点</strong>：找双亲容易，找孩子难</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>{</span><span class="comment">//树的结点定义</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAXTSIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数,根节点位置</span></span><br><span class="line">}PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-孩子链表">3.孩子链表</h4><p>把每个结点的孩子结点排列起来，看成是一个线性表， 用单链表存储，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。</p><p><strong>解释</strong>：每个结点都有一个单链表，叶子节点的单链表是空表，然后再将这些链表的头指针存放在数组中</p><p><img src="/posts/79666db/image-20241104164756540.png" alt="image-20241104164756540"></p><p>孩子结点结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>{</span></span><br><span class="line">    <span class="type">int</span> child;<span class="comment">//整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span><span class="comment">//下一个孩子的地址</span></span><br><span class="line">}* ChildPrt;</span><br></pre></td></tr></table></figure><p>双亲结点结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    ChildPrt firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">}CTBox;</span><br></pre></td></tr></table></figure><p>树结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    CTBox nodes[MAXTSIZE];<span class="comment">//头指针数组</span></span><br><span class="line">    <span class="type">int</span> n,r;<span class="comment">//节点数和根节点位置下标</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>:找孩子容易，找双亲难</p><h4 id="4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）">4.*孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4><h5 id="1-定义-6">1.定义</h5><p><strong>实现</strong>：用二叉链表作树的存储结构，链表中的美观结点的指针域分别指向其<strong>第一个孩子节点</strong>和<strong>下一个兄弟节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>{</span></span><br><span class="line">    ELemtype data;<span class="comment">//元素类型 数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子，下一个兄弟</span></span><br><span class="line">}CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p>左孩子 右兄弟，是兄弟的就来砍我</p><p><img src="/posts/79666db/image-20241104171329061.png" alt="image-20241104171329061"></p><p>特点：找孩子，找兄弟简单，找双亲难</p><h4 id="5-树与二叉树的转换">5.*树与二叉树的转换</h4><h5 id="1-定义-7">1.定义</h5><ul><li>将树转化为二叉树，利用二叉树的算法实现对树的操作</li><li>由于树和二叉树都可以用二叉链表作存储结构，则以二叉树链表作媒介可以导出树与二叉树之间的对应关系</li></ul><p><img src="/posts/79666db/image-20241104173140758.png" alt="image-20241104173140758"></p><h5 id="2-操作">2.操作</h5><h6 id="1-将树转为二叉树">1.将树转为二叉树</h6><ol><li><p>加线:在兄弟之间加一连线</p></li><li><p>抹线:对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p></li><li><p>旋转:以树的根结点为轴心，将整树顺时针转45°</p></li></ol><p><img src="/posts/79666db/image-20241104173843558.png" alt="image-20241104173843558"></p><h6 id="2-将二叉树转为树">2.将二叉树转为树</h6><ol><li>加线:若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩…沿分支找到的所有右孩子，都与p的双亲用线连起来</li><li>抹线:抹掉原二叉树中双亲与右孩子之间的连线</li><li>调整:将结点按层次排列，形成树结构</li></ol><p><img src="/posts/79666db/image-20241104173926325.png" alt="image-20241104173926325"></p><h4 id="6-森林和二叉树的转换（二叉树与多棵树之间的关系">6.*森林和二叉树的转换（二叉树与多棵树之间的关系)</h4><h5 id="1-森林转化为二叉树">1.森林转化为二叉树</h5><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p></li></ol><p><img src="/posts/79666db/image-20241104180338598.png" alt="image-20241104180338598"></p><h5 id="2-二叉树转为森林">2.二叉树转为森林</h5><ol><li><p>抹线:将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二又树（去掉全部右孩线）</p></li><li><p>还原:将孤立的二又树还原成树（孤立二叉再还原)</p><p><img src="/posts/79666db/image-20241104181000820.png" alt="image-20241104181000820"></p></li></ol><h4 id="7-树与森林的遍历">7.树与森林的遍历</h4><h5 id="1-树的遍历的三种方式-先根（次序-，后根，层次遍历">1.树的遍历的三种方式{先根（次序)，后根，层次遍历}</h5><ul><li><p>先根遍历（次序）</p><p>​           若树不空，则先访问根结点，然后依次先根遍历各棵子树</p></li><li><p>后根遍历（次序）</p><p>​          若树不空，则先依次后根遍历各棵子树，然后访问根结点</p></li><li><p>层次遍历</p><p>​          若树不空，则至上而下自左至右访问树的每个结点</p></li></ul><p><img src="/posts/79666db/image-20241104182021725.png" alt="image-20241104182021725"></p><h5 id="2-森林的遍历">2.森林的遍历</h5><p>将森林看作3部分构成</p><ol><li>森林中第一棵树的根结点;</li><li>森林中第一棵树的子树森林，</li><li>森林中其它树构成的森林。</li></ol><h6 id="1-先序遍历">1.先序遍历</h6><p>若森林不空 则：</p><ol><li>访问森林中第一棵树的<strong>根结点;</strong></li><li><strong>先序遍历</strong>森林中第一棵树的子树森林;</li><li><strong>先序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</li></ol><p><img src="/posts/79666db/image-20241104182719934.png" alt="image-20241104182719934"></p><h6 id="2-中序遍历">2.中序遍历</h6><p>若森林不空，则</p><p>​    1.<strong>中序遍历</strong>森林中第一棵树的子树森林;</p><p>​     2.访问森林中第一棵树的<strong>根结点;</strong></p><p>​     3.<strong>中序遍历</strong>森林中(除第一棵树之外)其余树构成的森林。</p><p>对应：213</p><h6 id="3-小案例">3.小案例</h6><p><img src="/posts/79666db/image-20241104183504031.png" alt="image-20241104183504031"></p><h3 id="7-哈夫曼树及其应用">7.*哈夫曼树及其应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">408要求：</span><br><span class="line">1．哈夫曼（Huffman）树和哈夫曼编码</span><br><span class="line"></span><br><span class="line">2．并查集及其应用</span><br><span class="line"></span><br><span class="line">3．堆及其应用（25新增）</span><br></pre></td></tr></table></figure><h4 id="1-基本概念">1.基本概念</h4><p><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径</p><p><strong>结点路径的长度</strong>:两结点间的路径上的分支数</p><p><img src="/posts/79666db/image-20241107090341596.png" alt="image-20241107090341596"></p><p><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和，记作TL</p><p><img src="/posts/79666db/image-20241107090440851.png" alt="image-20241107090440851"></p><p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong></p><p><strong>结点的带权路径长度</strong>：从<strong>根节点</strong>到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p><p><strong>树的带权的路径长度</strong>：树中的所有<strong>叶子</strong>结点<strong>带权路径长度之和</strong>(WPL)</p><p><img src="/posts/79666db/image-20241107091528322.png" alt="image-20241107091528322"></p><p><strong>最优树</strong>：带权路径最短的树（最优树）度要相同</p><p><strong>最优二叉树</strong>：带权路径长度(WPL)最短的二叉树</p><p>满二叉树不一定是哈夫曼树</p><p>具有相同带权结点的哈夫曼树不唯一</p><p><strong>贪心算法</strong>：构造哈夫曼树时首先选择权最小的叶子结点</p><h4 id="2-哈夫曼算法">2.哈夫曼算法</h4><h5 id="1-构造方法">1.构造方法</h5><ol><li><p>根据<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个给定的权值<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="14.571ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 6440.4 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1380.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1825.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mn" transform="translate(977,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3205.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(3650.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="msub" transform="translate(4989.1,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>构成的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>棵二叉树的森林<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="16.839ex" height="1.977ex" role="img" focusable="false" viewbox="0 -680 7442.9 874"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mo" transform="translate(1026.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2082.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1020.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1465.2,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2485.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2930.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="msub" transform="translate(4269.1,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container>,其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.889ex" role="img" focusable="false" viewbox="0 -677 911 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>只有一个带权为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.875ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1271 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的根节点</p><p>​    构造森林全是根</p></li><li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</p><p>​           选用两小造新树</p></li><li><p>在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 749 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g></g></g></svg></mjx-container>中删除这两棵树，同时将新得到的二叉校加入森林中。·</p></li></ol><p>​             删除两小添新人</p><p>​    4. 重复2，3剩单根</p><p><img src="/posts/79666db/image-20241107094439746.png" alt="image-20241107094439746"></p><p><img src="/posts/79666db/image-20241107095725435.png" alt="image-20241107095725435"></p><h6 id="总结">总结</h6><ol><li>哈夫曼树的结点只有度为0或2的没有度为1的结点</li><li>包含n各叶子结点的哈夫曼树共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.386ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2822.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1322.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(2322.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>个结点</li><li>包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点</li><li>在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。</li><li>经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。</li><li>可见:哈夫曼树中共有n+n-1 = 2n-1个结点，且其所有的分支结点的度均不为1。</li></ol><h5 id="2-哈夫曼树的算法">2.哈夫曼树的算法</h5><h6 id="顺序结构（一维数组）">顺序结构（一维数组）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="type">int</span> parent,lch,rch;<span class="comment">//双亲，左孩子，右孩子</span></span><br><span class="line">}HTNode,*HUffmanTree;</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241107101801514.png" alt="image-20241107101801514"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span> <span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n)</span>{<span class="comment">//构造哈夫曼树——哈夫曼算法</span></span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;<span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT=new HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;++i){<span class="comment">//将2n-1个元素的Ich、rch、parent置为O</span></span><br><span class="line">    HT[i].lch=<span class="number">0</span>; HT[i].rch=<span class="number">0</span>; HT[i].parent=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;HT[i].weight;<span class="comment">//输入前n个元素的weight值</span></span><br><span class="line"><span class="comment">// 初始化结束，下面开始建立哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=n+<span class="number">1</span>;i&lt;=m; i++){<span class="comment">//合并产生n-1个结点——构造Huffman树</span></span><br><span class="line">     Select(HT, i<span class="number">-1</span>,s1,s2);<span class="comment">//在HT[k](1≤ksi-1)中选择两个其双亲域为0，</span></span><br><span class="line">                           <span class="comment">//且权值最小的结点,并返回它们在HT中的序号s1和s2</span></span><br><span class="line">HT[s1].parent=i; HT[s2] .parent=i;<span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">HT[i].llch=s1;HT[i].rch=s2;<span class="comment">//s1,s2分别作为i的左右孩子</span></span><br><span class="line">HT[i].weight=HT[s1].weight + HT[s2].weight;<span class="comment">//i的权值为左右孩子权值之和</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol><li>初始化HT[1…….2n-1]: lch=rch=parent=0</li><li>输入初始n个叶子结点:置HT[1…n]的weight值;</li><li>进行以下n-1次合并，依次产生n-1个结点HT[i], i=n+1…2n-1:</li></ol><ul><li>a)在HT[1…i-1]中选两个未被选过(从parent ==0的结点中选)的weight最小的两个结点HT[s1]和HT[s2], s1、s2为两个最小结点下标;</li><li>b)修改HT[s1]和HT[s2]的parent的值：HT[s1].parent=i;HT[s2].parent=i;</li><li>c)修改新产生的HT[i]:<br>.HT[i].weight=HT[s1].weight + HT[s2].weight;. HT[i]. Ich=s1; HT[i]. rch=s2;</li></ul><h4 id="3-哈夫曼编码">3.哈夫曼编码</h4><p>前缀编码：任意一字符不是另一个字符的前缀</p><h5 id="1-方法">1.方法</h5><p>1、统计字符集中每个字符在电文中出现的平均概率 (概率越大，<br>要求编码越短)。<br>2、利用哈夫曼树的特点:权越大的叶子离根越近;将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。<br>3、在哈夫曼树的每个分支上标上O或1:<br>结点的左分支标0，右分支标1<br>把从根到每个吐子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p><p><img src="/posts/79666db/image-20241107110159328.png" alt="image-20241107110159328"></p><p><img src="/posts/79666db/image-20241107112200535.png" alt="image-20241107112200535"></p><p>左分支标记0，右分支标记1</p><h6 id="问题">问题</h6><p>1.为什么哈夫曼编码能够保证是前缀编码?</p><p>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p><p>2.为什么哈夫曼编码能够保证字符编码总长最短?<br>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p><p><strong>性质</strong>1：哈夫曼编码是前缀编码</p><p><strong>性质</strong>2：哈夫曼编码是最优前缀码</p><h5 id="2-实现">2.实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp; HC, <span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line">    <span class="type">int</span> i,cd,start;</span><br><span class="line">    HC=new <span class="type">char</span> *[n+<span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line"></span><br><span class="line">    cd=new <span class="type">char</span> [n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line"></span><br><span class="line">    cd[n<span class="number">-1</span>]=<span class="string">'\0’;//编码结束符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for(i=1; i&lt;=n; ++i){//逐个字符求哈夫曼编码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    start=n-1; c=i; f=HT[i].parent;</span></span><br><span class="line"><span class="string">    while(f!=O){//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line"><span class="string">    --start;//回溯一次start向前指一个位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (HT[f].Ichild= =c) cd[start]= '</span>O<span class="number">'</span> ;<span class="comment">//结点c是f的左孩子，则生成代码O</span></span><br><span class="line">    <span class="keyword">else</span> cd[start]= <span class="string">'1'</span> ;<span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">    c=f; f=HT[f].parent;<span class="comment">//继续向上回溯</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//求出第i个字符的编码</span></span><br><span class="line">HC[i]= new <span class="type">char</span> [n-start];<span class="comment">//为第i个字符串编码分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(HC[i],&amp;cd[start]);<span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">delete cd;<span class="comment">//释放临时空间</span></span><br><span class="line"></span><br><span class="line">}<span class="comment">// CreatHuffanCode</span></span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241107135013070.png" alt="image-20241107135013070"></p><h4 id="4-编码的实现">4.编码的实现</h4><p><img src="/posts/79666db/image-20241107140225327.png" alt="image-20241107140225327"></p><p><img src="/posts/79666db/image-20241107140705475.png" alt="image-20241107140705475"></p><h2 id="八、图">八、图</h2><h3 id="1-图的定义和基本术语">1.图的定义和基本术语</h3><h4 id="1-图的定义">1.图的定义</h4><p><strong>图</strong>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3722.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><p>​         V:顶点（数据元素）的有穷非空集合</p><p>​         E:边的有穷集合</p><p><strong>无向图</strong>：每条边都没有方向</p><p><strong>有向图</strong>:每条边都有方向</p><p><img src="/posts/79666db/image-20241107141712274.png" alt="image-20241107141712274"></p><p><strong>完全图</strong>：任意两个点都有一条边相连</p><p><img src="/posts/79666db/image-20241107141847834.png" alt="image-20241107141847834"></p><p><strong>稀疏图</strong>：有很少边或弧的图（e&lt;nlogn)</p><p><strong>稠密图</strong>：有较多边或弧的图</p><p><strong>网</strong>：边/弧带权的图</p><p><strong>邻接</strong>:有边/弧相连的两个顶点之间的关系。</p><p>​       存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="6.547ex" height="2.363ex" role="img" focusable="false" viewbox="0 -750 2893.9 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1201,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1645.6,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(2504.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，则称<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>;互为<strong>邻接点</strong>;(无向图)</p><p>​存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="10.008ex" height="2.211ex" role="img" focusable="false" viewbox="0 -683 4423.5 977.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="msub" transform="translate(1055.8,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1965.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(2410.4,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(3645.5,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g></g></g></svg></mjx-container>，则称v<strong>邻接到</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container><strong>邻接于</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>(有向图)</p><p><strong>关联</strong>：边/弧与顶点的关系</p><p>​           存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="18.758ex" height="2.363ex" role="img" focusable="false" viewbox="0 -750 8291.2 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1299,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1743.6,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(2700.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3089.9,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mo" transform="translate(3867.7,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="msub" transform="translate(4923.5,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(5833.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(6278.1,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(7513.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g></g></g></svg></mjx-container>称为该边/弧关联于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewbox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container></p><p><strong>顶点的度</strong>:与该顶点相关联的边的数目，记为TD(v)</p><p>在有向图中，顶点的度等于该顶点的入度与出度之和。</p><p>顶点v的入度是以v为终点的有向边的条数,记作ID(v)</p><p>顶点v的出度是以v为始点的有向边的条数,记作OD(v)</p><p><img src="/posts/79666db/image-20241107142753964.png" alt="image-20241107142753964"></p><p><strong>路径</strong>：接续的边构成的顶点序列</p><p><strong>路径长度</strong>:路径上边或弧的数目/权值之和。<br><strong>回路(环)</strong>:第一个顶点和最后一个顶点相同的路径。<br><strong>简单路径</strong>:除路径起点和终点可以相同外，其余顶点均不相同的路径。</p><p><strong>简单回路(简单环)</strong>:除路径起点和终点相同外，其余顶点均不相同的路径。</p><p><img src="/posts/79666db/image-20241107144251328.png" alt="image-20241107144251328"></p><p><strong>连通图(强连通图)</strong><br>在无(有)向图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4875.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3722.2,0)"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>中，若对任何两个顶点v、u都右在从v至到u的路径称G是连通图(裾连通图)</p><p><img src="/posts/79666db/image-20241107144721137.png" alt="image-20241107144721137"></p><p><strong>权与网</strong><br>图中边或弧所具有的相关数称为<strong>权</strong>。表明从一个顶点到另一个顶点的距离或耗费。<br>带权的图称为<strong>网</strong>。</p><p><strong>子图</strong><br>设有两个图G= (V，{E})、G1= (V1，{E1})，若V1⊆V,E1⊆E,则称G1是G的子图</p><p><img src="/posts/79666db/image-20241107145900753-1730962741866-1.png" alt="image-20241107145900753"></p><p><strong>连通分量（强连通分量)</strong><br>无向图G的<strong>极大连通子图</strong>称为G的<strong>连通分量</strong>。<br>极大连通子图意思是:该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。</p><p><img src="/posts/79666db/image-20241107150554317.png" alt="image-20241107150554317"></p><p>有向图G的极大强连通子图称为G的<strong>强连通分量</strong></p><p>极大强连通子图意思是:该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p><p><img src="/posts/79666db/image-20241107150813934.png" alt="image-20241107150813934"></p><p>**极小连通子图:**该子图是G的连通子图，在该子图中删除任何一天边子图不再连通。<br>**生成树:**包含无向图G所有顶点的极小连通子图。<br>**生成森林:**对非连通图，由各个连通分量的生成树的集合。</p><p><img src="/posts/79666db/image-20241107151129261.png" alt="image-20241107151129261"></p><h3 id="2-图的类型定义">2.图的类型定义</h3><h4 id="1-图的抽象数据类型定义如下">1.图的抽象数据类型定义如下:</h4><p>ADT Graph{<br><strong>数据对象V</strong>:具有相同特性的数据元素的集合，称为<strong>顶点集。</strong><br><strong>数据关系R:</strong> R={VR}<br>VR={&lt;v,w&gt;|&lt;v,w&gt; | v,w⊆V ^ p(v,w),<br>&lt;v,w&gt;表示从v到w的弧，P(v,w)定义了弧&lt;v,w&gt;的信息</p><p>}</p><h4 id="2-图的操作">2. 图的操作</h4><p><img src="/posts/79666db/image-20241107152052212.png" alt="image-20241107152052212"></p><h4 id="3-图的存储结构">3.图的存储结构</h4><p><img src="/posts/79666db/image-20241107152459776.png" alt="image-20241107152459776"></p><h5 id="1-数组（邻接矩阵）表示法">1.数组（邻接矩阵）表示法</h5><p><img src="/posts/79666db/image-20241107152717210.png" alt="image-20241107152717210"></p><h6 id="无向图邻接矩阵">无向图邻接矩阵</h6><p><img src="/posts/79666db/image-20241107153625208.png" alt="image-20241107153625208"></p><p>分析1：无向图的邻接矩阵是对称的</p><p>分析2：顶点i的度=第i行（列）中的1的个数</p><p>特别：完全的邻接矩阵中，对角元素为0，其余为1</p><h6 id="有向图的邻接矩阵">有向图的邻接矩阵</h6><p><img src="/posts/79666db/image-20241107155521228.png" alt="image-20241107155521228"></p><p>分析1：有向图的邻接矩阵可能不是对称的</p><p>分析2：顶点的出度=第i行元素之和（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1019.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container> 指向&amp;V_2&amp; 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container>）</p><p>顶点的出度=第i列元素之和</p><p>​              顶点的度=第i行元素之和+第i列元素之和</p><h5 id="有向网的邻接矩阵">有向网的邻接矩阵</h5><p>网（即有权图)的邻接矩阵表示法</p><p>定义为</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.403ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9018 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1723.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2174.7,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(2607.7,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(3076.7,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3354.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3699.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3977.7,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(4255.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(4667.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(5223.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(6279.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(7550.2,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(8240,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g></g></g></svg></mjx-container>V_i<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="0.629ex" height="0.713ex" role="img" focusable="false" viewbox="0 -121 278 315"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2444.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1055.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">或</text></g><g data-mml-node="mo" transform="translate(2055.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g></g></g></svg></mjx-container>V_i,V_j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.951ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3072.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(666.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1544.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2313.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g></g></g></svg></mjx-container></p><p>​                  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"/></g></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">无</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">边</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">弧</text></g></g></g></svg></mjx-container></p><p>如果两个顶点之间存在弧或边，那么我就记录两个顶点为权<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="3.808ex" height="2.007ex" role="img" focusable="false" viewbox="0 -683 1683 887"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mi" transform="translate(1271,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>，如果不存在则记录无穷大</p><p><img src="/posts/79666db/image-20241109095058803.png" alt="image-20241109095058803"></p><h4 id="2-邻接矩阵的存储形式">2.邻接矩阵的存储形式</h4><h6 id="1-用两个数组分别存储顶点表和邻接矩阵">1.用两个数组分别存储顶点表和邻接矩阵</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//设顶点的娄文据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">VerTexType vexs[MVNum]; <span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前点数和边数</span></span><br><span class="line">}AMGraph; <span class="comment">// Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure><h5 id="2-采用邻接矩阵表示法创建无向网">2.采用邻接矩阵表示法创建无向网</h5><h6 id="算法思想">算法思想</h6><p>​    (1)输入总顶点数和总边数。</p><p>(2)依次输点的信息存人顶点表中。</p><p>（3）初始化邻接矩阵，使每个权值初始化为极大值。</p><p>（4）构造邻接矩阵</p><p>代码先欠着</p><h5 id="3-邻接矩阵的好处和坏处">3.邻接矩阵的好处和坏处</h5><h6 id="好处">好处</h6><ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有“邻接点”(有边直接相连的顶点)</li><li>方便计算任一顶点的“度”(从该点发出的边数为“出度”，指向该点的边数为“入度”)·无向图:对应行（或列)非O元素的个数·有向图:对应行非0元素的个数是“出度”;对应列非0元素的个数是“入度”</li></ul><h6 id="坏处">坏处</h6><ul><li><p>不便于增加和删除顶点</p></li><li><p>浪费空间——传稀疏图人点很多而边很少）有大量无效元素</p></li><li><p>​           对稠密图（特别是完全图)还是很合算的</p></li><li><p>浪费时间——统计稀疏图中一共有多少条边</p></li></ul><h4 id="3-邻接表表示法（链式）">3.邻接表表示法（链式）</h4><h5 id="1-无向图的邻接表">1.无向图的邻接表</h5><ul><li>·顶点:</li></ul><p>​             ·按编号顺序将顶点数据存储在一维数组中;·</p><ul><li><p>关联同一顶点的边(以顶点为尾的弧)︰</p><p>​      ·用线性链表存储</p></li></ul><p><img src="/posts/79666db/image-20241109105841878.png" alt="image-20241109105841878"></p><p>data表示顶点本身，firstarc表示第一条边的指针（以v1为例子，下标为3或为1的元素的指针）adjvex表示邻接的顶点，nextarc表示下一元素的指针</p><h6 id="特点-4">特点:</h6><ul><li>·邻接表不唯一</li><li>·若无向图中有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.054ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 466 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>条边，则其邻接表需<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个头结点和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container> 个表结点。适宜存储稀疏图。</li><li>无向图中顶点v的度为第i个单链表中的结点数。</li></ul><h5 id="2-有向图">2.有向图</h5><p><img src="/posts/79666db/image-20241109111503505.png" alt="image-20241109111503505"></p><h6 id="特点-5">特点:</h6><blockquote><p>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>出度</strong>为第i个单链表中的结点个数。<br>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>的<strong>入度</strong>为整个单链表中邻接点域值是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.677ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2067.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1567.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>的结点个数。</p></blockquote><p><img src="/posts/79666db/image-20241109112935783.png" alt="image-20241109112935783"></p><h5 id="3-链式代码">3.链式代码</h5><h6 id="1-定义代码">1.定义代码</h6><p>顶点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>{</span></span><br><span class="line">    </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息--类型自义定</span></span><br><span class="line">    ArcNode * firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">    </span><br><span class="line">}VNode,AdjList[MVNum]; <span class="comment">//AdjList表示邻接表类型,MVNUM为最大数组数</span></span><br></pre></td></tr></table></figure><p>边结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>{</span><span class="comment">//边结点</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">}ArcNode;</span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241109122123413.png" alt="image-20241109122123413"></p><p>图结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">     AdjList vertices;<span class="comment">//vertices--vertex的复数顶点数组</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">} ALGraph;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><img src="/posts/79666db/image-20241109123727673.png" alt="image-20241109123727673"></p><h6 id="2-采用邻接表表示法创建无向网的算法思想">2.采用邻接表表示法创建无向网的算法思想</h6><p>【算法思想】</p><ol><li>输入总顶点数和总边数。</li><li>建立顶点表<br>依次输入点的信息存入顶点表中<br>使每个表头结点的指针域初始化为NULL</li><li>创建邻接表<br>依次输入每条边依附的两个顶点确定两个顶点的序号i和j，建立边结点<br>将此边结点分别插入到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="2.166ex" height="2.211ex" role="img" focusable="false" viewbox="0 -683 957.3 977.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></svg></mjx-container>对应的两个边链表的头部</li></ol><h4 id="5-邻接表的特点">5.邻接表的特点</h4><h5 id="1-特点">1.特点</h5><ul><li><p>·方便找任一顶点的所有“邻接点”</p></li><li><p>·节约稀疏图的空间</p><p>​    需要N个头指针＋2E个结点(每个结点至少2个域)·</p></li><li><p>方便计算任一顶点的“度”?<br>对无向图:是的</p><p>对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算入度”</p></li><li><p>·不方便检查任意、对顶点间是否存在边</p></li></ul><h4 id="4-邻接矩阵与邻接表表示方法的关系">4.邻接矩阵与邻接表表示方法的关系</h4><p><img src="/posts/79666db/image-20241109131228879.png" alt="image-20241109131228879"></p><h5 id="2-联系">2.<strong>联系:</strong></h5><p>邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p><h5 id="2-区别">2.区别:</h5><p>对于任一确定的无向图，邻接矩阵是唯一的(行列号与顶点编号一致)，但邻接表不唯一（链接次序与顶点编号无关）。</p><p>邻接矩阵的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>,而邻接表的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><h5 id="3-用途">3.用途:</h5><p>邻接矩阵多用于榈密图;而邻接表多用于稀疏图</p><h4 id="5-十字链表">5.十字链表</h4><p><img src="/posts/79666db/image-20241109132236978.png" alt="image-20241109132236978"></p><h5 id="1-简介">1.简介</h5><p><strong>十字链表</strong>(Orthogonal List)是<strong>有向图</strong>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。<br>有向图中的每一条弧对应十字链表中的一个<strong>弧结点</strong>，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做<strong>顶点结点。</strong></p><h5 id="2-具体">2.具体</h5><p>data:数据</p><p>firstin:第一个入度边</p><p>firstout:第一个出度边</p><p>tailvex:弧尾位置</p><p>headvex:弧头位置</p><p>hlink:弧头相同的下一条弧</p><p>tlink:弧尾相同的下一条弧</p><p><img src="/posts/79666db/image-20241109134222311.png" alt="image-20241109134222311"></p><h4 id="6-邻接多重表">6.邻接多重表</h4><p><img src="/posts/79666db/image-20241109144018754.png" alt="image-20241109144018754"></p><p><img src="/posts/79666db/image-20241109144858776.png" alt="image-20241109144858776"></p><h3 id="4-图的遍历">4.图的遍历</h3><h4 id="1-定义-8">1.定义</h4><p><strong>遍历定义:</strong></p><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做<strong>图的遍历</strong>，它是图的基本运算</p><p><strong>遍历实质</strong>:找每个顶点的邻接点的过程。</p><p><strong>图的特点</strong>:<br>图中可能存在<strong>回路</strong>，且图的任一顶点都可能与其它顶点相通在访问完某个顶点之后可能会沿着某些边<strong>又回到了曾经访问过的顶点。</strong></p><p><strong>如何避免回路</strong>:</p><p>解决思路:设置<strong>辅助数组</strong><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.382ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4147 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3869,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，用来标记每个被访问过的顶点。</p><ul><li>初始状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为0</li><li>·顶点i被访问，改<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.805ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3892 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1299,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1644,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(2005,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(2471,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2991,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(3269,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>为1，防止被多次访问</li></ul><h4 id="2-深度优先-DFS">2.深度优先(DFS)</h4><h5 id="1-连通图的遍历">1.连通图的遍历</h5><h6 id="方法">方法:</h6><ul><li>在访问图中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1</li><li>再从w出发，访问与w邻接但还未被访问过的顶点W2;</li><li>然后再从w出发，进行类似的访问，…</li><li>如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。</li><li>如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;</li><li>如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</li></ul><p><img src="/posts/79666db/image-20241109151227573.png" alt="image-20241109151227573"></p><h6 id="实现">实现</h6><p><img src="/posts/79666db/image-20241109154118743.png" alt="image-20241109154118743"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span><span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line">   <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G;v++)</span><br><span class="line">   {</span><br><span class="line">       visited[v]=<span class="literal">false</span>;<span class="comment">//初始化已访问数组</span></span><br><span class="line">       <span class="keyword">for</span> ( v = <span class="number">0</span>; v &lt; G; ++v) {<span class="comment">//从v0开始遍历</span></span><br><span class="line">           <span class="keyword">if</span>(!visited[v])</span><br><span class="line">           {</span><br><span class="line">               DFS(G,v);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Grap G,<span class="type">int</span> V)</span><span class="comment">//从顶点v出发，深度遍历图G</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    visit(v);<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))<span class="comment">//依次检查邻接矩阵v所在的行 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])<span class="comment">//w为v还没访问的邻接顶点</span></span><br><span class="line">        {</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="效率分析">效率分析</h6><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2577.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>用邻接表来表示图，虽然有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.186ex" height="1.532ex" role="img" focusable="false" viewbox="0 -666 966 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>.</p><h6 id="结论"><strong>结论</strong>:</h6><ul><li><strong>稠密图</strong>适于在邻接矩阵上进行深度遍历;</li><li><strong>稀疏图</strong>通于在邻接表上进行深度遍历。</li></ul><h4 id="2-广度优先遍历">2.广度优先遍历</h4><h5 id="1-方法-2">1.方法</h5><p>方法:从图的某一结点出发，首先依次访问该结点的所有邻接点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="13.127ex" height="1.984ex" role="img" focusable="false" viewbox="0 -683 5802 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1019.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1464.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2483.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2928.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(4267.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(4711.8,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>,再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点<br>重复此过程，直至所有顶点均被访问为止。</p><p><img src="/posts/79666db/image-20241110090045314.png" alt="image-20241110090045314"></p><h5 id="2-实现-2">2.实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//王道代码</span></span><br><span class="line"><span class="type">bool</span> visited [Max_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Grap G)</span>{<span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) {</span><br><span class="line">        visited[i]=<span class="literal">false</span>;<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    }</span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;G.vexnum ; ++i) {<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i]){<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>{<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;<span class="comment">//对v做以访问标志</span></span><br><span class="line">    Enqueue(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)){</span><br><span class="line">        DeQueue(Q,v);<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = FirstNeighbor(G,v); w&gt;<span class="number">0</span> ; w=NextNeighbor(G,v,w)) {</span><br><span class="line">                                           <span class="comment">//检测到v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w]){<span class="comment">//w为v未访问的邻接顶点</span></span><br><span class="line">                visit(w);<span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;<span class="comment">//对w做以访问标记</span></span><br><span class="line">                Enqueue(Q,w);<span class="comment">//顶点w入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-效率分析">3.效率分析</h5><ul><li>如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要<br>循环检测矩阵中的整整一行（ n个元素)，总的时间代价为O(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.345ex" height="1.912ex" role="img" focusable="false" viewbox="0 -833.9 1036.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>)。</li><li>用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</li></ul><h5 id="4-效率比较">4.效率比较</h5><ul><li>·空间复杂度相同，都是O(n)(借用了堆栈或队列) ;</li><li>·时间复杂度只与存储结构,(邻接矩阵或邻接表)有关，而与搜索路径无关。</li></ul><h3 id="5-图的应用">5.图的应用</h3><h4 id="1-最小生成树">1.最小生成树</h4><h5 id="1-生成树的简介">1.生成树的简介</h5><p><strong>生成树</strong>：所有顶点均由边连接在一起，但不存在回路</p><p><img src="/posts/79666db/image-20241110095716787.png" alt="image-20241110095716787"></p><blockquote><p>一个图可以有许多棵不同的生成树</p><p>所有生成树具有以下共同特点</p><ul><li>生成树的顶点个数与图的<strong>顶点个数相同;</strong></li><li>生成树是图的<strong>极小连通子图</strong>，去掉一条边则非连通;·</li><li>一个有n个顶点的连通图的生成树有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>条边;</li><li><strong>·在生成树中再加一条边必然形成回路。</strong></li><li>生成树中任意两个顶点间的<strong>路径是唯一</strong>的;</li></ul><p>含有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个顶点 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewbox="0 -666 2322.4 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1822.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>条边的图不一定是最小生成树</p><p><img src="/posts/79666db/image-20241110095828535.png" alt="image-20241110095828535"></p></blockquote><h5 id="2-无向图的生成树">2.无向图的生成树</h5><p><img src="/posts/79666db/image-20241110100335510.png" alt="image-20241110100335510"></p><h5 id="3-最小生成树">3.最小生成树</h5><p><strong>最小生成树</strong>:给定一个无向网络在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。</p><p><img src="/posts/79666db/image-20241110100803730.png" alt="image-20241110100803730"></p><h6 id="构造最小生成树">构造最小生成树</h6><p>构造最小生成树的算法很多，其中多数算法都利用了<strong>MST</strong>的性质。</p><p><strong>MST性质</strong>:设N =(V, E)是一个连通网,U是顶点集V的一个非空子集。若边(u, v)是一条具有最小权值的边，其中u∈u,v∈V-U,则必存<br>在一棵包含边(u, v)的最小生成树。</p><h6 id="Prim-普里姆算法">Prim-普里姆算法</h6><p>算法思想</p><blockquote><p>设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.229ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4963.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(4574.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>是连通网，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>是N上最小生成树中边的集合。</p><p>初 始 令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="7.01ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 3098.5 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2100.6,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.025ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3989.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1675.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(2553.1,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3322.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(3711.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>TE=${ }。</p><p>在所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="5.644ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 2494.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(849.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1727.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="9.952ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 4399 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(762.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(1640.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(2631.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3632,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g></g></g></svg></mjx-container>的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.501ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4199.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mo" transform="translate(1890.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2557.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">∊</text></g><g data-mml-node="mi" transform="translate(3435.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>中，找一条代价最小的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>并入集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.538ex" role="img" focusable="false" viewbox="0 -680 1468 680"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g></g></g></svg></mjx-container>，同时<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>并入U</p><p>重复上述操作直至<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.492ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 2869.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2100.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g></g></g></svg></mjx-container>，则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.437ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5497.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3640.2,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(4344.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(5108.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g></g></g></svg></mjx-container>的最小生成树。</p></blockquote><p>从顶点往下找最小的权</p><h6 id="Kruskal-克鲁斯卡尔算法">Kruskal-克鲁斯卡尔算法</h6><p>所有边按权值排序,然后选择最小的</p><p>当有循环时舍弃这条边</p><p>当所有边连通时结束</p><p>与prim算法不同的是他是按排序来找最小,prim是依次选最小</p><blockquote><p>设连通网<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.261ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4977.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2221.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2610.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3379.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3824.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mo" transform="translate(4588.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，令最小生D树初始状态为只有n个顶点而无边的非连通图<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.116ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4029.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(981.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2037.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2426.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mo" transform="translate(3195.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3640.2,0)"/><g data-mml-node="mo" transform="translate(3640.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>,每个顶点自成一个连通分量。</p><p>在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即:不能形成环)，则将此边加入到T中;否则，舍去此边，选取下一条代价最小的边。</p><p>依此类推，直至T中所有顶点都在同一连通分量上为止。</p></blockquote><p>最小生成树可能不唯一</p><h6 id="两种比较">两种比较</h6><p><img src="/posts/79666db/image-20241110111651349.png" alt="image-20241110111651349"></p><h4 id="2-最短路径">2.最短路径</h4><h5 id="1-定义-9">1.定义</h5><p><strong>最短路径与最小生成树不同</strong>，路径上不一定包含n个顶点，也不一定包含n-1条边。</p><p>单源最短路径-Dijkstra迪杰斯特拉算法</p><p><img src="/posts/79666db/image-20241110112448263.png" alt="image-20241110112448263"></p><p>所有顶点间的最短路径–Floyd弗洛伊德算法</p><p><img src="/posts/79666db/image-20241110112715538-1731209239025-1.png" alt="image-20241110112715538"></p><h5 id="2-Dijkstra算法">2.Dijkstra算法</h5><h6 id="概述">概述</h6><blockquote><p>1.初始化:先找出从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到各终点v的直达路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.413ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3276.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1408.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1853.2,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2887.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, 即通过一条弧到达的路径。</p><p>2选择:从这些路径中找出一条长度最短的路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.121ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2705.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>3.更新:然后对其余各条路径进行适当调整:</p><p>​          若在图中存在弧<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.401ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2829.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1405.7,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(2440.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> ，且<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="25.029ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11062.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2316.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2927.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(3928.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4317.1,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4889.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(5333.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(6270.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6936.9,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mo" transform="translate(7992.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(8381.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(9292.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(9737.3,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(10673.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>则以路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.689ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4282.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1397.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1842.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2414.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(2859.3,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><g data-mml-node="mo" transform="translate(3893.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>代替<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.348ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3247.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g><g data-mml-node="mo" transform="translate(1299.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1744.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(2513.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2858.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>在调整后的各条路径中，再找长度最短的路径)依此类推。</p><p>(先找出直达的,然后与不直达的比较,有小的就更新被比较的)</p></blockquote><h6 id="具体-按路径长度递增次序产生最短路径">具体-按路径长度递增次序产生最短路径</h6><blockquote><p>1、把V分成两组:辅助数组D存放。<br>(1) S:已求出最短路径的顶点的集合。<br>(2)T=V -s∶尚未确定最短路径的顶点集合。</p><p>2、将T中顶点按最短路径递增的次序加入到S中，</p><p>保证:(1）从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到S中各顶点的最短路径长度都不大于从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.307ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1019.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mn" transform="translate(616,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>到T中任何顶点的最短路径长度。</p><p>(2)每个顶点对应一个距离值:<br>S中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的最短路径长度。</p><p>​T中顶点:从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.061ex" height="1.359ex" role="img" focusable="false" viewbox="0 -443 910.9 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g></g></g></g></svg></mjx-container>到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p></blockquote><p><img src="/posts/79666db/image-20241110143716951.png" alt="image-20241110143716951"></p><h5 id="3-Floyd-弗洛伊德算法">3.Floyd 弗洛伊德算法</h5><h6 id="算法思想-2">算法思想</h6><ul><li>·逐个顶点试探</li><li>·从到v,的所有可能存在的路径中·</li><li>选出一条长度最短的路径</li></ul><p><img src="/posts/79666db/image-20241110151313801.png" alt="image-20241110151313801"></p><h4 id="3-拓扑排序">3.拓扑排序</h4><p>有向无环图：无环的有向图，简称DAG</p><p><img src="/posts/79666db/image-20241110151722949.png" alt="image-20241110151722949"></p><p>一个结点可能有多个前驱，但是没有回路</p><h5 id="1-AOV网">1.AOV网</h5><h6 id="定义-2">定义</h6><p>用一个有向图表示一个工程的各子工程及其相冥制约的关系，其中<strong>以顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网(Activity On Vertex network)</p><h6 id="特点-6">特点</h6><ul><li>若从i到j有一条有向路径，则i是j的前驱;j是i的后继。</li><li>若&lt;i,j &gt;是网中有向边，则i是j的直接前驱;j是i的直接后继</li><li>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</li></ul><h6 id="检测AOV-网中是否存在环方法">检测AOV 网中是否存在环方法:</h6><p>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV 网必定不存在环。</p><h5 id="2-AOE网">2.AOE网</h5><p>用一个有向图表承一个工程的各子工程及其相互制约的关系,以<strong>弧表示活动</strong>，以<strong>顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网(Activity On Edge)。</p><h5 id="3-拓扑排序-2">3.拓扑排序</h5><p>在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧&lt;i,j&gt;存在，则在这个序列甲，I一疋排仕J的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序。</strong></p><p><img src="/posts/79666db/image-20241110160144846-1731225709478-3.png" alt="image-20241110160144846"></p><h4 id="4-关键路径">4.关键路径</h4><p><img src="/posts/79666db/image-20241110165246291.png" alt="image-20241110165246291"></p><p>对于AOE网，我们关心两个问题:</p><p>(1)完成整项工程至少需要多少时间?</p><p>(2)哪些活动是影响工程进度的关键?</p><p>关键路径 ：路径长度最长的路径。<br>路径长度：路径上各活动持续时间之和。</p><p>------&gt;求解关键路径问题</p><p><img src="/posts/79666db/image-20241110171020097.png" alt="image-20241110171020097"></p><p>由若干个关键活动组成的就是关键路径</p><p><img src="/posts/79666db/image-20241110171553903.png" alt="image-20241110171553903"></p><p>ve(j)最早开始时间：从原点开始找到权的最大值</p><p>vl(n)最迟发生时间：从汇点向前，找到最小值</p><p><img src="/posts/79666db/image-20241110172431466-1731230673854-5.png" alt="image-20241110172431466"></p><p>具体计算</p><p><img src="/posts/79666db/image-20241110173552506-1731231354674-9.png" alt="image-20241110173552506"></p><p>e(i)就是弧尾的长度</p><p>​        eg: v5就是6（v5连接的是v2，只用算v2），</p><p>l(i)就是vl-路径上的权值</p><p>​       eg: v5就是7-a4的权=7-1=6</p><p><img src="/posts/79666db/image-20241110174727136.png" alt="image-20241110174727136"></p><h5 id="讨论">讨论</h5><p>1、若网中有几条关键路径,则需加快同时在几条关键路径上的关键活动。<br>如: a11、a10、a8、a7。</p><p>2、如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。如: a1、a4。</p><p>3、处于所有的关键路径上的活动完成时间不能缩短太多)，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。</p><p>​         如:a1由6天变成3天，就会改变关键路径。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;C语言–数据结构&lt;/h1&gt;
&lt;p&gt;---------------------------------------内容参考《郝斌数据结构》，《王道》《王卓》&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://lyay23.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://lyay23.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java尚硅谷笔记</title>
    <link href="http://lyay23.github.io/posts/c7b053e8/"/>
    <id>http://lyay23.github.io/posts/c7b053e8/</id>
    <published>2024-11-05T13:34:21.000Z</published>
    <updated>2024-11-05T13:37:48.072Z</updated>
    
    <content type="html"><![CDATA[<h1>Java 基础 第 1 阶段：基本语法——尚硅谷学习笔记（含面试题） 2023 年</h1><h1>第 1 章 Java 语言概述</h1><span id="more"></span><h2 id="1-1-Java-基础阶段的学习内容">1.1 Java 基础阶段的学习内容</h2><h3 id="1-1-1-第-1-阶段：Java-基本语法">1.1.1 第 1 阶段：Java 基本语法</h3><p>Java 概述、关键字、标识符、变量、运算符、流程控制（条件判断、选择结构、循环结构）、IDEA、数组。</p><h3 id="1-1-2-第-2-阶段：Java-面向对象编程">1.1.2 第 2 阶段：Java 面向对象编程</h3><ul><li>类及类的内部成员。</li><li>面向对象的三大特征 ：封装、继承、多态。</li><li>其它关键字的使用。</li></ul><h3 id="1-1-3-第-3-阶段：Java-语言的高级应用">1.1.3 第 3 阶段：Java 语言的高级应用</h3><p>异常处理、多线程、IO 流、集合框架、反射、网络编程、新特性、其它常用的 API 等。</p><blockquote><p>书籍推荐：《Java 核心技术》、《Effective Java》、《Java 编程思想》。</p></blockquote><h2 id="1-2-软件开发相关内容">1.2 软件开发相关内容</h2><h3 id="1-2-1-计算机的构成">1.2.1 计算机的构成</h3><p>硬件 + 软件。</p><h3 id="1-2-2-软件">1.2.2 软件</h3><p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。</p><ul><li>系统软件，即操作系统，Windows、Mac OS 、Linux、Android、ios。</li><li>应用软件，即 OS 之上的应用程序。</li></ul><h3 id="1-2-3-人机交互方式">1.2.3 人机交互方式</h3><ul><li>图形化界面（Graphical User Interface，GUI）。</li><li>命令行交互方式（Command Line Interface，CLI）。</li></ul><p>熟悉常用的 DOS（Disk Operating System，磁盘操作系统）命令：</p><ul><li><em>进入和回退</em><ul><li><em>盘符名称:</em><br>盘符切换。E:回车，表示切换到 E 盘。</li><li><em>dir</em><br>列出当前目录下的文件以及文件夹。</li><li><em>cd 目录</em><br>进入指定目录。</li><li><em>cd …</em><br>回退到上一级目录。</li><li><em>cd \ 或 cd /</em><br>回退到盘符目录。</li></ul></li><li><em>增、删</em><ul><li><em>md 文件目录名</em><br>创建指定的文件目录。</li><li><em>rd 文件目录名</em><br>删除指定的文件目录（如文件目录内有数据，删除失败）。</li></ul></li><li><em>其它</em><ul><li><em>cls</em><br>清屏。</li><li><em>exit</em><br>退出命令提示符窗口。</li><li><em>↑ ↓</em><br>调阅历史操作命令。</li></ul></li></ul><h3 id="1-2-4-计算机编程语言">1.2.4 计算机编程语言</h3><ul><li>语言的分代：<ul><li>第 1 代：机器语言</li><li>第 2 代：汇编语言</li><li>第 3 代：高级语言</li></ul></li><li>面向过程的语言：C</li><li>面向对象的语言：C++、Java、C#、Python、Go、JavaScript</li></ul><p>没有“最好”的语言，只有在特定场景下相对来说，最适合的语言而已。</p><h2 id="1-3-Java-概述">1.3 Java 概述</h2><h3 id="1-3-1-Java-发展史">1.3.1 Java 发展史</h3><ul><li>几个重要的版本：1996 年，发布 JDK1.0<ul><li>里程碑式的版本：JDK5.0、JDK8.0（2014 年发布）</li><li>JDK11（LTS）、JDK17（LTS）long term support</li></ul></li></ul><h3 id="1-3-2-Java-之父">1.3.2 Java 之父</h3><p>詹姆斯·高斯林</p><h3 id="1-3-3-Java-具体的平台划分">1.3.3 Java 具体的平台划分</h3><ul><li>J2SE ——&gt; JavaSE（Java Standard Edition）标准版</li><li>J2EE ——&gt; JavaEE（Java Enterprise Edition）企业版</li><li>J2ME ——&gt; JavaME（Java Micro Edition）小型版</li></ul><p>Java 目前主要的应用场景：JavaEE 后端开发、Android 客户端的开发、大数据开发。</p><p><img src="https://img-blog.csdnimg.cn/a2a157b0064b4410bbdbd9302af64375.png" alt="Java 应用场景"></p><h2 id="1-4-Java-环境的搭建">1.4. Java 环境的搭建</h2><h3 id="1-4-1-JDK、JRE、JVM-的基本概念">1.4.1 JDK、JRE、JVM 的基本概念</h3><ul><li>JDK（Java Development Kit）：是 Java 程序开发工具包，包含 JRE 和开发人员使用的工具。</li><li>JRE（Java Runtime Environment） ：是 Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库。</li><li>Java 虚拟机（Java Virtual Machine 简称 JVM）是运行所有 Java 程序的抽象计算机，是 Java 语言的运行环境，它是 Java 最具吸引力的特性之一。</li></ul><h3 id="1-4-2-JDK、JRE、JVM-三者之间的关系">1.4.2 JDK、JRE、JVM 三者之间的关系</h3><ul><li><p>JDK = JRE + 开发工具集（例如 Javac 编译工具等）。</p></li><li><p>JRE = JVM + Java SE 标准类库。</p><p><img src="https://img-blog.csdnimg.cn/7fb09b95dabf42aa8086d6b8839f66e1.png" alt="JDK、JRE、JVM之间的关系"></p></li></ul><h3 id="1-4-3-安装-JDK">1.4.3 安装 JDK</h3><ul><li>JDK 的下载：<a href="https://www.oracle.com">Oracle 官网</a>（<a href="https://www.oracle.com">https://www.oracle.com</a>）</li><li>JDK 的安装：<br>安装 jdk11 和 jdk17。</li><li>环境变量的配置：<br>配置 JAVA_HOME + path。</li></ul><h2 id="1-5-HelloWorld">1.5. HelloWorld</h2><h3 id="1-5-1-开发步骤">1.5.1 开发步骤</h3><p>Java 程序开发三步骤：编写、编译、运行。</p><ul><li>将 Java 代码编写到扩展名为 .java 的源文件中。</li><li>通过 javac.exe 命令对该 java 文件进行编译，生成一个或多个字节码文件。格式：javac 源文件名.java</li><li>通过 java.exe 命令对生成的 class 文件进行运行。格式： java 字节码文件名</li></ul><p><img src="https://img-blog.csdnimg.cn/1f04469993cf426780705f0d4443b251.png" alt="Java 程序开发步骤"></p><h3 id="1-5-2-开发说明">1.5.2 开发说明</h3><ul><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类</span><br><span class="line">{</span><br><span class="line">    方法</span><br><span class="line">    {</span><br><span class="line">        语句;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.java</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>说明：<br>① class：关键字，表示“类”，后面跟着类名。<br>② main() 方法的格式是固定的。表示程序的入口。<br>③ Java 程序，是严格区分大小写的。<br>④ 从控制台输出数据的操作：<br>System.out.println() : 输出数据之后，会换行。<br>System.out.print() : 输出数据之后，不会换行。<br>⑤ 每一行执行语句必须以;结束。<br>⑥ 编译以后，会生成 1 个或多个字节码文件。每一个字节码文件对应一个 Java 类，并且字节码文件名与类名相同。<br>⑦ 我们是针对于字节码文件对应的 Java 类进行解释运行的。<br>⑧ 一个源文件中可以声明多个类，但是最多只能有一个类使用 public 进行声明，且要求声明为 public 的类的类名与源文件名相同。</p></li></ul><h2 id="1-6-注释">1.6 注释</h2><p>源文件中用于解释、说明程序的文字就是注释。</p><h3 id="1-6-1-Java-中的注释的种类">1.6.1 Java 中的注释的种类</h3><p>单行注释、多行注释、文档注释（Java 特有）。</p><h3 id="1-6-2-单行注释">1.6.2 单行注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释。</span></span><br></pre></td></tr></table></figure><h3 id="1-6-3-多行注释">1.6.3 多行注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是多行注释。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="1-6-4-文档注释">1.6.4 文档注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> <span class="doctag">@author</span> 指定 Java 程序的作者</span></span><br><span class="line"><span class="comment"> <span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>文档注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p><h2 id="1-7-API-文档">1.7 API 文档</h2><p>API （Application Programming Interface，应用程序编程接口）是 Java 提供的基本编程接口。</p><p>Java 语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的说明文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。</p><p>Java API 文档，即为 JDK 使用说明书、帮助文档。</p><h2 id="1-8-Java-核心机制：JVM">1.8 Java 核心机制：JVM</h2><h3 id="1-8-1-Java-语言的优点">1.8.1 Java 语言的优点</h3><ul><li>跨平台性：<ul><li>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个 Java 虚拟机(JVM ，Java Virtual Machine) 即可，由 JVM 来负责 Java 程序在该系统中的运行。</li></ul></li><li>面向对象性：<br>面向对象是一种程序设计技术，非常适合大型软件的设计和开发。面向对象编程支持封装、继承、多态等特性，让程序更好达到高内聚，低耦合的标准。</li><li>健壮性：<br>吸收了 C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。<ul><li>安全性高：<br>Java 适合于网络/分布式环境，需要提供一个安全机制以防恶意代码的攻击。如：安全防范机制（ClassLoader 类加载器），可以分配不同的命空间以防替代本地的同名类、字节代码检查。</li></ul></li><li>简单性：<br>Java 就是 C++ 语法的简化版，我们也可以将 Java 称之为“C++ - -”。比如：头文件，指针运算，结构，联合，操作符重载，虚基类等。<ul><li>高性能：<br>Java 最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java 语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过 JIT(JUST IN TIME)即时编译技术提高运行效率。</li></ul></li></ul><h3 id="1-8-2-Java-语言的缺点">1.8.2 Java 语言的缺点</h3><ul><li>语法过于复杂、严谨，对程序员的约束比较多，与 python、php 等相比入门较难。</li><li>一般适用于大型网站开发，整个架构会比较重，对于初创公司开发和维护人员的成本比较高。</li><li>并非适用于所有领域。比如，Objective C、Swift 在 iOS 设备上就有着无可取代的地位；浏览器中的处理几乎完全由 JavaScript 掌控；Windows 程序通常都用 C++或 C#编写；Java 在服务器端编程和跨平台客户端应用领域则很有优势。</li></ul><h3 id="1-8-3-JVM-功能说明">1.8.3 JVM 功能说明</h3><p>JVM（Java Virtual Machine ，Java 虚拟机）：是一个虚拟的计算机，是 Java 程序的运行环境。JVM 具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器。</p><p><img src="https://img-blog.csdnimg.cn/f51b46569e604732a684aa2c8823ba58.png" alt="JVM"></p><ul><li><p>功能 1：实现 Java 程序的跨平台性 。我们编写的 Java 代码，都运行在 JVM 之上。正是因为有了 JVM，才使得 Java 程序具备了跨平台性。</p><p><img src="https://img-blog.csdnimg.cn/d4971b8e3d6d4a4eb8bc6fe549b716e3.png" alt="JVM 跨平台性"></p></li><li><p>功能 2：自动内存管理（内存分配、内存回收）</p><ul><li>Java 程序在运行过程中，涉及到运算的数据的分配、存储等都由 JVM 来完成。</li><li>Java 消除了程序员回收无用内存空间的职责。提供了一种系统级线程跟踪存储空间的分配情况，在内存空间达到相应阈值时，检查并释放可被释放的存储器空间。</li><li>GC 的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没有释放空间而导致的内存泄漏。</li></ul></li></ul><h2 id="1-9-企业真题">1.9 企业真题</h2><ol><li><p>一个“.java”源文件中是否可以包括多个类？有什么限制？<br>答：<br>一个源文件中可以声明多个类，但是最多只能有一个类使用 public 进行声明。<br>且要求声明为 public 的类的类名与源文件名相同。</p></li><li><p>Java 的优势有哪些？<br>答：跨平台型、安全性高、简单性、高性能、面向对象性、健壮性。</p></li><li><p>常用的几个命令行操作都有哪些？<br>答：<br>① 盘符名称:<br>盘符切换。E:回车，表示切换到 E 盘。<br>② dir<br>列出当前目录下的文件以及文件夹。<br>③ cd 目录<br>进入指定目录。<br>④ cd …<br>回退到上一级目录。<br>⑤ cd \ 或 cd /<br>回退到盘符目录。<br>⑥ md 文件目录名<br>创建指定的文件目录。<br>⑦ rd 文件目录名*<br>删除指定的文件目录（如文件目录内有数据，删除失败）。<br>⑧ cls<br>清屏。<br>⑨ exit<br>退出命令提示符窗口。<br>⑩ ↑ ↓<br>调阅历史操作命令。</p></li><li><p>Java 中是否存在内存溢出、内存泄漏？如何解决？举例说明。<br>答：Java 中存在内存溢出和内存泄漏问题。</p><p>内存溢出指的是程序申请的内存超出了 JVM 所能分配的内存大小，导致程序崩溃。解决方法包括：<br>① 增加 JVM 内存限制：通过修改 JVM 启动参数，增加内存限制，例如 -Xmx。<br>② 优化代码：检查代码中是否存在大量的无用对象或者内存泄漏，及时释放资源。<br>③ 分析内存使用情况：使用工具分析内存使用情况，找到内存占用过多的地方，及时优化。<br>内存泄漏指的是程序中的对象在使用完毕后没有及时释放，导致内存占用不断增加。解决方法包括：<br>① 手动释放资源：在代码中手动释放资源，例如关闭文件、数据库连接等。<br>② 使用 try-with-resources：使用 try-with-resources 管理资源，确保资源被及时释放。<br>③ 检查代码：检查代码中是否存在内存泄漏的地方，及时优化。例如，如果在循环中创建对象并没有及时释放，就会导致内存泄漏。</p></li><li><p>如何看待 Java 是一门半编译半解释型的语言?<br>答：Java 是一门半编译半解释型的语言，这意味着 Java 具有一定的优点和缺点。</p><p>优点：<br>① 跨平台性强：Java 的半编译半解释型特性使得它能够在不同的操作系统上运行，只需在不同平台上安装 Java 虚拟机即可。<br>② 安全性高：Java 的编译过程中会进行严格的类型检查和边界检查，减少了程序出错的可能性，同时 Java 还具有内存自动管理机制，防止了一些常见的安全漏洞。<br>③ 灵活性好：Java 的半编译半解释型特性使得它能够在运行时进行动态加载和更新，增强了程序的灵活性。<br>缺点：<br>① 执行效率低：由于 Java 是半编译半解释型的语言，需要在运行时进行解释和编译，导致执行效率较低。<br>② 内存占用大：Java 在运行时需要加载虚拟机和类库，占用的内存较大。<br>③ 资源消耗多：Java 的编译和解释过程需要占用较多的 CPU 和内存资源，对于一些资源受限的设备来说可能会造成困扰。</p><p>综上所述，Java 的半编译半解释型特性使得它具有跨平台性和安全性等优点，但也存在执行效率低、内存占用大和资源消耗多等缺点。在实际应用中需要根据具体情况进行权衡和选择。</p><p><img src="https://img-blog.csdnimg.cn/2b8e031807a04397a508117d4ebf34f2.png" alt=" Java 是一门半编译半解释型的语言"></p></li></ol><h1>第 2 章 变量与运算符</h1><h2 id="2-1-关键字、保留字">2.1 关键字、保留字</h2><ul><li>关键字：被 Java 赋予特殊含义的字符串。<br>官方规范中有 50 个关键字，true、false、null 虽然不是关键字，但是可以当做关键字来看待。</li><li>保留字：goto、const</li></ul><h2 id="2-2-标识符">2.2 标识符</h2><p>标识符：凡是可以自己命名的地方，都是标识符。<br>比如：类名、变量名、方法名、接口名、包名、常量名等。</p><p>标识符命名的规则：</p><ul><li>由 26 个英文字母大小写，0 - 9，或 $ 组成。</li><li>数字不可以开头。</li><li>不可以使用关键字和保留字，但能包含关键字和保留字。</li><li>Java 中严格区分大小写，长度无限制。</li><li>标识符不能包含空格。</li></ul><p>标识符命名的规范：</p><ul><li>包名：多个单词组成时所有字母都小写，<br>例如：java.lang、com.MYXH.bean</li><li>类名、接口名：多个单词组成时，所有单词的首字母大写，例如：HelloWorld，String，System 等。</li><li>变量名、方法名：多个单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，例如：age, name, bookName, main, binarySearch, getName 等。</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接，例如：MAX_VALUE, PI, DEFAULT_CAPACITY 等。</li></ul><h2 id="2-3-变量">2.3 变量</h2><p>变量的概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p><p>变量的构成包含三个要素：数据类型、变量名、存储的值。</p><p>Java 中变量声明的格式：数据类型 变量名 = 变量值</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量的方式1：</span></span><br><span class="line"><span class="type">char</span> gender;    <span class="comment">// 过程1：变量的声明</span></span><br><span class="line">gender = <span class="string">'男'</span>;    <span class="comment">// 过程2：变量的赋值（或初始化）</span></span><br><span class="line"><span class="comment">// 定义变量的方式2：声明与初始化合并</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同一个作用域内，不能声明两个同名的变量</span></span><br><span class="line"><span class="comment">// char gender = '女';</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="comment">// b1 超出了 byte 的范围，编译不通过。</span></span><br><span class="line"><span class="comment">// b1 = 128;</span></span><br></pre></td></tr></table></figure><p>说明：<br>定义变量时，变量名要遵循标识符命名的规则和规范。<br>① 变量都有其作用域。变量只在作用域内是有效的，出了作用域就失效了。<br>② 在同一个作用域内，不能声明两个同名的变量。<br>③ 定义好变量以后，就可以通过变量名的方式对变量进行调用和运算。<br>④ 变量值在赋值时，必须满足变量的数据类型，并且在数据类型有效的范围内变化。</p><p>变量的内存结构如图：<br><img src="https://img-blog.csdnimg.cn/db5cff0d053542d59e52e1e6e9dee41a.png" alt="变量的内存结构"></p><h2 id="2-4-基本数据类型">2.4 基本数据类型</h2><h3 id="2-4-1-基本数据类型">2.4.1 基本数据类型</h3><ul><li>整型：byte、short、int、long</li><li>浮点型：float、double</li><li>字符型：char</li><li>布尔型：boolean</li></ul><h3 id="2-4-2-引用数据类型">2.4.2 引用数据类型</h3><ul><li>类(class)</li><li>数组(array)</li><li>接口(interface)</li><li>枚举(enum)</li><li>注解(annotation)</li><li>记录(record)</li></ul><p>如果在开发中，需要极高的精度，需要使用 BigDecimal 类替换浮点型变量。</p><h2 id="2-5-基本数据类型变量间的运算规则">2.5 基本数据类型变量间的运算规则</h2><h3 id="2-5-1-自动类型提升">2.5.1 自动类型提升</h3><p>规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。</p><h3 id="2-5-2-强制类型转换">2.5.2 强制类型转换</h3><p>规则：</p><ul><li>如果需要将容量大的变量的类型转换为容量小的变量的类型，需要使用强制类型转换。</li><li>强制类型转换需要使用强转符：()。在()内指明要转换为的数据类型。</li><li>强制类型转换过程中，可能导致精度损失。</li></ul><h2 id="2-6-基本数据类型与-String-的运算">2.6 基本数据类型与 String 的运算</h2><h3 id="2-6-1-字符串类型：String">2.6.1 字符串类型：String</h3><p>String 类，属于引用数据类型，俗称字符串。</p><p>String 类型的变量，可以使用一对""的方式进行赋值。</p><p>String 声明的字符串内部，可以包含 0 个，1 个或多个字符。</p><h3 id="2-6-2-运算规则">2.6.2 运算规则</h3><ul><li>String 与基本数据类型变量间只能做连接运算，使用“+”表示。</li><li>运算的结果是 String 类型。</li><li>String 类型不能通过强制类型()转换，转为其他的类型。</li></ul><h2 id="2-7-进制的认识">2.7 进制的认识</h2><h3 id="2-7-1-进制的分类">2.7.1 进制的分类</h3><p>二进制（以 0B、0b 开头）、十进制、八进制（以 0 开头）、十六进制（以 0x 或 0X 开头）。</p><h3 id="2-7-2-二进制的理解">2.7.2 二进制的理解</h3><ul><li>正数：原码、反码、补码三码合一。</li><li>负数：原码、反码、补码不相同。了解三者之间的关系。<ul><li>负数的原码：把十进制转为二进制，然后最高位设置为 1。</li><li>负数的反码：在原码的基础上，最高位不变，其余位取反（0 变 1,1 变 0）。</li><li>负数的补码：反码 + 1。</li></ul></li><li>计算机数据的存储使用二进制补码形式存储，并且最高位是符号位。<ul><li>正数：最高位是 0。</li><li>负数：最高位是 1。</li></ul></li><li>熟悉：二进制与十进制之间的转换。</li><li>了解：二进制与八进制、十六进制间的转换。</li></ul><h2 id="2-8-运算符">2.8 运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><ul><li>运算符的分类：<ul><li>按照功能分为：算术运算符、赋值运算符、比较（或关系）运算符、逻辑运算符、位运算<br>符、条件运算符、Lambda 运算符。</li><li>按照操作数个数分为：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符 （三目运算符）。</li></ul></li></ul><h3 id="2-8-1-算术运算符">2.8.1 算术运算符</h3><p><img src="https://img-blog.csdnimg.cn/c4542eb1b130438a94d306ada93334c9.png" alt="算术运算符"></p><h3 id="2-8-2-赋值运算符">2.8.2 赋值运算符</h3><ul><li>符号：=<ul><li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li><li>支持连续赋值。</li></ul></li><li>扩展赋值运算符： +=、 -=、*=、 /=、%=</li></ul><h3 id="2-8-3-比较（关系）运算符">2.8.3 比较（关系）运算符</h3><p><img src="https://img-blog.csdnimg.cn/edaa10d48e044be7a674d23ba44487d0.png" alt="比较（关系）运算符"></p><h3 id="2-8-4-逻辑运算符">2.8.4 逻辑运算符</h3><p><img src="https://img-blog.csdnimg.cn/7950e9c915654cbe993c6170ca80ed86.png" alt="逻辑运算符"></p><p>逻辑运算符，操作的都是 boolean 类型的变量或常量，而且运算得结果也是 boolean 类型的值。</p><ul><li>运算符说明：<ul><li>&amp; 和 &amp;&amp;：表示"且"关系，当符号左右两边布尔值都是 true 时，结果才能为 true。否则，为 false。</li><li>| 和 ||：表示"或"关系，当符号两边布尔值有一边为 true 时，结果为 true。当两边都为 false 时，结果为 false。</li><li>！：表示"非"关系，当变量布尔值为 true 时，结果为 false。当变量布尔值为 false 时，结果为 true。</li><li>^：当符号左右两边布尔值不同时，结果为 true。当两边布尔值相同时，结果为 false。<br>理解：异或，追求的是“异”！</li></ul></li></ul><h3 id="2-8-5-位运算符">2.8.5 位运算符</h3><p><img src="https://img-blog.csdnimg.cn/c32282064e114bb8b6bb84e27d07c145.png" alt="位运算符"></p><p><img src="https://img-blog.csdnimg.cn/62921608915e4fa3a0952ecfd073b34d.png" alt="位运算符细节"></p><ul><li>左移：&lt;&lt;<br>运算规则：在一定范围内，数据每向左移动一位，相当于原数据 * 2。</li><li>右移：&gt;&gt;<br>运算规则：在一定范围内，数据每向右移动一位，相当于原数据 / 2。</li></ul><h3 id="2-8-6-条件运算符">2.8.6 条件运算符</h3><ul><li>条件运算符格式：(条件表达式)? 表达式 1 : 表达式 2</li><li>说明：<br>① 条件表达式的结果是 boolean 类型。<br>② 如果条件表达式的结果是 true，则执行表达式 1。否则，执行表达式 2。<br>③ 表达式 1 和表达式 2 需要是相同的类型或能兼容的类型。</li></ul><h3 id="2-8-7-运算符的优先级">2.8.7 运算符的优先级</h3><ul><li>如果想体现优先级比较高，使用()</li><li>我们在编写一行执行语句时，不要出现太多的运算符。</li></ul><h3 id="2-8-8-字符集">2.8.8 字符集</h3><ul><li>编码与解码：<br>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。</li><li>字符编码（Character Encoding）：就是一套自然语言的字符与二进制数之间的对应规则。</li><li>字符集：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符<br>号、图形符号、数字等。</li><li>ASCII 码、ISO-8859-1 字符集、GBxxx 字符集、Unicode 码、UTF-8。</li></ul><h2 id="2-9-企业真题">2.9 企业真题</h2><ol><li><p>怎么高效计算 2 * 8 的值？<br>答：<br>2 &lt;&lt; 3 或 8 &lt;&lt; 2</p></li><li><p>&amp;和&amp;&amp;的区别？<br>答：<br>区分“&amp;”和“&amp;&amp;”：<br>相同点：如果符号左边是 true，则二者都执行符号右边的操作。</p><p>不同点：<br>&amp; ： 如果符号左边是 false,则继续执行符号右边的操作。<br>&amp;&amp; ：如果符号左边是 false,则不再继续执行符号右边的操作（短路与）。<br>建议：开发中，推荐使用 &amp;&amp;。</p></li><li><p>Java 中的基本类型有哪些？String 是最基本的数据类型吗？<br>答：<br>基本数据类型（8 种）。<br>整型：byte、short、int、long<br>浮点型：float、double<br>字符型：char<br>布尔型：boolean<br>String 类，属于引用数据类型，俗称字符串。</p></li><li><p>Java 开发中计算金额时使用什么数据类型？<br>答：<br>不能使用 float 或 double，因为精度不高。<br>使用 BigDecimal 类替换，可以实现任意精度的数据的运算。</p></li><li><p>char 型变量中能不能存储一个中文汉字，为什么？<br>答：<br>可以。char c1 = ‘中’；char c2 = ‘a’。<br>因为 char 使用的是 unicode 字符集，包含了世界范围的所有的字符。</p></li><li><p>代码分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1=<span class="number">1</span>;</span><br><span class="line">s1=s1+<span class="number">1</span>;   <span class="comment">// 有什么错？  答：= 右边是 int 类型，需要强转。</span></span><br><span class="line"><span class="type">short</span> s1=<span class="number">1</span>;</span><br><span class="line">s1+=<span class="number">1</span>;     <span class="comment">//有什么错?   答：没错。</span></span><br></pre></td></tr></table></figure></li><li><p>int i = 0; i = i++ 执行这两句话后，变量 i 的值为？<br>答：<br>变量 i 的值为 0。</p></li><li><p>如何将两个变量的值互换？<br>String s1 = “abc”;<br>String s2 = “123”;<br>答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s1;</span><br><span class="line">s1 = s2;</span><br><span class="line">s2 = temp;</span><br></pre></td></tr></table></figure></li><li><p>boolean 占几个字节？<br>答：<br>在编译时不谈占几个字节。<br>但是 JVM 在给 boolean 类型分配内存空间时，boolean 类型的变量占据一个槽位(slot，等于 4 个字节)。<br>细节：true:1 false:0</p><blockquote><p>拓展：<br>在内存中，byte、short、char、boolean、int、float : 占用 1 个 slot。<br>double、long :占用 2 个 slot。</p></blockquote></li><li><p>为什么 Java 中 0.1 + 0.2 结果不是 0.3？<br>在代码中测试 0.1 + 0.2，你会惊讶的发现，结果不是 0.3，而是 0.3000……4。这是为什么？<br>答：<br>几乎所有现代的编程语言都会遇到上述问题，包括 JavaScript、Ruby、Python、Swift 和 Go 等。引发这个问题的原因是，它们都采用了 IEEE 754 标准。<br>IEEE 是指“电气与电子工程师协会”，其在 1985 年发布了一个 IEEE 754 计算标准，根据这个标准，小数的二进制表达能够有最大的精度上限提升。但无论如何，物理边界是突破不了的，它仍然不能实现“每一个十进制小数，都对应一个二进制小数”。正因如此，产生了 0.1 + 0.2 不等于 0.3 的问题。</p><p>具体的：<br>整数变为二进制，能够做到“每个十进制整数都有对应的二进制数”，比如数字 3，二进制就是 11；再比如，数字 43 就是二进制 101011，这个毫无争议。<br>对于小数，并不能做到“每个小数都有对应的二进制数字”。举例来说，二进制小数 0.0001 表示十进制数 0.0625 （至于它是如何计算的，不用深究）；二进制小数 0.0010 表示十进制数 0.125；二进制小数 0.0011 表示十进制数 0.1875。看，对于四位的二进制小数，二进制小数虽然是连贯的，但是十进制小数却不是连贯的。比如，你无法用四位二进制小数的形式表示 0.125 ~ 0.1875 之间的十进制小数。<br>所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用四舍五入或者“同乘同除”等方式进行验证，避免上述问题。</p></li></ol><h1>第 3 章 流程控制语句</h1><h2 id="3-1-流程控制结构">3.1 流程控制结构</h2><ul><li>顺序结构</li><li>分支结构<ul><li>if-else</li><li>switch-case</li></ul></li><li>循环结构<ul><li>for</li><li>while</li><li>do-while</li></ul></li></ul><h2 id="3-2-分支结构之一：if-else">3.2 分支结构之一：if-else</h2><p>在程序中，凡是遇到了需要使用分支结构的地方，都可以考虑使用 if-else。</p><h3 id="3-2-1-基本语法">3.2.1 基本语法</h3><ul><li><p>结构 1：单分支条件判断：if</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式)</span><br><span class="line">{</span><br><span class="line">    语句块;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li><li><p>结构 2：双分支条件判断：if…else</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(条件表达式)</span><br><span class="line">{</span><br><span class="line">    语句块 1;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">    语句块 2;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>结构 3：多分支条件判断：if…else if…else</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式 1)</span><br><span class="line">{</span><br><span class="line">    语句块 1;</span><br><span class="line">}</span><br><span class="line">else if (条件表达式 2)</span><br><span class="line">{</span><br><span class="line">    语句块 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">else if (条件表达式 n)</span><br><span class="line">{</span><br><span class="line">    语句块 n;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">    语句块 n+1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-分支结构之二：switch-case">3.3 分支结构之二：switch-case</h2><p>在特殊的场景下，分支结构可以考虑使用 switch-case。</p><h3 id="3-3-1-基本语法">3.3.1 基本语法</h3><p>分支结构之 switch-case</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)</span><br><span class="line">{</span><br><span class="line">    case 常量1:</span><br><span class="line">      // 执行语句 1</span><br><span class="line">      // break;</span><br><span class="line">      case 常量2:</span><br><span class="line">      // 执行语句 2</span><br><span class="line">      // break;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      // 执行语句 n</span><br><span class="line">      // break;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-3-2-case-的穿透性">3.3.2 case 的穿透性</h3><p>在 switch 语句中，如果 case 的后面不写 break，将出现穿透现象，也就是一旦匹配成功，不会在判断下一个 case 的值，直接向后运行，直到遇到 break 或者整个 switch 语句结束，执行终止。</p><h2 id="3-4-循环结构之一：for">3.4 循环结构之一：for</h2><p>凡是循环结构，都有 4 个要素：<br>① 初始化条件<br>② 循环条件（是 boolean 类型）<br>③ 循环体<br>④ 迭代条件</p><h3 id="3-4-1-基本语法">3.4.1 基本语法</h3><p>循环结构之一：for 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(① 初始化条件;② 循环条件;④ 迭代条件)</span><br><span class="line">{</span><br><span class="line">    ③ 循环体</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>我们可以在循环结构中使用 break。一旦执行 break，就跳出（或结束）当前循环结构。</li><li>如何结束一个循环结构？<ul><li>方式 1：循环条件不满足。（即循环条件执行完以后是 false）</li><li>方式 2：在循环体中执行了 break。</li></ul></li><li>如果一个循环结构不能结束，那就是一个死循环！我们开发中要避免出现死循环。</li></ul><h2 id="3-5-循环结构之二：while">3.5 循环结构之二：while</h2><p>凡是循环结构，就一定会有 4 个要素：<br>① 初始化条件<br>② 循环条件（是 boolean 类型）<br>③ 循环体<br>④ 迭代部分</p><h3 id="3-5-1-基本语法">3.5.1 基本语法</h3><p>循环结构之一：while 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① 初始化条件</span><br><span class="line">while(② 循环条件)</span><br><span class="line">{</span><br><span class="line">    ③ 循环体</span><br><span class="line">    ④ 迭代部分</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="3-6-循环结构之三：do-while">3.6 循环结构之三：do-while</h2><p>凡是循环结构，就一定会有 4 个要素：<br>① 初始化条件<br>② 循环条件（是 boolean 类型）<br>③ 循环体<br>④ 迭代部分</p><h3 id="3-6-1-基本语法">3.6.1 基本语法</h3><p>循环结构之一：do-while 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① 初始化条件</span><br><span class="line">do</span><br><span class="line">{</span><br><span class="line">    ③ 循环体</span><br><span class="line">    ④ 迭代部分</span><br><span class="line">}</span><br><span class="line">while(② 循环条件);</span><br></pre></td></tr></table></figure><h2 id="3-7-“无限”循环">3.7 “无限”循环</h2><h3 id="3-7-1-基本语法">3.7.1 基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(true) {}  或  for(;;) {}</span><br></pre></td></tr></table></figure><ul><li><p>开发中，有时并不确定需要循环多少次，需要根据循环体内部某些条件，来控制循环的结束（使用 break）。</p></li><li><p>如果此循环结构不能终止，则构成了死循环！开发中要避免出现死循环。</p></li></ul><h2 id="3-8-关键字-break、continue">3.8 关键字 break、continue</h2><p>break 和 continue 关键字的使用</p><ul><li>使用范围：在循环结构中的作用</li><li>相同点：<ul><li>break：循环结构中结束（或跳出）当前循环结构。</li><li>continue：循环结构中结束（或跳出）当次循环 。</li></ul></li></ul><h2 id="3-9-Scanner-类的使用">3.9 Scanner 类的使用</h2><p>如何从键盘获取不同类型（基本数据类型、String 类型）的变量：使用 Scanner 类。</p><p>键盘输入代码的四个步骤：<br>① 导包：import java.util.Scanner;<br>② 创建 Scanner 类型的对象：Scanner scan = new<br>Scanner(<a href="http://System.in">System.in</a>);<br>③ 调用 Scanner 类的相关方法（next()、nextXxx()），来获取指定类型的变量。<br>④ 释放资源：scan.close();</p><h2 id="3-10-获取随机数">3.10 获取随机数</h2><p>如何获取一个随机数?<br>① 可以使用 Java 提供的 API:Math 类的 random() 。<br>② random() 调用以后，会返回一个[0.0,1.0)范围的 double 型的随机数。</p><h2 id="3-11-企业真题">3.11 企业真题</h2><ol><li><p>break 和 continue 的作用？<br>答：<br>使用范围：在循环结构中的作用。</p><p>相同点：<br>break：循环结构中结束（或跳出）当前循环结构。<br>continue：循环结构中结束（或跳出）当次循环</p></li><li><p>if 分支语句和 switch 分支语句的异同之处？<br>答：<br>if-else 语句优势：<br>if 语句的条件是一个布尔类型值，if 条件表达式为 true 则进入分支，可以用于范围的判断，也可以用于等值的判断，使用范围更广。<br>switch 语句的条件是一个常量值（byte、short、int、char、枚举、String），只能判断某个变量或表达式的结果是否等于某个常量值，使用场景较狭窄。</p><p>switch 语句优势：<br>当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用 if 和 switch 都可以，习惯上使用 switch 更多。因为效率稍高。<br>当条件是区间范围的判断时，只能使用 if 语句。<br>使用 switch 可以利用穿透性，同时执行多个分支，而 if-else 没有穿透性。</p></li><li><p>switch 语句中忘写 break 会发生什么？<br>答：<br>如果在 switch 语句中忘记写 break，程序将会继续执行下一个 case 语句，直到遇到 break 或者 switch 语句结束。这种情况被称为“穿透”（fall-through），因为程序“穿透”了一个 case 语句并继续执行下一个 case 语句。这可能会导致程序出现意外行为，因为程序可能会执行不应该执行的代码。因此，在编写 switch 语句时，应该始终记得写上 break 来避免出现这种情况。</p></li><li><p>Java 支持哪些类型循环？<br>答：<br>for；while；do-while；<br>增强 for 循环（for-each）。</p></li><li><p>while 和 do while 循环的区别？<br>答：<br>while 循环和 do while 循环都是用于重复执行某个代码块的结构，但它们之间存在一些区别：<br>① while 循环是先判断条件是否成立，再决定是否执行循环体，如果条件不成立，则一次都不执行；而 do while 循环是先执行一次循环体，再判断条件是否成立，所以至少会执行一次循环体。<br>② while 循环的循环体可能一次都不执行，因为条件不成立；而 do while 循环的循环体至少会执行一次。<br>③ while 循环是入口判断循环，即在循环开始前就判断条件是否成立；而 do while 循环是出口判断循环，即在循环结束后判断条件是否成立。<br>④ 在循环条件不成立的情况下，while 循环不会执行循环体，而 do while 循环会执行一次循环体。</p><p>总的来说，while 循环适合在条件不成立时不需要执行循环体的情况下使用；而 do while 循环适合在至少需要执行一次循环体的情况下使用。</p></li></ol><h1>第 4 章 IDEA 的安装与使用</h1><h2 id="4-1-IDEA-的认识">4.1 IDEA 的认识</h2><ul><li>IDEA（集成功能强大、符合人体工程学）</li><li>Eclipse</li></ul><h2 id="4-2-IDEA-的下载、安装、卸载">4.2 IDEA 的下载、安装、卸载</h2><ul><li>卸载：使用控制面板进行卸载，注意删除 C 盘指定目录下的两个文件目录：jetbrains。</li><li>下载：从官网<a href="https://www.jetbrains.com/">IDEA 官网</a><a href="https://www.jetbrains.com/%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%9A%E6%97%97%E8%88%B0%E7%89%88%E3%80%82">https://www.jetbrains.com/进行下载：旗舰版。</a></li><li>安装：傻瓜式的安装、注册。</li></ul><h2 id="4-3-工程结构">4.3 工程结构</h2><ul><li>project(工程)、module(模块)、package(包)、package(包)等概念。</li><li>掌握：如何创建工程、如何创建模块、如何导入其他项目中的模块、如何创建包、如何创建类、如何运行。</li></ul><h2 id="4-4-企业真题">4.4 企业真题</h2><ol><li><p>开发中你接触过的开发工具都有哪些？<br>答：<br>IDEA、Visual Studio Code、Eclipse。</p></li><li><p>谈谈你对 Eclipse 和 IDEA 使用上的感受？<br>答：<br>IDEA 集成功能强大、符合人体工程学，Eclipse 不够人性化。</p></li></ol><h1>第 5 章：数组</h1><h2 id="5-1-数组的概述">5.1 数组的概述</h2><p>数组(Array)：就可以理解为多个数据的组合。</p><p>程序中的容器：数组、集合框架（List、Set、Map）。</p><p>数组中的概念：</p><ul><li>数组名</li><li>下标（或索引）</li><li>元素</li><li>数组的长度</li></ul><p>数组存储的数据的特点：</p><ul><li>依次紧密排列的、有序的、可以重复的。</li><li>数组的其它特点：<ul><li>一旦初始化，其长度就是确定的、不可更改的。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/2cd6a66782eb40059da67115d6ed5d69.png" alt="数组"></p><h2 id="5-2-一维数组">5.2 一维数组</h2><h3 id="5-2-1-数组的声明和初始化">5.2.1 数组的声明和初始化</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">String[] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"Tom"</span>,<span class="string">"Jerry"</span>};</span><br></pre></td></tr></table></figure><h3 id="5-2-2-数组的使用">5.2.2 数组的使用</h3><ul><li>调用数组的指定元素：使用角标、索引、index。</li><li>index 从 0 开始。</li><li>数组的属性：length，表示数组的长度。</li><li>数组的遍历。</li><li>数组元素的默认初始化值。</li></ul><h3 id="5-2-3-一维数组内存分析">5.2.3 一维数组内存分析</h3><ul><li><p>虚拟机栈：main() 作为一个栈帧，压入栈空间中。在 main() 栈帧中，存储着 arr 变量。arr 记录着数组实体的首地址值。</p></li><li><p>堆：数组实体存储在堆空间中。</p></li><li><p>Java 虚拟机的内存划分：</p><p><img src="https://img-blog.csdnimg.cn/a6a5a9e76891480e9ed38d02ba9ad632.png" alt="Java 虚拟机的内存划分"></p></li></ul><h2 id="5-3-二维数组">5.3 二维数组</h2><p>二维数组本质上是元素类型是一维数组的一维数组。</p><h2 id="5-4-数组的常用算法">5.4 数组的常用算法</h2><ul><li>数值型数组的特征值的计算：最大值、最小值、总和、平均值等。</li><li>数组元素的赋值。</li><li>数组的复制、赋值。</li><li>数组的反转。</li><li>数组的扩容、缩容。</li><li>数组的查找：<ul><li>线性查找。</li><li>二分法查找（前提：数组有序）。</li></ul></li><li>数组的排序：<ul><li>冒泡排序（最简单）。</li><li>快速排序（最常用）。</li></ul></li></ul><h2 id="5-5-Arrays-工具类的使用">5.5 Arrays 工具类的使用</h2><ul><li>java.util.Arrays 类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。</li><li>toString() 、 sort()、 binarySearch()。</li></ul><h2 id="5-6-数组中的常见异常">5.6 数组中的常见异常</h2><ul><li>下标越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException</li></ul><h2 id="5-7、企业真题">5.7、企业真题</h2><ol><li><p>数组有没有 length()这个方法? String 有没有 length()这个方法？<br>答：<br>数组没有 length()，有 length 属性。<br>String 有 length()。</p></li><li><p>有数组 int[] arr，用 Java 代码将数组元素顺序颠倒？<br>答：<br>可以使用两个指针，一个指向数组的第一个元素，另一个指向数组的最后一个元素，交换它们的值，然后继续向中间靠拢，直到两个指针相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line"></span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>[] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};    <span class="comment">// 定义一个数组</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"原数组："</span> + Arrays.toString(arr));    <span class="comment">// 输出原数组</span></span><br><span class="line">    reverseArray(arr);    <span class="comment">// 调用方法将数组元素顺序颠倒</span></span><br><span class="line">    System.out.println(<span class="string">"颠倒后的数组："</span> + Arrays.toString(arr));    <span class="comment">// 输出颠倒后的数组</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行该主函数，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原数组：[1, 2, 3, 4, 5]</span><br><span class="line">颠倒后的数组：[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure></li><li><p>为什么数组要从 0 开始编号，而不是 1？<br>答：<br>数组的索引，表示了数组元素距离首地址的偏离量。因为第 1 个元素的地址与首地址相同，所以偏移量就是 0，所以数组要从 0 开始。</p></li><li><p>数组有什么排序的方式，手写一下？<br>答：<br>常见的数组排序方式有冒泡排序、选择排序、插入排序、快速排序、归并排序等。</p><p>冒泡排序：<br>冒泡排序的思路是从第一个元素开始，依次比较相邻的两个元素，如果前一个元素比后一个元素大，则交换它们的位置。这样一轮下来，最大的元素就会被移动到最后一个位置。然后再从第一个元素开始，继续进行比较和交换，直到所有元素都被排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        {</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">         {</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">             {</span><br><span class="line">                 <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                 {</span><br><span class="line">                     <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                     arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                     arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                 }</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>冒泡排序的时间复杂度为 O(n^2)，空间复杂度为 O(1)。</p><p>快速排序：<br>快速排序的思路是选取一个基准元素，将数组分为左右两部分，左半部分的元素均小于等于基准元素，右半部分的元素均大于等于基准元素。然后对左右两部分分别进行快速排序，直到整个数组有序。在上面的代码中，partition 方法用于实现分区，将数组分为左右两部分。quickSort 方法用于实现快速排序，递归调用自身对左右两部分进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>};</span><br><span class="line"></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr)</span><br><span class="line">        {</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line"></span><br><span class="line">            quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot)</span><br><span class="line">            {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)</span><br><span class="line">            {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度为 O(nlogn)，空间复杂度为 O(logn)。</p></li><li><p>二分算法实现数组的查找？<br>答：<br>二分查找思路：<br>① 首先确定要查找的数组的范围，即左右边界；<br>② 计算中间位置，即中间索引值；<br>③ 判断中间值是否等于要查找的值，如果是，则返回中间索引值；<br>④ 如果中间值大于要查找的值，则在左半部分继续查找，即将右边界设为中间索引值减一；<br>⑤ 如果中间值小于要查找的值，则在右半部分继续查找，即将左边界设为中间索引值加一；<br>⑥ 重复 ②-⑤ 步骤，直到找到要查找的值或左右边界重合，此时返回-1 表示未找到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key &lt; arr[mid])</span><br><span class="line">            {</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid])</span><br><span class="line">            {</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(arr, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的元素"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"指定元素的索引为："</span> + index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度为 O(log n)，因为每次查找都将查找范围缩小一半，最坏情况下需要查找 log n 次，其中 n 为数组长度。<br>空间复杂度为 O(1)，因为只需要常数个额外变量存储查找范围的左右边界和中间索引值。</p></li><li><p>怎么求数组的最大子序列和?<br>答：<br>以下是一个使用 Java 实现的求解最大子序列和的示例代码：</p><p>这个算法的思路是使用动态规划的思想。</p><p>我们从左到右遍历整个数组，使用两个变量 maxSum 和 currentSum 来记录最大子序列和和当前子序列和。</p><p>对于当前遍历到的元素 nums[i]，我们可以有两种选择：<br>将 nums[i] 加入当前子序列中，即 currentSum = currentSum + nums[i]；<br>以 nums[i] 作为新的起点开始一个新的子序列，即 currentSum = nums[i]。</p><p>我们需要比较这两种选择哪个更优，即选择 currentSum + nums[i] 或选择 nums[i] 中的较大值作为当前子序列的和 currentSum。同时，我们需要比较当前子序列的和 currentSum 和最大子序列和 maxSum 哪个更大，即选择 Math.max(maxSum, currentSum)作为新的最大子序列和 maxSum。</p><p>最后，遍历完成后 maxSum 就是最大子序列和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSubArraySum</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArraySum</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        {</span><br><span class="line">            currentSum = Math.max(currentSum + nums[i], nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, currentSum);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span>[] nums = {-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> maxSubArraySum(nums);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最大子序列和为："</span> + maxSum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大子序列和为：6</span><br></pre></td></tr></table></figure><p>解释：最大子序列为[4, -1, 2, 1]，和为 6。</p></li><li><p>Arrays 类的排序方法是什么？如何实现排序的？<br>答：<br>Arrays 类提供了多种排序方法，包括：<br>① sort(Object[] a)：对数组 a 进行升序排序，元素类型必须实现 Comparable 接口。<br>② sort(Object[] a, Comparator c)：对数组 a 进行排序，使用自定义的 Comparator 比较器进行比较。<br>③ parallelSort(Object[] a)：对数组 a 进行并行排序，效率更高。</p><p>排序的实现原理主要是基于快速排序和归并排序，具体实现方式根据元素类型和排序方法不同而不同。</p><p>在 sort(Object[] a) 方法中，对于实现了 Comparable 接口的元素类型，通过 compareTo() 方法进行比较，并且使用快速排序实现；对于未实现 Comparable 接口的元素类型，则会抛出 ClassCastException 异常。</p><p>在 sort(Object[] a, Comparator c) 方法中，通过传入自定义的 Comparator 比较器进行比较，也使用快速排序实现。<br>在 parallelSort(Object[] a) 方法中，使用 Fork/Join 框架实现并行排序，将数组拆分成多个小数组进行排序，最后再合并起来。</p></li></ol><h1>Java 基础 第 2 阶段：面向对象编程——尚硅谷学习笔记（含面试题） 2023 年</h1><h1>第 6 章 面向对象——基础</h1><h2 id="6-1-面向过程-vs-面向对象">6.1 面向过程 vs 面向对象</h2><ul><li>不管是面向过程、面向对象，都是程序设计的思路。</li><li>面向过程（Process Oriented Programming，简称 POP）：以函数为基本单位，适合解决简单问题。</li><li>面向对象（ Object Oriented Programming），简称 OOP）：以类为基本单位，适合解决复杂问题。</li></ul><h2 id="6-2-类、对象">6.2 类、对象</h2><h3 id="6-2-1-类">6.2.1 类</h3><p>类：具有相同特征的事物的抽象描述，是抽象的、概念上的定义。</p><h3 id="6-2-2-对象">6.2.2 对象</h3><p>对象：实际存在的该类事物的每个个体，是具体的，因而也称为实例。</p><p>面向对象完成具体功能的操作的三步流程：</p><ul><li>步骤 1：创建类，并设计类的内部成员（属性、方法）。</li><li>步骤 2：创建类的对象。如：Phone p1 = new Phone()。</li><li>步骤 3：通过对象，调用其内部声明的属性或方法，完成相关的功能。</li></ul><p>匿名对象 （anonymous object）：</p><ul><li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</li><li>如：new Person().shout();</li><li>使用情况：<ul><li>如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li><li>我们经常将匿名对象作为实参传递给一个方法调用。</li></ul></li></ul><h3 id="6-2-3-对象的内存解析">6.2.3 对象的内存解析</h3><ul><li><p>Java 中内存结构划分为：虚拟机栈、堆、方法区；程序计数器、本地方法栈。</p></li><li><p>虚拟机栈：以栈帧为基本单位，有入栈和出栈操作；每个栈帧入栈操作对应一个方法的执行；方法内的局部变量会存储在栈帧中。</p></li><li><p>堆空间：new 出来的结构（数组、对象）：<br>① 数组，数组的元素在堆中<br>② 对象的成员变量在堆中。</p></li><li><p>方法区：加载的类的模板结构。</p><p><img src="https://img-blog.csdnimg.cn/52fa910e5ab1464ba81f866f41627773.png" alt=" JVM 内存结构划分"></p></li></ul><h2 id="6-3-类的成员之一：属性（成员变量-field）">6.3 类的成员之一：属性（成员变量 field）</h2><h3 id="6-3-1-声明成员变量">6.3.1 声明成员变量</h3><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名</span><br><span class="line">{</span><br><span class="line">    修饰符 数据类型 成员变量名 = 初始化值;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 声明 private 变量 age</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> “Lila”;    <span class="comment">// 声明 public 变量 name</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-3-2-成员变量-vs-局部变量">6.3.2 成员变量 vs 局部变量</h3><ul><li>在方法体外，类体内声明的变量称为成员变量。</li><li>在方法体内部等位置声明的变量称为局部变量。</li></ul><p><img src="https://img-blog.csdnimg.cn/4645b9880e934122831e8b01cb1929b4.png" alt="成员变量 vs 局部变量"></p><ul><li>不同点：<ul><li>内存中存储的位置<br>① 成员变量：堆 。<br>② 局部变量：栈。</li><li>生命周期<br>① 成员变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的。<br>② 局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡， 而且每一次方法调用都是独立。</li><li>作用域<br>① 实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” 。<br>② 局部变量：出了作用域就不能使用。</li></ul></li></ul><h2 id="6-4-类的成员之二：方法（method）">6.4 类的成员之二：方法（method）</h2><p>方法(method、函数)的理解：</p><ul><li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过<br>程。</li><li>将功能封装为方法的目的是，可以实现代码重用，减少冗余，简化代码。</li><li>Java 里的方法不能独立存在，所有的方法必须定义在类里。</li></ul><h3 id="6-4-1-方法的声明">6.4.1 方法的声明</h3><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(形参列表) throws 异常列表</span><br><span class="line">{</span><br><span class="line">    方法体的功能代码</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法用于获取 name 属性值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 方法用于设置 name 属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法用于获取 age 属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 方法用于设置 age 属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-4-2-方法的重载-overload">6.4.2 方法的重载(overload)</h3><ul><li>方法的重载的要求：“两同一不同”，方法名、返回值类型相同，形参列表不同。</li><li>调用方法时，如何确定调用的是某个指定的方法呢？<br>① 方法名<br>② 形参列表</li></ul><h3 id="6-4-3-可变个数形参的方法">6.4.3 可变个数形参的方法</h3><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void method (int ... args)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>int … arg 相当于 int[] arg</p><h3 id="6-4-4-方法的参数传递机制：值传递">6.4.4 方法的参数传递机制：值传递</h3><p>如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。</p><p>如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。</p><h3 id="6-4-5-递归方法">6.4.5 递归方法</h3><p>递归方法构成了隐式的循环。</p><p>对比：相较于循环结构，递归方法效率稍低，内存占用偏高。</p><h3 id="6-5-5-方法调用内存分析">6.5.5 方法调用内存分析</h3><p>方法没有被调用的时候，都在方法区中的字节码文件(.class)中存储。</p><p>方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈动<br>作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。</p><p>当方法执行结束后，会释放该内存，称为出栈，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。</p><p>栈结构：先进后出，后进先出。</p><h2 id="6-5-对象数组">6.5 对象数组</h2><ul><li>数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。</li><li>String[ ];</li><li>Person[ ];</li><li>Customer[ ];</li></ul><h2 id="6-6-package、import-关键字">6.6 package、import 关键字</h2><ul><li><p>package：指明声明的类所属的包。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 顶层包名.子包名 ;</span><br></pre></td></tr></table></figure></li><li><p>import：当前类中，如果使用其它包下的类（除 java.lang 包），原则上就需要导入。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 包名.类名;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-7-面向对象的特征之一：封装性">6.7 面向对象的特征之一：封装性</h2><p>Java 规定了 4 种权限修饰，分别是：private、缺省、protected、public。</p><p>我们可以使用 4 种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。</p><p><img src="https://img-blog.csdnimg.cn/02f932ebf33b4d15a54a96d38b0d8b23.png" alt="权限修饰符"></p><h3 id="6-7-1-封装性的体现">6.7.1 封装性的体现</h3><ul><li>场景 1：私有化(private)类的属性，提供公共(public)的 get 和 set 方法，对此属性进行获取或修改。</li><li>场景 2：将类中不需要对外暴露的方法，设置为 private。</li><li>场景 3：单例模式中构造器 private 的了，避免在类的外部创建实例。</li></ul><h3 id="6-7-2-封装性的作用">6.7.2 封装性的作用</h3><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉；<br>（Java 程序通常以类的形态呈现，相关的功能封装到方法中。）</li><li>低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用。<br>（给相关的类、方法设置权限，把该隐藏的隐藏起来，该暴露的暴露出去。）</li></ul><h2 id="6-8-类的成员之三：构造器（Constructor）">6.8 类的成员之三：构造器（Constructor）</h2><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名</span><br><span class="line">{</span><br><span class="line">    修饰符 构造器名()</span><br><span class="line">    {</span><br><span class="line">        // 实例初始化代码</span><br><span class="line">    }</span><br><span class="line">    修饰符 构造器名(参数列表)</span><br><span class="line">    {</span><br><span class="line">        // 实例初始化代码</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>构造器的作用：<br>① 搭配上 new，用来创建对象 。<br>② 初始化对象的成员变量。</p><h2 id="6-9-类的实例变量的赋值过程">6.9 类的实例变量的赋值过程</h2><ul><li><p>在类的属性中，可以有哪些位置给属性赋值？<br>① 默认初始化；<br>② 显式初始化；<br>③ 构造器中初始化；<br>④ 通过"对象.方法"的方式赋值；<br>⑤ 通过"对象.属性"的方式赋值；</p></li><li><p>这些位置执行的先后顺序是怎样？<br>① - ② - ③ - ④/⑤</p></li></ul><h2 id="6-10-JavaBean">6.10 JavaBean</h2><p>JavaBean 是一种 Java 语言写成的可重用组件。</p><p>所谓 JavaBean，是指符合如下标准的 Java 类：</p><ul><li>类是公共的。</li><li>有一个无参的公共的构造器。</li><li>有属性，且有对应的 get、set 方法。</li></ul><h2 id="6-11-UML-类图">6.11 UML 类图</h2><p>UML（Unified Modeling Language，统一建模语言），用来描述软件模型和架构的图形化语言。</p><p>在软件开发中，使用 UML 类图可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。</p><p><img src="https://img-blog.csdnimg.cn/a0cebd9662364c74aa58788035690a2e.png" alt="UML 类图"></p><h2 id="6-12-企业真题">6.12 企业真题</h2><ol><li><p>面向对象，面向过程的理解？<br>答：<br>面向对象和面向过程是两种不同的编程思想。</p><p>面向过程编程是一种按照一定的流程和步骤来完成任务的编程方式。它将程序看作是一系列的步骤或者函数，每个函数都有一定的输入和输出。面向过程的编程思想强调的是程序的执行过程，程序的主要任务是按照一定的流程和步骤来完成任务。</p><p>面向对象编程是一种将程序看作一组对象的编程方式，它将程序看作是一组相互协作的对象，每个对象都有一定的属性和方法。面向对象的编程思想强调的是程序的设计和架构，程序的主要任务是设计和实现对象之间的关系和交互。</p><p>总的来说，面向过程的编程思想适合于简单的程序，而面向对象的编程思想适合于复杂的程序。在实际的编程中，可以根据需要选择不同的编程思想来完成任务。</p></li><li><p>Java 的引用类型有哪几种？<br>答：<br>类、数组、接口、枚举、注解、记录。</p></li><li><p>类和对象的区别？<br>答：<br>类是一种抽象的概念，描述了一类具有相同属性和行为的对象的集合。对象则是类的实例，具有独立的状态和行为。</p><p>类是一种模板或蓝图，用于创建对象。它定义了对象的属性和方法，但并不实际存在于程序中。对象则是类的具体实现，它们是程序中实际存在的实体。</p><p>类和对象之间的关系是一种“是一种”（is-a）的关系。例如，一个狗类可以派生出吉娃娃犬类，吉娃娃犬就是狗类的一种具体实现。同样，一个具体的吉娃娃犬对象也是狗类的一个实例。</p><p>总之，类是一种抽象的概念，描述了一类对象的共同特征；对象则是类的具体实现，具有独立的状态和行为。</p></li><li><p>面向对象，你解释一下，项目中哪些地方用到面向对象？<br>答：<br>“万事万物皆对象”。</p><p>面向对象是一种编程思想，它将程序中的数据和操作封装成对象，并通过对象之间的交互来完成任务。在面向对象的编程中，重点是对象，而不是函数或过程。</p><p>在项目中，面向对象通常用于设计和实现程序的核心功能模块。例如，一个电商网站的订单管理系统可以设计为一个 Order 类，它包含订单信息和操作方法，如创建订单、更新订单状态等。另外，面向对象还可以用于设计和实现用户界面、数据访问、日志记录等模块。</p><p>具体地说，项目中哪些地方用到面向对象取决于具体的业务需求和技术架构，但通常会涉及以下方面：<br>① 类的设计和实现：根据业务需求，设计和实现类，包括类的属性、方法、构造函数、析构函数等。<br>② 对象的创建和使用：在程序运行时，根据需要创建对象，调用对象的方法来完成任务。<br>③ 继承和多态：利用继承和多态的特性，实现代码的复用和灵活性。<br>④ 接口和抽象类：通过接口和抽象类，定义程序的公共接口，提高代码的可维护性和可扩展性。</p><p>总之，面向对象是一种强大的编程思想，可以提高代码的可读性、可维护性和可扩展性，是现代软件开发中不可或缺的一部分。</p></li><li><p>Java 虚拟机中内存划分为哪些区域，详细介绍一下。<br>答：<br>Java 虚拟机中内存划分为以下几个区域：<br>① 程序计数器区域（Program Counter Register）：程序计数器是一块较小的内存区域，它可以看作是当前线程所执行的字节码指令的行号指示器。每个线程都有一个独立的程序计数器，用于记录线程执行的位置。当线程执行 Java 方法时，程序计数器记录的是正在执行的虚拟机字节码指令的地址；当线程执行 native 方法时，程序计数器的值为 undefined。<br>② Java 虚拟机栈区域（Java Virtual Machine Stacks）：每个线程在创建时都会分配一个 Java 虚拟机栈，用于存储方法调用的局部变量、操作数、返回值等信息。Java 虚拟机栈是一种线程私有的内存区域，它的生命周期与线程的生命周期相同。当线程调用一个方法时，Java 虚拟机会为该方法分配一个栈帧，并将该栈帧推入当前线程的 Java 虚拟机栈中。当方法执行结束时，对应的栈帧会被弹出。<br>③ 本地方法栈区域（Native Method Stacks）：与 Java 虚拟机栈类似，本地方法栈也是一种线程私有的内存区域，用于存储 native 方法的局部变量、操作数、返回值等信息。与 Java 虚拟机栈不同的是，本地方法栈为 native 方法服务。<br>④ 堆区域（Heap）：堆是 Java 虚拟机中最大的一块内存区域，用于存储对象实例和数组。堆是所有线程共享的内存区域，它的大小可以通过-Xmx 和-Xms 参数进行调整。Java 虚拟机的垃圾回收器会定期对堆中的无用对象进行回收。<br>⑤ 方法区域（Method Area）：方法区是一种线程共享的内存区域，用于存储类的结构信息、常量池、静态变量、即时编译器编译后的代码等。方法区的大小可以通过-XX:MaxMetaspaceSize 参数进行调整。在 JDK8 之前，方法区被称为持久代（Permanent Generation），但在 JDK8 之后，持久代被移除，方法区被移到了本地内存中，称为元空间（Metaspace）。<br>⑥ 运行时常量池区域（Runtime Constant Pool）：运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用。与 Class 文件中的常量池不同，运行时常量池可以动态地添加、删除、修改常量池中的内容。在 JDK7 之前，运行时常量池也属于方法区，但在 JDK7 之后，运行时常量池被移到了堆中。</p></li><li><p>对象存在 Java 内存的哪块区域里面？<br>答：<br>堆空间。</p></li><li><p>private 、缺省、protected、public 的作用区域？<br>答：<br>下表是 private、缺省、protected、public 的作用区域：</p><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包</th><th>继承子类</th><th>其他包</th></tr></thead><tbody><tr><td>private</td><td>✔️</td><td></td><td></td><td></td></tr><tr><td>缺省</td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr><td>protected</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td></tr><tr><td>public</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr></tbody></table><p>解释：<br>类内部：在类的内部可以随意访问该成员。<br>同包：在同一个包中的其他类可以访问该成员。<br>继承子类：在继承该类的子类中可以访问该成员。<br>其他包：在其他包中的类可以访问该成员。</p></li><li><p>main 方法的 public 能不能换成 private？为什么？<br>答：<br>能。但是更改以后就不能作为程序的入口了，就只是一个普通的方法。</p></li><li><p>构造方法和普通方法的区别？<br>答：<br>编写代码的角度：没有共同点。声明格式、作用都不同。<br>字节码文件的角度：构造器会以<init>()方法的形态呈现，用以初始化对象。</init></p></li><li><p>构造器 Constructor 是否可被 overload?<br>答：<br>可以。</p></li><li><p>无参构造器和有参构造器的的作用和应用？<br>答：<br>无参构造器和有参构造器是 Java 中的两种构造方法。</p><p>无参构造器是指不需要传入参数的构造器，它是默认的构造器，如果一个类没有定义任何构造器，那么编译器会自动为该类生成一个无参构造器。无参构造器的作用主要是用来初始化对象的成员变量，为对象赋初值，也可以在其中进行一些初始化操作。</p><p>有参构造器是指需要传入参数的构造器，它可以根据传入的参数不同来创建不同的对象。有参构造器的作用主要是用来实现对象的初始化，可以在其中设置对象的属性，进行一些初始化操作，以及传递参数给父类的构造器。</p><p>无参构造器和有参构造器的应用场景：<br>① 无参构造器适用于只需要对对象进行简单的初始化的情况。<br>② 有参构造器适用于需要传递参数，进行复杂初始化操作的情况。<br>③ 如果一个类需要继承父类，那么需要在子类的有参构造器中调用父类的有参构造器，以便完成父类的初始化操作。<br>④ 在实现某些设计模式时，如工厂模式、建造者模式等，需要使用有参构造器来创建对象。</p></li><li><p>成员变量与局部变量的区别？<br>答：<br>① 定义位置不同：成员变量定义在类中，局部变量定义在方法、代码块或者语句中。<br>② 生命周期不同：成员变量的生命周期与对象相同，而局部变量在方法结束后就会被销毁。<br>③ 访问方式不同：成员变量可以被类中的所有方法访问，而局部变量只能在定义它的方法中被访问。<br>④ 默认值不同：成员变量有默认值，而局部变量没有。成员变量的默认值是基本类型为 0 或者 false，引用类型为 null。<br>⑤ 内存分配不同：成员变量在对象创建时会被分配内存空间，而局部变量在方法调用时才会被分配内存空间。<br>⑥ 作用范围不同：成员变量的作用范围是整个类，而局部变量的作用范围只在定义它的方法内部。</p></li><li><p>变量赋值和构造方法加载的优先级问题？<br>答：<br>通过字节码文件，变量显式赋值先于构造器中的赋值。</p><p>从字节码文件的角度来看，变量的显式赋值是在类的初始化阶段执行的，而构造方法中的赋值是在对象实例化阶段执行的。</p><p>在类的初始化阶段，字节码解释器会按照顺序执行类中所有静态变量的显式赋值语句，将值存储在静态变量表中。然后再执行静态代码块和其他静态方法。这个过程只会执行一次，即在类被加载到内存中时执行。</p><p>在对象实例化阶段，字节码解释器会先分配对象所需的内存空间，然后会按照顺序执行实例变量的显式赋值语句，将值存储在实例变量表中。接着执行构造方法中的代码，其中可能包含对实例变量的赋值操作。这个过程对每个对象都会执行一次。</p><p>因此，从字节码文件的角度来看，变量的显式赋值优先于构造方法中的赋值，因为它们在不同的阶段执行。</p><p>假设有以下 Java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>对应的字节码文件如下（省略了一些细节）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的头部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 实例变量表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;  <span class="comment">// 默认值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// 对象实例化阶段，先执行实例变量的显式赋值</span></span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 构造方法中的赋值</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法结束</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 默认值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 类的初始化阶段，先执行静态变量的显式赋值</span></span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 再执行静态代码块和其他静态方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>从字节码文件可以看出，在类的初始化阶段，静态变量的显式赋值先于静态代码块和其他静态方法执行；而在对象实例化阶段，实例变量的显式赋值先于构造方法中的赋值执行。</p><p>以下是使用 javap 命令生成的 MyClass 类的字节码汇编代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">        <span class="number">4</span>: aload_0</span><br><span class="line">        <span class="number">5</span>: iconst_1</span><br><span class="line">        <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field x:I</span></span><br><span class="line">        <span class="number">9</span>: aload_0</span><br><span class="line">        <span class="number">10</span>: iload_1</span><br><span class="line">        <span class="number">11</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field x:I</span></span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> {};</span><br><span class="line">    Code:</span><br><span class="line">        <span class="number">0</span>: iconst_2</span><br><span class="line">        <span class="number">1</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field y:I</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>其中，构造方法的字节码指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0           // 将this引用入栈</span><br><span class="line">1: invokespecial #1  // 调用父类构造方法</span><br><span class="line">4: aload_0           // 将this引用入栈</span><br><span class="line">5: iconst_1          // 将常量1入栈</span><br><span class="line">6: putfield #2       // 将栈顶值（常量1）赋值给实例变量x</span><br><span class="line">9: aload_0           // 将this引用入栈</span><br><span class="line">10: iload_1          // 将参数x入栈</span><br><span class="line">11: putfield #2      // 将栈顶值（参数x）赋值给实例变量x</span><br><span class="line">14: return           // 返回</span><br></pre></td></tr></table></figure><p>静态代码块的字节码指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_2          // 将常量2入栈</span><br><span class="line">1: putstatic #3      // 将栈顶值（常量2）赋值给静态变量y</span><br><span class="line">4: return            // 返回</span><br></pre></td></tr></table></figure><p>可以看出，字节码汇编代码中也体现了变量的显式赋值先于构造方法中的赋值。</p></li></ol><h1>第 7 章：面向对象——进阶</h1><h2 id="7-1-this-关键字">7.1 this 关键字</h2><ul><li><p>this 调用的结构：属性、方法、构造器。</p></li><li><p>this 调用属性或方法时，理解为当前对象或当前正在创建的对象。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>();    <span class="comment">// 调用本类无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>(name);    <span class="comment">// 调用本类中有一个 String 参数的构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 当属性名和形参名同名时，必须使用this来区分</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>this(形参列表)的方式，表示调用当前类中其他的重载的构造器。</p></li></ul><h2 id="7-2-面向对象的特征二：继承性">7.2 面向对象的特征二：继承性</h2><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class A</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">修饰符 class B extends A</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>子类获取了父类中声明的全部的属性、方法。但是可能受封装性的影响，不能直接调用。</p><h3 id="7-2-1-继承性的好处">7.2.1 继承性的好处</h3><ul><li>减少了代码的冗余，提高了复用性。</li><li>提高了扩展性。</li><li>为多态的实现，提供了前提。</li></ul><h3 id="7-2-2-Java-中继承性的特点">7.2.2 Java 中继承性的特点</h3><ul><li>局限性：类的单继承性。通过类实现接口的方式，解决单继承的局限性。</li><li>支持多层继承，一个父类可以声明多个子类。</li></ul><h2 id="7-3-方法的重写（override-、overwrite）">7.3 方法的重写（override 、overwrite）</h2><p>方法的重载与重写的区别？</p><ul><li>方法的重载：“两同一不同”，方法名、返回值类型相同，形参列表不同。</li><li>方法的重写：<ul><li>前提：类的继承关系。</li><li>子类对父类中同名同参数方法的覆盖、覆写。</li></ul></li></ul><h2 id="7-4-super-关键字">7.4 super 关键字</h2><p>super 可以调用的结构：属性、方法、构造器。</p><p>super 调用父类的属性、方法：</p><ul><li>如果子父类中出现了同名的属性，此时使用 super.的方式，表明调用的是父类中声明的属性。</li><li>子类重写了父类的方法。如果子类的任何一个方法中需要调用父类被重写的方法时，需要使用 super.</li></ul><p>super 调用构造器：</p><ul><li>在子类的构造器中，首行使用了"this(形参列表)“，或者使用了"super(形参列表)”。</li></ul><h2 id="7-5-子类对象实例化的全过程">7.5 子类对象实例化的全过程</h2><ul><li>结果上：体现为继承性。</li><li>过程上：子类调用构造器创建对象时，一定会直接或间接的调用其父类的构造器，以及父类的父类的构造器，直到调用到 Object()的构造器。</li></ul><h2 id="7-6-面向对象的特征三：多态性">7.6 面向对象的特征三：多态性</h2><ul><li><p>广义上的理解：子类对象的多态性、方法的重写；方法的重载。</p></li><li><p>狭义上的理解：子类对象的多态性，即父类的引用指向子类的对象。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new String(“HelloWorld!”);     // 父类的引用指向子类的对象。</span><br></pre></td></tr></table></figure></li><li><p>多态的好处：减少了大量的重载的方法的定义；对扩展开放，对修改关闭原则。</p></li><li><p>举例：public boolean equals(Object obj)</p></li><li><p>多态的使用：虚方法调用（动态链接或晚期绑定）。“编译看左边，运行看右边”。</p></li><li><p>多态的逆过程：向下转型，使用强转符()。</p><ul><li>为了避免出现强转时的 ClassCastException，建议()之前使用 instanceOf 进行判断。<br><img src="https://img-blog.csdnimg.cn/633bd4d559c2466daf2eefda2897b1aa.png" alt="类型转换"></li></ul></li></ul><h2 id="7-7-Object-类">7.7 Object 类</h2><h3 id="7-7-1-理解根父类">7.7.1 理解根父类</h3><p>类 java.lang.Object 是类层次结构的根类，即所有其它类的父类。每个类都使用 Object 作为超类。</p><p><img src="https://img-blog.csdnimg.cn/529625f9db6e4fffb751bc8bb3451cf2.png" alt="Object 类"></p><h3 id="7-7-2-Object-类的方法">7.7.2 Object 类的方法</h3><ul><li><p>equals()</p><ul><li>== ：<ul><li>基本类型比较值：只要两个变量的值相等，即为 true。</li><li>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回 true。</li></ul></li><li>equals()：所有类都继承了 Object，也就获得了 equals()方法，可以重写。<ul><li>只能比较引用类型，Object 类源码中 equals()的作用与“==”相同：比较是否指向同一个对象。</li></ul></li></ul></li><li><p>toString()</p><ul><li>Object 中 toString()调用后，返回当前对象所属的类和地址值。</li><li>开发中常常重写 toString()，用于返回当前对象的属性信息。</li></ul></li><li><p>clone()</p><ul><li>clone() 方法是 Object 类中的一个方法，它用于创建并返回当前对象的一个副本。</li><li>该方法是 protected 访问修饰符，只能被子类重写或调用。</li><li>在调用 clone() 方法时，如果类没有实现 Cloneable 接口，会抛出 CloneNotSupportedException 异常。因此，要使用 clone() 方法，需要满足两个条件：<ul><li>类必须实现 Cloneable 接口。</li><li>在类中重写 clone() 方法，并将其访问修饰符改为 public。</li></ul></li><li>clone() 方法的使用可以避免一些对象拷贝的问题，例如浅拷贝和深拷贝。浅拷贝只复制对象的引用，而不是对象本身，因此当拷贝对象的某个属性发生变化时，原对象和拷贝对象的该属性都会发生变化。深拷贝则是完全复制一个对象，包括其所有属性，因此拷贝对象的属性变化不会影响原对象的属性。</li></ul></li><li><p>finalize()</p><ul><li>当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，<br>是本类对象调用的。）</li></ul></li><li><p>getClass()</p><ul><li>public final Class&lt;?&gt; getClass()：获取对象的运行时类型。</li></ul></li><li><p>hashCode()</p><ul><li>public int hashCode()：返回每个对象的 hash 值。</li></ul></li></ul><h3 id="7-2-3-native-关键字">7.2.3 native 关键字</h3><p>使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非 Java 语言实现的，并且被编译成了 DLL，由 Java 去调用。</p><h2 id="7-8-企业真题">7.8 企业真题</h2><ol><li><p>父类哪些成员可以被继承，属性可以被继承吗？请举下例子。<br>答：<br>子类可以继承父类的以下成员：<br>① 非私有的属性和方法（包括静态和实例成员）。<br>② 父类的构造方法。</p><p>子类不能继承父类的私有成员。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> String name;    <span class="comment">// 非私有的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 非私有的方法</span></span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 私有的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 私有的方法</span></span><br><span class="line">        System.out.println(<span class="string">"Walking..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 可以继承父类的非私有属性和方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Studying..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法继承父类的私有属性和方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public int getAge()</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        return age;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    public void go()</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        walk();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的例子中，子类 Student 继承了父类 Person 的 name 属性和 say()方法，但无法继承 age 属性和 walk()方法，因为它们都是私有的。</p><p>需要注意的是，子类虽然可以继承父类的属性，但是它们并不属于子类自己的属性，而是从父类继承而来的。子类可以通过继承来获得父类的属性和方法，但是不能直接访问父类的私有成员。</p></li><li><p>什么是 Override，与 Overload 的区别？<br>答：<br>Override 是指在子类中重写父类的方法，使得子类的方法覆盖了父类的方法，具有相同的方法名、参数列表和返回值类型。</p><p>Overload 是指在同一类中定义多个方法，它们具有相同的方法名，但参数列表不同（包括参数类型、个数或顺序），从而实现不同的功能。</p><p>区别在于 Override 是继承关系中子类对父类方法的重写，Overload 是在同一类中定义多个方法，参数列表不同，目的是提供多个方法实现不同的功能。</p></li><li><p>Overload 的方法是否可以改变返回值的类型?<br>答：<br>Overload 的方法不能仅仅通过返回值类型的改变来进行重载。方法的重载必须要求参数列表不同，而返回值类型不是方法签名的一部分。如果只是改变返回值类型而不改变参数列表，编译器将会报错。</p></li><li><p>构造器 Constructor 是否可被 override?<br>答：<br>构造器 Constructor 不能被 override，因为构造器的名字必须与类名相同，并且没有返回值类型。如果子类需要调用父类的构造器，可以使用 super 关键字来实现。但是子类可以提供自己的构造器，可以使用 super 关键字在子类的构造器中调用父类的构造器。</p></li><li><p>为什么要有重载，我随便命名一个别的函数名不行吗？谈谈你是怎么理解的。<br>答：<br>Java 中，重载是指在同一个类中，可以定义多个同名但参数类型、个数或顺序不同的方法，这些方法可以根据不同的参数类型和个数进行区分，从而实现不同的功能。</p><p>重载的作用是提高代码的可读性和可维护性。通过重载，可以使用相同的方法名来表示不同的操作，使代码更加简洁明了。同时，重载还可以提高代码的灵活性，可以根据不同的情况选择不同的方法进行调用，从而实现更加精细的控制。</p><p>如果随便命名一个别的函数名，可能会导致命名冲突，增加代码的维护难度，同时也会降低代码的可读性和可维护性。因此，在 Java 中，重载是一种非常重要的语言特性，可以提高代码的可读性和可维护性。</p></li><li><p>super 和 this 的区别？<br>答：<br>super 和 this 是 Java 中两个关键字，它们的作用不同。</p><p>super 表示父类，可以用来访问父类中的属性和方法。在子类中，如果要调用父类中的方法或者属性，可以使用 super 关键字。例如，如果子类中有一个和父类同名的方法或者属性，可以使用 super 关键字来区分调用父类的方法或者属性。super 关键字只能用在子类中。</p><p>this 表示当前对象，可以用来访问当前对象的属性和方法。在一个类中，如果要调用当前对象的属性或者方法，可以使用 this 关键字。例如，如果一个类中有一个成员变量和一个局部变量同名，可以使用 this 关键字来区分访问成员变量或者局部变量。this 关键字可以在任何地方使用。</p><p>总的来说，super 和 this 的作用不同，super 用于访问父类的属性和方法，this 用于访问当前对象的属性和方法。</p></li><li><p>this、super 关键字分别代表什么?以及他们各自的使用场景和作用。<br>答：<br>this 和 super 是 Java 中的关键字，分别代表当前对象和父类对象。</p><p>this 关键字代表当前对象，可以用来引用当前对象的属性和方法。this 关键字主要用于以下场景：<br>① 当局部变量和成员变量同名时，使用 this 关键字可以区分二者，如 <a href="http://this.name">this.name</a> 表示当前对象的 name 属性，name 表示局部变量。<br>② 在构造器中调用另一个构造器时，使用 this 关键字可以调用同一个类中的其他构造器，如 this(name)，表示调用该类中的带有一个参数的构造器。<br>③ 在方法链式调用时，使用 this 关键字可以返回当前对象，如 return this。<br>super 关键字代表父类对象，可以用来调用父类的属性和方法。super 关键字主要用于以下场景：<br>① 在子类中调用父类的构造方法时，使用 super 关键字可以调用父类的构造方法，如 super()，表示调用父类的无参构造器。<br>② 当子类和父类有同名属性或方法时，使用 super 关键字可以调用父类的属性或方法，如 <a href="http://super.name">super.name</a> 表示调用父类的 name 属性。</p><p>总的来说，this 关键字用于当前对象中，super 关键字用于父类对象中。它们的使用场景和作用不同，但都可以方便地引用当前对象或父类对象的属性和方法。</p></li><li><p>谈谈你对多态的理解。<br>答：<br>多态是面向对象程序设计中的重要概念，它是指同一个方法可以根据不同的对象调用出不同的行为。具体来说，多态包括两种类型：静态多态和动态多态。</p><p>静态多态是指在编译阶段就确定了调用的方法，主要通过方法的重载和参数的多态来实现。例如，同一个类中可以有多个同名方法，但是参数类型或个数不同，编译器在编译时会根据参数类型和个数来自动匹配调用哪个方法。</p><p>动态多态是指在运行时根据实际对象的类型来确定调用的方法，主要通过方法的重写和父类引用指向子类对象来实现。例如，一个父类引用可以指向其子类对象，当调用该引用的方法时，实际调用的是子类的方法。</p><p>多态的优点在于可以增加程序的灵活性和可扩展性，使代码更加简洁、可读性更高。它可以减少代码的重复，使程序更易于维护和修改。同时，多态也是面向对象程序设计的核心思想之一，它有助于提高代码的可重用性和可维护性，增强了程序的可扩展性和可靠性。</p></li><li><p>多态 new 出来的对象跟不多态 new 出来的对象区别在哪？<br>答：<br>多态 new 出来的对象是基于父类或接口创建的，可以根据实际情况指向不同的子类对象，具有更强的灵活性和可扩展性；而不多态 new 出来的对象是直接创建的具体子类对象，无法在运行时进行动态绑定，缺乏灵活性和可扩展性。</p></li><li><p>说说你认为多态在代码中的体现。<br>答：<br>多态是指同一种操作作用于不同的对象上面，可以产生不同的执行结果。在 Java 中，多态主要通过以下三种方式体现：<br>① 方法重载：方法重载是指在同一个类中，有多个方法名相同但参数类型或个数不同的方法。这种方法的调用会根据传入的参数类型或个数的不同，自动匹配调用相应的方法，实现了多态。<br>② 方法重写：方法重写是指子类重写了父类的方法，当调用这个方法时，实际上会根据对象的实际类型调用对应的方法。这种方法实现了运行时多态。<br>③ 接口实现：接口是一种规范，定义了一组方法的签名，实现接口的类必须实现这些方法。当一个类实现了多个接口时，可以根据需要选择调用不同的方法，实现了多态。</p></li><li><p>== 与 equals() 的区别？<br>答：<br>在 Java 中，== 是一个操作符，用于比较两个对象的内存地址是否相同，即它们是否是同一个对象。而 equals()是一个方法，用于比较两个对象的内容是否相同，即它们是否具有相同的属性值。</p><p>在 Java 中，所有的类都继承自 Object 类，Object 类中的 equals()方法默认使用==比较两个对象的内存地址。因此，如果我们想要比较两个对象的内容是否相同，需要重写 equals()方法来实现比较对象属性值的操作。</p><p>例如，我们可以在自定义类中重写 equals()方法，比较对象的属性值是否相同，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他方法省略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，我们重写了 Person 类的 equals()方法，首先使用==比较两个对象的内存地址，如果相同则返回 true，否则判断 o 是否是 Person 类的实例，如果不是则返回 false，最后比较两个对象的属性值是否相同，如果相同则返回 true，否则返回 false。</p><p>在使用 equals()方法比较两个对象时，需要注意以下几点：<br>① equals()方法必须满足自反性、对称性、传递性和一致性等特性；<br>② equals()方法的参数必须是 Object 类型，需要进行类型转换；<br>③ equals()方法比较两个对象的属性值时，需要使用 Objects.equals()方法，避免空指针异常。</p></li><li><p>重写 equals()方法要注意什么？<br>答：<br>重写 equals()方法是为了比较两个对象是否相等，因此需要注意以下几点：<br>① 对象比较要使用 equals()方法，而不是“==”运算符。<br>② 重写 equals()方法时，需要重写 hashCode()方法，保证相等的对象具有相同的哈希码。<br>③ equals()方法必须具有自反性、对称性、传递性和一致性。<br>④ equals()方法的参数必须是 Object 类型，需要进行类型检查和类型转换。<br>⑤ 在比较对象的属性时，需要逐个比较所有属性，而不是只比较其中的几个属性。<br>⑥ 如果子类中增加了新的属性，需要在 equals()方法中同时比较新的属性。<br>⑦ 如果父类已经实现了 equals()方法，子类可以选择继承父类的 equals()方法，也可以重写 equals()方法。如果重写了 equals()方法，需要调用父类的 equals()方法进行比较。</p></li><li><p>Java 中所有类的父类是什么？他都有什么方法？<br>答：<br>Java 中所有类的父类是 Object 类。</p><p>Object 类中常用的方法有：<br>① toString()：返回对象的字符串表示形式。<br>② equals(Object obj)：判断两个对象是否相等。<br>③ hashCode()：返回对象的哈希码值。<br>④ getClass()：返回对象的类。<br>⑤ wait()：使当前线程等待。<br>⑥ notify()：唤醒正在等待该对象的线程。<br>⑦ notifyAll()：唤醒正在等待该对象的所有线程。<br>⑧ finalize()：在对象被垃圾回收器回收之前调用。</p></li></ol><h1>第 8 章 面向对象——高级</h1><h2 id="8-1-static-关键字">8.1 static 关键字</h2><ul><li><p>static 使用范围：</p><ul><li>在 Java 类中，可用 static 修饰属性、方法、代码块、内部类。</li></ul></li><li><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类</span><br><span class="line">{</span><br><span class="line">    修饰符 static 数据类型 变量名;</span><br><span class="line"></span><br><span class="line">    修饰符 static 返回值类型 方法名(形参列表)</span><br><span class="line">    {</span><br><span class="line">      方法体</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>static 修饰后的成员具备以下特点：</p><ul><li>静态的，随着类的加载而加载、执行。</li><li>随着类的加载而加载。</li><li>优先于对象存在。</li><li>修饰的成员，被所有对象所共享。</li><li>访问权限允许时，可不创建对象，直接被类调用。</li></ul></li><li><p>类变量：类的生命周期内，只有一个。被类的多个实例共享。</p></li></ul><h2 id="8-2-单例模式">8.2 单例模式</h2><p>经典的设计模式有 23 种。每个设计模式均是特定环境下特定问题的处理方法。</p><p><img src="https://img-blog.csdnimg.cn/8ac3940877454efd9e78d1f1af60043e.png" alt="23种设计模式"></p><blockquote><p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为"四人组（Gang of Four）"，而这本书也就被称为"四人组（或 GoF）"书。</p></blockquote><p>单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p><p>实现方式：饿汉式、懒汉式、枚举类等。</p><p>饿汉式代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lass Singleton</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></table></figure><p>懒汉式代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// 1.私有化构造器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">  <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">  {</span><br><span class="line">      <span class="keyword">if</span>(single == <span class="literal">null</span>)</span><br><span class="line">      {</span><br><span class="line">        single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>饿汉式和懒汉式的区别：</p><ul><li>饿汉式：“立即加载”，线程安全的。</li><li>懒汉式：“延迟加载”，线程不安全。</li></ul><h2 id="8-3-理解-main-方法的语法">8.3 理解 main()方法的语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>由于 JVM 需要调用类的 main()方法，所以该方法的访问权限必须是 public。</p><p>又因为 JVM 在执行 main()方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数。</p><p>又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。</p><h2 id="8-4-类的成员之四：代码块">8.4 类的成员之四：代码块</h2><ul><li><p>分类：静态代码块、非静态代码块。</p></li><li><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类</span><br><span class="line">{</span><br><span class="line">    static</span><br><span class="line">    {</span><br><span class="line">        静态代码块</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>静态代码块：随着类的加载而执行。</p></li><li><p>非静态代码块：随着对象的创建而执行。</p></li><li><p>总结<br>对象的实例变量可以赋值顺序：<br><img src="https://img-blog.csdnimg.cn/5a8c2936e3354656989e6194431ee81e.png" alt="实例变量赋值顺序"></p></li></ul><h2 id="8-5-final-关键字">8.5 final 关键字</h2><p>final：最终的，不可更改的。</p><p>用来修饰：类、方法、变量（成员变量、局部变量）。</p><ul><li>类：不能被继承。</li><li>方法：不能被重写。</li><li>变量：是一个“常量”，一旦赋值不能修改。</li></ul><h2 id="8-6-abstract-关键字">8.6 abstract 关键字</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p><p>abstract：抽象的。</p><p>抽象类的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修饰符 abstract class 类名</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">修饰符 abstract class 类名 extends 父类</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>抽象方法的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 abstract 返回值类型 方法名([形参列表]);</span><br></pre></td></tr></table></figure><p>用来修饰：类、方法。</p><ul><li>类：抽象类：不能实例化。</li><li>方法：抽象方法：没有方法体，必须由子类实现此方法。</li></ul><p>模板方法模式（TemplateMethod） ：</p><ul><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</li></ul><h2 id="8-7-interface-关键字">8.7 interface 关键字</h2><p>Java 的软件系统会有很多模块组成，那么各个模块之间也应该采用这种面向接口的低耦合，为系统提供更好的可扩展性和可维护性。</p><p>interface：接口，用来定义一组规范、一种标准。</p><p>接口声明的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名</span><br><span class="line">{</span><br><span class="line">    接口的成员列表</span><br><span class="line">    公共的静态常量</span><br><span class="line">    公共的抽象方法</span><br><span class="line"></span><br><span class="line">    公共的默认方法（JDK1.8 以上）</span><br><span class="line">    公共的静态方法（JDK1.8 以上）</span><br><span class="line">    私有方法（JDK1.9 以上）</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在 JDK8.0 之前，接口中只允许声明：<br>① 公共的静态的常量。<br>② 公共的抽象的方法。</p><ul><li>在 JDK8.0 时，接口中允许声明默认方法和静态方法。</li></ul><p>类实现接口（implements）：</p><ul><li>接口不能创建对象，但是可以被类实现（implements ，类似于被继承）。</li><li>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。</li></ul><p>接口实现的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 实现类 implements 接口</span><br><span class="line">{</span><br><span class="line">    重写接口中抽象方法</span><br><span class="line">    重写接口中默认方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">修饰符 class 实现类 extends 父类 implements 接口</span><br><span class="line">{</span><br><span class="line">    重写接口中抽象方法</span><br><span class="line">    重写接口中默认方法</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>接口可以多继承、多实现。</p><p>接口与抽象类之间的对比：</p><p><img src="https://img-blog.csdnimg.cn/296b1b7ddeaf4344ba1c929365176b14.png" alt="接口与抽象类之间的对比"></p><h2 id="8-8-类的成员之五：内部类">8.8 类的成员之五：内部类</h2><p>将一个类 A 定义在另一个类 B 里面，里面的那个类 A 就称为内部类，类 B 则称为外部类。</p><ul><li><p>成员内部类：<br>成员内部类的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类</span><br><span class="line">{</span><br><span class="line">    修饰符 static class 内部类</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>非匿名局部内部类：<br>非匿名局部内部类的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类</span><br><span class="line">{</span><br><span class="line">    修饰符 返回值类型 方法名(形参列表)</span><br><span class="line">    {</span><br><span class="line">        final/abstract class 内部类</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类：<br>匿名内部类的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new 父接口()</span><br><span class="line">{</span><br><span class="line">    重写方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">new 父类(实参列表)</span><br><span class="line">{</span><br><span class="line">    重写方法</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-9-枚举类：enum">8.9 枚举类：enum</h2><p>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</p><p>使用 enum 关键字定义枚举类。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 enum 枚举类名</span><br><span class="line">{</span><br><span class="line">    常量对象列表</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">修饰符 enum 枚举类名</span><br><span class="line">{</span><br><span class="line">    常量对象列表;</span><br><span class="line"></span><br><span class="line">    对象的实例变量列表;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="8-10-注解：Annotation">8.10 注解：Annotation</h2><p>注解（Annotation）是从 JDK5.0 开始引入，以“@注解名”在代码中存在。</p><p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。</p><p>注解可以在类编译、运行时进行加载，体现不同的功能。</p><p>常用注解：</p><ul><li>@Override: 限定重写父类方法，该注解只能用于方法。</li><li>@Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。</li><li>@SuppressWarnings: 抑制编译器警告。</li></ul><p>元注解：对现有的注解进行解释说明。</p><ul><li>@Target：表明可以用来修饰的结构。</li><li>@Retation：表明生命周期。</li><li>@Documented：表明这个注解应该被 javadoc 工具记录。</li><li>@Inherited：允许子类继承父类中的注解如何自定义注解。</li></ul><p>自定义注解的使用：</p><ul><li><p>一个完整的注解应该包含三个部分： ① 声明 ② 使用 ③ 读取</p></li><li><p>声明自定义注解 ：<br>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line">修饰符 @interface 注解名</span><br><span class="line">{</span><br><span class="line">    成员列表</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>框架 = 注解 + 反射 + 设计模式</p></blockquote><h2 id="8-11-JUnit-单元测试">8.11 JUnit 单元测试</h2><ul><li><p>测试分类：</p><ul><li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li><li>白盒测试：需要写代码的。关注程序具体的执行流程。</li></ul></li><li><p>JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供 Java 开发人员编写单元测试之用。</p></li><li><p>编写和运行@Test 单元测试方法：</p></li><li><p>JUnit4 版本，要求@Test 标记的方法必须满足如下要求：</p><ul><li>所在的类必须是 public 的，非抽象的，包含唯一的无参构造器。</li><li>@Test 标记的方法本身必须是 public，非抽象的，非静态的，void 无返回值，无参数的。</li></ul></li></ul><h2 id="8-12-包装类">8.12 包装类</h2><p>基本数据类型对应的包装类都有哪些？</p><p><img src="https://img-blog.csdnimg.cn/6a4e7ca622a4448f8b42e8549138ca53.png" alt="基本数据类型对应的包装类"></p><p>基本数据类型、包装类、String 三者之间的转换：</p><p><img src="https://img-blog.csdnimg.cn/a30635e9b47e483f97b13ec57ba141c8.png" alt="基本数据类型、包装类、String三者之间的转换"></p><p>基本数据类型 &lt;——&gt; 包装类：自动装箱、自动拆箱。</p><p>String 类的 valueOf(xxx)方法。</p><p>包装类的 parseXxx(String str)方法。</p><h2 id="8-13-IDEA-的-Debug">8.13 IDEA 的 Debug</h2><p>程序在执行过程中如果出现错误，该如何查找或定位错误呢？简单的代码直接就可以看出来，但如果代码比较复杂，就需要借助程序调试工具（Debug）来查找错误了。</p><p>Debug(调试)程序步骤如下：<br>① 添加断点。<br>② 启动调试。<br>③ 单步执行。<br>④ 观察变量和执行流程，找到并解决问题。</p><h2 id="8-14-企业真题">8.14 企业真题</h2><ol><li><p>静态变量和实例变量的区别？<br>答：<br>静态变量是属于类的变量，只有一个副本，被该类的所有实例共享，可以通过类名访问。实例变量是属于对象的变量，每个对象都有自己的一份副本，互相独立，只能通过实例名访问。静态变量在类加载时初始化，实例变量在实例化对象时初始化。静态变量一般用于存储常量或类级别的变量，实例变量一般用于存储对象的状态信息。</p></li><li><p>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？<br>答：<br>静态属性和静态方法可以被继承，但不能被重写。</p><p>静态属性和静态方法是属于类的，而不是属于实例的。子类继承父类时，会继承父类的静态属性和静态方法，但是子类无法重写父类的静态属性和静态方法，因为静态属性和静态方法是属于类的，而不是属于对象的。在子类中可以使用父类的静态属性和静态方法，也可以定义自己的静态属性和静态方法，但是不能重写父类的静态属性和静态方法。</p></li><li><p>是否可以从一个 static 方法内部发出对非 static 方法的调用？<br>答：<br>可以从一个 static 方法内部发出对非 static 方法的调用，但前提是必须先创建一个对象实例，然后通过该实例来调用非 static 方法。因为非 static 方法是属于对象的，需要通过对象实例才能调用，而 static 方法是属于类的，可以直接通过类名调用。如果在 static 方法中要调用非 static 方法，必须先创建一个对象实例，然后通过该实例来调用非 static 方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"这是一个非静态方法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.nonStaticMethod();</span><br><span class="line">        System.out.println(<span class="string">"这是一个静态方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的代码中，staticMethod() 中创建了一个 MyClass 的对象实例 obj，并通过该实例来调用 nonStaticMethod()。</p></li><li><p>被 static 修饰的成员(类、方法、成员变量)能否再使用 private 进行修饰？<br>答：<br>可以。被 static 修饰的成员可以再使用 private 进行修饰，表示该成员只能在当前类中被访问，不能被其他类访问。这样可以保证该成员的访问权限更加严格，增加程序的安全性。</p></li><li><p>知道哪些设计模式？<br>答：<br>我知道很多设计模式，包括： - 单例模式 - 工厂模式 - 抽象工厂模式 - 建造者模式 - 原型模式 - 适配器模式 - 桥接模式 - 组合模式 - 装饰器模式 - 外观模式 - 享元模式 - 代理模式 - 责任链模式 - 命令模式 - 解释器模式 - 迭代器模式 - 中介者模式 - 备忘录模式 - 观察者模式 - 状态模式 - 策略模式 - 模板方法模式 - 访问者模式</p><p>当然，这只是其中的一部分，设计模式还有很多种，每种模式都有自己的应用场景和优缺点。</p></li><li><p>开发中都用到了那些设计模式?用在什么场合?<br>答：<br>在开发中常用的设计模式包括：<br>① 单例模式：保证一个类只有一个实例，并提供全局访问点。<br>② 工厂模式：将对象的创建和使用分离，通过工厂类来创建对象。<br>③ 观察者模式：一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知。<br>④ 建造者模式：将一个复杂对象的构建过程分解为多个简单对象的构建过程，使得构建过程灵活性增强，且更易于扩展。<br>⑤ 适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。<br>⑥ 装饰器模式：动态地给一个对象添加一些额外的职责，而不需要修改原始类的代码。<br>⑦ 策略模式：定义一系列算法，将它们封装起来，并且使它们可以互相替换，使得算法的变化独立于使用算法的客户。</p><p>这些设计模式都有各自的使用场合，如单例模式可以用于创建全局唯一的对象；工厂模式可以用于创建一系列相关对象；观察者模式可以用于实现事件驱动的程序设计；建造者模式可以用于构建复杂对象；适配器模式可以用于不同接口之间的转换；装饰器模式可以用于扩展对象的功能；策略模式可以用于解耦算法的实现和使用。</p></li><li><p>main()方法的 public 能不能换成 private，为什么？<br>答：<br>不可以。因为 main()方法是程序的入口，如果将其访问修饰符改为 private，那么程序在启动时就无法访问该方法，无法执行程序。因此，main()方法必须是 public 修饰，以便程序能够访问执行。</p></li><li><p>main()方法中是否可以调用非静态方法？<br>答：<br>可以调用非静态方法，但需要先创建该方法所在类的对象，然后通过对象来调用非静态方法。</p></li><li><p>类的组成和属性赋值执行顺序?<br>答：<br>类的组成包括类名、属性、方法和构造函数。属性赋值执行顺序是在创建类的实例时执行的，先执行构造函数，然后按照属性的定义顺序依次执行属性的赋值操作。如果属性有默认值，则先执行默认值的赋值操作，然后再执行构造函数中的赋值操作。在属性赋值时，如果属性有 setter 方法，则会调用 setter 方法来完成赋值操作。</p></li><li><p>静态代码块，普通代码块，构造方法，从类加载开始的执行顺序？<br>答：<br>① 静态代码块：在类加载时执行，只执行一次；<br>② 普通代码块：在创建对象时执行，每次创建对象都会执行一次；<br>③ 构造方法：在创建对象时执行，每次创建对象都会执行一次。</p><p>执行顺序为：静态代码块 → 普通代码块 → 构造方法。</p></li><li><p>描述一下对 final 理解。<br>答：<br>final 是 Java 中的一个关键字，可以用来修饰类、方法和变量。final 关键字的主要作用是：<br>① final 修饰的类不能被继承，即该类为最终类。<br>② final 修饰的方法不能被子类重写，即该方法为最终方法。<br>③ final 修饰的变量为常量，即该变量的值不能被修改，一旦被赋值后就不能再改变。</p><p>final 关键字的使用可以提高程序的安全性和效率，因为 final 修饰的类、方法和变量在程序运行时无法被修改，从而防止了程序中的错误和不必要的开销。同时，final 还可以用来定义常量，方便程序中的使用和维护。</p></li><li><p>使用 final 修饰一个变量时，是引用不能改变，引用指向的对象可以改变？<br>答：<br>如果 final 修饰的是一个引用变量，则该引用变量所指向的对象不能被改变，但该对象的属性值可以被改变。如果 final 修饰的是一个基本数据类型变量，则该变量的值不能被改变。</p></li><li><p>final 不能用于修饰构造方法？<br>答：<br>是的，final 关键字不能用于修饰构造方法。final 关键字可以用于修饰类、成员变量和方法，但不能用于构造方法。这是因为构造方法的主要作用是初始化对象的状态，而 final 关键字表示不可变性，这与构造方法的目的不符。</p></li><li><p>final 或 static final 修饰成员变量，能不能进行++操作？<br>答：<br>无法进行++操作。final 修饰的成员变量是常量，不可被修改；而 static final 修饰的成员变量是静态常量，也不可被修改。因此，++操作是不允许的。</p></li><li><p>什么是抽象类？如何识别一个抽象类？<br>答：<br>抽象类是一种不能被实例化的类，其目的是为了被其他类继承而设计的。抽象类中可以包含抽象方法和非抽象方法，抽象方法是指没有实现的方法，需要在子类中被实现。非抽象方法是指已经实现的方法，可以直接在抽象类中调用。</p><p>抽象类可以通过关键字"abstract"来定义。如果一个类中包含至少一个抽象方法，那么该类必须被定义为抽象类。抽象类不能被实例化，只能被继承，并且子类必须实现所有抽象方法，否则子类也必须被定义为抽象类。<br>以下是一个抽象类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"我在吃东西。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的例子中，Animal 是一个抽象类，其中包含一个抽象方法 makeSound()和一个非抽象方法 eat()。makeSound()方法必须在子类中被实现，而 eat()方法已经被实现，可以直接在 Animal 类中调用。</p></li><li><p>为什么不能用 abstract 修饰属性、私有方法、构造器、静态方法、final 的方法？<br>答：<br>① 属性：抽象属性没有实现，无法在子类中重写，因此没有意义。<br>② 私有方法：私有方法只能在本类中被调用，无法在子类中重写，因此没有意义。<br>③ 构造器：构造器用于创建对象，不能被重写，因此没有意义。<br>④ 静态方法：静态方法属于类，不属于实例，无法被重写，因此没有意义。<br>⑤ final 方法：final 方法表示该方法不能被重写，因此使用 abstract 修饰没有意义。</p></li><li><p>接口与抽象类的区别？<br>答：<br>① 定义方式不同：接口使用 interface 关键字定义，抽象类使用 abstract 关键字定义。<br>② 实现方式不同：类可以实现多个接口，但只能继承一个抽象类。<br>③ 方法实现方式不同：接口中的方法都是抽象方法，没有方法体，实现类必须重写所有接口中的方法；抽象类中可以包含抽象方法和非抽象方法，实现类需要重写抽象方法，可以选择性地重写非抽象方法。<br>④ 成员变量不同：接口中只能定义常量，而抽象类可以定义普通成员变量。<br>⑤ 构造方法不同：接口中不能定义构造方法，而抽象类可以定义构造方法。<br>⑥ 目的不同：接口用于定义一组规范，而抽象类用于被继承。</p></li><li><p>接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？<br>答：<br>接口是可以继承接口的，这个过程和类之间的继承类似，子接口继承父接口的方法和常量，并可以在子接口中添加新的方法和常量。</p><p>抽象类可以通过实现接口来实现接口的方法，这个过程和普通类实现接口的过程一样。</p><p>抽象类也可以继承实现类，但是这种做法不太常见，因为实现类已经实现了接口中的方法，而抽象类的目的是为了让子类来实现，这样就会导致代码的重复和混淆。</p></li><li><p>接口可以有自己属性吗？<br>答：<br>在面向对象编程中，接口是一个纯粹的抽象概念，不应该包含实现代码或属性。接口只定义了类应该具有的方法和属性，但不提供它们的实现。因此，接口本身不应该有任何属性。</p></li><li><p>访问接口的默认方法如何使用？<br>答：<br>访问接口的默认方法可以通过实现该接口的类来调用。默认方法在接口中被定义，但是可以在实现类中被重写或者调用。如果实现类没有重写接口中的默认方法，那么默认方法将被继承并使用。<br>以下是访问接口默认方法的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"这是一个默认方法。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 此类不会重写接口中的默认方法。</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">            obj.myMethod();    <span class="comment">//输出：这是一个默认方法。</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个接口 MyInterface，其中包含了一个默认方法 myMethod()。然后，我们通过实现该接口的类 MyClass 来调用默认方法。在 main()方法中，我们创建了一个 MyClass 对象并调用了 myMethod()方法，输出了默认方法的内容。</p></li><li><p>内部类有哪几种？<br>答：<br>内部类分为四种：<br>① 成员内部类（也称为普通内部类）<br>② 静态内部类<br>③ 局部内部类<br>④ 匿名内部类</p></li><li><p>内部类的特点说一下。<br>答：<br>① 内部类是定义在另一个类内部的类，在外部类的范围内声明，但是不能独立存在。<br>② 内部类可以访问外部类的所有成员，包括私有成员。<br>③ 内部类可以使用外部类的引用，通过 this 关键字来访问外部类的成员。<br>④ 内部类可以被 private、protected、public 和 static 修饰，可以作为外部类的成员或局部变量。<br>⑤ 内部类可以继承其他类或实现接口，可以被其他类继承或实现。<br>⑥ 内部类可以访问外部类的私有构造方法，可以用来实现单例模式。<br>⑦ 内部类可以被用来实现回调机制，通过实现接口来实现回调函数。</p></li><li><p>枚举可以继承吗?<br>答：<br>枚举类型不能被继承，因为它们已经是最终的类型。枚举类型是一种特殊的值类型，它们的值是固定的且不可修改，因此没有必要对其进行继承。</p></li><li><p>Java 基本类型与包装类的区别？<br>答：<br>Java 基本类型是指 Java 语言中最基本的数据类型，包括整数类型、浮点数类型、字符类型和布尔类型，其值是直接存储在内存中的。而包装类是一种特殊的类，用于将基本类型转换为对象，以便在面向对象的环境中使用。包装类提供了一些方法，使得基本类型可以像对象一样进行操作。</p><p>Java 基本类型与包装类的区别主要有以下几点：<br>① 基本类型的变量直接存储值，而包装类的对象存储的是值的引用。<br>② 基本类型的变量在内存中占用的空间比包装类的对象小。<br>③ 基本类型的变量不能为 null，而包装类的对象可以为 null。<br>④ 基本类型的变量不能调用方法，而包装类的对象可以调用方法。<br>⑤ 基本类型的变量可以直接进行算术运算，而包装类的对象需要通过方法进行运算。<br>⑥ 基本类型的变量可以直接赋值，而包装类的对象需要使用构造方法或 valueOf()方法进行赋值。<br>⑦ 基本类型的变量在方法中传递时是按值传递，而包装类的对象在方法中传递时是按引用传递。</p></li><li><p>谈谈你对面向对象的理解？<br>答：<br>面向对象是一种编程范式，它将现实世界中的事物抽象成对象，并将对象之间的关系封装成类，从而实现程序的模块化、复用和扩展。面向对象的编程主要基于三个核心概念：封装、继承和多态。</p><p>封装是指将数据和行为封装在一个对象中，对外部只暴露必要的接口，隐藏内部实现细节，从而保证数据的安全性和可靠性。</p><p>继承是指一个类可以继承另一个类的属性和方法，从而减少代码的重复和冗余，提高代码的复用性和可维护性。</p><p>多态是指同一种行为具有不同的表现形式，不同的对象可以对同一消息作出不同的响应，从而增强代码的灵活性和可扩展性。</p><p>面向对象的编程思想可以使程序更加易于理解、扩展和维护，同时也可以提高代码的可复用性和可测试性，因此在现代软件开发中得到了广泛的应用。</p></li><li><p>面向对象的特征有哪些方面?<br>答：<br>面向对象的特征有以下几个方面：<br>① 封装性：将数据和操作数据的方法封装在一起，对外部隐藏其内部实现细节，只提供公共接口，以保证数据的安全性和完整性。<br>② 继承性：通过继承机制，子类可以继承父类的属性和方法，从而减少重复代码，提高代码的复用性和可维护性。<br>③ 多态性：同一种类的对象在不同的情况下表现出不同的行为，即一个方法可以有多个不同的实现方式，提高了代码的灵活性和可扩展性。<br>④ 抽象性：通过抽象类和接口，将对象的共性抽象出来，从而使得代码更加简洁、易于理解和维护。<br>⑤ 组合性：通过将多个对象组合在一起，形成一个更加复杂的对象，从而提高了代码的可拓展性和可复用性。</p></li></ol><h1>Java 基础 第 3 阶段：高级应用——尚硅谷学习笔记（含面试题） 2023 年</h1><h1>第 9 章 异常处理</h1><h2 id="9-1-异常的概述">9.1 异常的概述</h2><h3 id="9-1-1-什么是异常？">9.1.1 什么是异常？</h3><p>指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致 JVM 的非正常停止。</p><h3 id="9-1-2-异常的抛出机制">9.1.2 异常的抛出机制</h3><p>Java 中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出（throw）。</p><p>然后程序员可以捕获(catch)到这个异常对象，并处理。如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。</p><h3 id="9-1-3-如何对待异常">9.1.3 如何对待异常</h3><p>对于程序出现的异常，一般有两种解决方法：</p><ul><li>一是遇到错误就终止程序的运行。</li><li>另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及异常的处理，保证代码的健壮性。</li></ul><h2 id="9-2-异常的体系结构及常见的异常">9.2 异常的体系结构及常见的异常</h2><h3 id="9-2-1-Throwable">9.2.1 Throwable</h3><ul><li><p>java.lang.Throwable:异常体系的根父类。</p></li><li><p>Throwable 中的常用方法：</p><ul><li>public void printStackTrace()：<br>打印异常的详细信息。<br>包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用 printStackTrace()。</li><li>public String getMessage()：<br>获取发生异常的原因。</li></ul></li></ul><h3 id="9-2-2-Error-和-Exception">9.2.2 Error 和 Exception</h3><ul><li><p>Throwable 可分为两类：<br>Error 和 Exception。<br>分别对应着 java.lang.Error 与 java.lang.Exception 两个类。</p></li><li><p>Error：<br>Java 虚拟机无法解决的严重问题。<br>如：<br>JVM 系统内部错误、资源耗尽等严重情况。<br>一般不编写针对性的代码进行处理。</p><ul><li>例如：<br>StackOverflowError（栈内存溢出）和 OutOfMemoryError（堆内存溢出，简称 OOM）。</li></ul></li><li><p>Exception:<br>其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉。</p><ul><li>例如：<br>空指针访问。<br>试图读取不存在的文件。<br>网络连接中断。<br>数组角标越界。</li></ul></li></ul><h2 id="9-3-编译时异常和运行时异常">9.3 编译时异常和运行时异常</h2><p>Java 程序的执行分为编译时过程和运行时过程。有的错误只有在运行时才会发生。</p><ul><li>比如：<br>除数为 0，数组下标越界等。</li></ul><p>因此，根据异常可能出现的阶段，可以将异常分为：</p><ul><li>编译时期异常（即 checked 异常、受检异常）：<br>在代码编译阶段，编译器就能明确警<br>示当前代码可能发生（不是一定发生）xx 异常，并明确督促程序员提前编写处理它的代码。如果程序员没有编写对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，<br>或者不是靠加简单判断就可以避免的。<ul><li>例如：<br>FileNotFoundException（文件找不到异常）。</li></ul></li><li>运行时期异常（即 runtime 异常、unchecked 异常、非受检异常）：<br>在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了 xx 异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。<ul><li>例如：<br>java.lang.RuntimeException:类及它的子类都是运行时异常。<ul><li>比如：<br>ArrayIndexOutOfBoundsException：<br>数组下标越界异常。<br>ClassCastException：<br>类型转换异常。</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/da0eaa42fd394e00b03afaf4398308dc.png" alt="异常的体系结构"></p><h2 id="9-4-异常处理的方式">9.4 异常处理的方式</h2><h3 id="9-4-1-异常处理概述">9.4.1 异常处理概述</h3><ul><li><p>过程 1：“抛”</p><ul><li>“自动抛” ： 程序在执行的过程当中，一旦出现异常，就会在出现异常的代码处，自动生成对应异常类的对象，并将此对象抛出。</li><li>“手动抛” ：程序在执行的过程当中，不满足指定条件的情况下，我们主动的使用"throw + 异常类的对象"方式抛出异常对象。</li></ul></li><li><p>过程 2：“抓”</p><ul><li>狭义上讲：try-catch 的方式捕获异常，并处理。</li><li>广义上讲：把“抓”理解为“处理”。则此时对应着异常处理的两种方式：<br>① try-catch-finally<br>② throws</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/759cd91475d3495eb58dcc08c56afa09.png" alt="异常处理的流程"></p><h3 id="9-4-2-方式-1：捕获异常（try-catch-finally）">9.4.2 方式 1：捕获异常（try-catch-finally）</h3><p>try-catch-finally 语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">{</span><br><span class="line">    ...... //可能产生异常的代码</span><br><span class="line">}</span><br><span class="line">catch(异常类型1 e)</span><br><span class="line">{</span><br><span class="line">    ...... //当产生异常类型1型异常时的处置措施</span><br><span class="line">}</span><br><span class="line">catch(异常类型2 e)</span><br><span class="line">{</span><br><span class="line">    ......     //当产生异常类型2型异常时的处置措施</span><br><span class="line">}</span><br><span class="line">finally</span><br><span class="line">{</span><br><span class="line">    ...... //无论是否发生异常，都无条件执行的语句</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>try-catch-finally 使用细节：</p><ul><li>将可能出现异常的代码声明在 try 语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象。并将此对象抛出。</li><li>针对于 try 中抛出的异常类的对象，使用之后的 catch 语句进行匹配。一旦匹配上，就进入 catch 语句块进行处理。</li><li>一旦处理结束，代码就可继续向下执行。</li></ul><p>catch 中异常处理的方式：</p><ul><li>自己编写输出的语句。</li><li>printStackTrace()：打印异常的详细信息。 （推荐）</li><li>getMessage()：获取发生异常的原因。</li></ul><p>finally 的使用说明：</p><ul><li>finally 的理解：<br>我们将一定要被执行的代码声明在 finally 结构中。</li><li>什么样的代码我们一定要声明在 finally 中呢？<ul><li>我们在开发中，有一些资源（比如：输入流、输出流，数据库连接、Socket 连接等资源），在使用完以后，必须显式的进行关闭操作，否则，GC 不会自动的回收这些资源。进而导致内存的泄漏。</li><li>为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明<br>在 finally 中。</li></ul></li></ul><h3 id="9-4-3-方式-2：声明抛出异常类型（throws）">9.4.3 方式 2：声明抛出异常类型（throws）</h3><p>throws 语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名 1,异常类名 2...</span><br><span class="line">{</span><br><span class="line">    // 可能存在编译时异常</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>是否真正处理了异常？</p><ul><li>从编译是否能通过的角度看，给出了异常万一出现时候的解决方案。此方案就是，继续向上抛出(throws)。</li><li>但是，此 throws 的方式，仅是将可能出现的异常抛给了此方法的调用者。此调用者仍然需要考虑如何处理相关异常。从这个角度来看，throws 的方式不算是真正意义上处理了异常。</li></ul><p>方法的重写 throws 的要求：</p><ul><li>子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。</li></ul><h3 id="9-4-4-如何选择异常处理的两种方式？">9.4.4 如何选择异常处理的两种方式？</h3><ul><li>如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用 try-catch-finally 来处理，保证不出现内存泄漏。</li><li>如果父类被重写的方法没有 throws 异常类型，则子类重写的方法中如果出现异常，只能考虑使用 try-catch-finally 进行处理，不能 throws。</li><li>开发中，方法 a 中依次调用了方法 b,c,d 等方法，方法 b,c,d 之间是递进关系。此时，如果方法 b,c,d 中有异常，我们通常选择使用 throws，而方法 a 中通常选择使用 try-catch-finally。</li></ul><h2 id="9-5-手动-throw-异常对象">9.5 手动 throw 异常对象</h2><p>Java 中异常对象的生成有两种方式：</p><ul><li>由虚拟机自动生成：<br>程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。</li><li>由开发人员手动创建：<br>new 异常类型(实参列表);<br>如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦 throw 抛出，就会对程序运行产生影响了。</li></ul><h2 id="9-6-自定义异常类">9.6 自定义异常类</h2><h3 id="9-6-1-为什么需要自定义异常类">9.6.1 为什么需要自定义异常类</h3><ul><li>Java 中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。</li><li>例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。</li></ul><h3 id="9-6-2-如何自定义异常类">9.6.2 如何自定义异常类</h3><p>要继承一个异常类型：</p><ul><li>自定义一个编译时异常类型：<br>自定义类继承 java.lang.Exception。</li><li>自定义一个运行时异常类型：<br>自定义类继承 java.lang.RuntimeException。</li></ul><p>建议大家提供至少两个构造器，一个是无参构造，一个是(String message)构造器。</p><p>自定义异常需要提供 serialVersionUID。</p><h2 id="9-7-企业真题">9.7 企业真题</h2><ol><li><p>Java 的异常体系简单介绍下。<br>答：<br>Java 的异常体系是指 Java 语言中用于处理程序运行时错误的一组类和接口，它们构成了一个层次化的结构。在 Java 中，异常被定义为一种表示程序运行时错误的对象，它们可以由系统或程序员自己抛出，被程序的调用栈捕获并处理。Java 的异常体系主要包括以下几个部分：<br>① Throwable 类：Throwable 是所有异常类的父类，它定义了常见的异常处理方法，如 getMessage()、printStackTrace()等。<br>② Error 类：Error 是一种表示严重的系统级错误的异常，如 OutOfMemoryError、StackOverflowError 等，程序一般无法恢复。<br>③ Exception 类：Exception 是一种表示程序运行时错误的异常，它可以被程序处理并恢复。Exception 又分为两种：<br>RuntimeException 类：RuntimeException 是一种表示程序逻辑错误的异常，如 NullPointerException、ArrayIndexOutOfBoundsException 等。<br>非 RuntimeException 类：非 RuntimeException 是一种表示程序外部错误的异常，如 IOException、SQLException 等。<br>④ Checked 异常：Checked 异常是指在编译时必须处理的异常，如 IOException、SQLException 等。<br>⑤ Unchecked 异常：Unchecked 异常是指在编译时不必处理的异常，如 NullPointerException、ArrayIndexOutOfBoundsException 等。</p><p>Java 的异常体系为程序员提供了一种有效的处理程序运行时错误的方式，使得程序的稳定性和可靠性得到提高。</p></li><li><p>Java 异常处理机制？<br>答：<br>两种处理方案：try-catch-finally、throws。</p><p>Java 异常处理机制是一种用于处理程序运行时错误的机制。当程序出现错误时，会抛出一个异常对象，这个异常对象可以被程序捕获并进行处理。Java 中的异常分为两种：受检异常和非受检异常。</p><p>受检异常（Checked Exception）必须在方法签名中声明，并且在调用该方法时必须进行处理，否则编译器会报错。常见的受检异常有 IOException、SQLException 等。</p><p>非受检异常（Unchecked Exception）不需要在方法签名中声明，也不需要进行处理。常见的非受检异常有 NullPointerException、ArrayIndexOutOfBoundsException 等。</p><p>Java 中的异常处理机制主要包括 try-catch-finally 语句块和 throw 语句。try-catch-finally 语句块用于捕获和处理异常，throw 语句用于抛出异常。在 try 块中执行代码，如果发生异常则进入 catch 块，如果没有发生异常则跳过 catch 块。无论是否发生异常，finally 块中的代码都会执行。</p></li><li><p>异常的两种类型，Error 和 Exception 的区别？<br>答：<br>Error 和 Exception 都是 Java 中的 Throwable 类的子类，但它们之间有一些区别。</p><p>Error 是指 JVM 无法处理的严重问题，通常是由于系统资源耗尽或其他不可恢复的错误导致的。例如，OutOfMemoryError，StackOverflowError 等。Error 通常是不可处理的，程序应该尽可能地避免出现这种情况。</p><p>Exception 是指可以被程序处理的异常。它们通常由程序错误或意外情况引起，例如输入无效，文件不存在等。Exception 分为两种类型：checked exception 和 unchecked exception。checked exception 是在编译时就可以被检测到的异常，必须在代码中处理或声明抛出。unchecked exception 是在运行时才能被检测到的异常，不需要在代码中处理或声明抛出。</p><p>总之，Error 是无法处理的异常，而 Exception 是可以被处理的异常。</p></li><li><p>运行时异常与一般异常有何异同？<br>答：<br>运行时异常和一般异常的主要区别在于编译期检查和处理的时机不同。</p><p>一般异常（Checked Exception）必须在编译期间显式地捕获和处理，否则代码就无法编译通过。这种异常通常是由于外部因素导致的，例如文件不存在、网络连接失败等，程序员需要在代码中显式地处理这些异常情况。</p><p>而运行时异常（Unchecked Exception）则不需要在编译期间显式地捕获和处理，可以在运行期间由虚拟机自动抛出。这种异常通常是由于程序逻辑错误导致的，例如空指针异常、数组越界异常等。程序员可以通过编写正确的代码来避免这些异常的发生，但是如果发生了，通常也无法通过捕获和处理来修复程序的错误。</p><p>因此，一般异常通常是由程序员自己引起，并需要在代码中显式地处理；而运行时异常通常是由程序逻辑错误引起的，程序员需要通过编写正确的代码来避免这些异常的发生。</p></li><li><p>说几个你常见到的异常？<br>答：<br>① NullPointerException：当调用一个空对象的方法或访问其属性时抛出。<br>② ArrayIndexOutOfBoundsException：当访问数组元素超出其范围时抛出。<br>③ ClassCastException：当试图将一个对象强制转换为不兼容的类型时抛出。<br>④IllegalArgumentException：当传递的参数不符合方法要求时抛出。<br>⑤ IOException：当发生输入/输出异常时抛出。<br>⑥ FileNotFoundException：当尝试打开不存在的文件时抛出。<br>⑦ ArithmeticException：当发生算术错误时抛出，如除以零。<br>⑧ InterruptedException：当线程在等待或睡眠时被中断时抛出。<br>⑨ UnsupportedOperationException：当不支持请求的操作时抛出。<br>⑩ SQLException：当访问数据库时发生错误时抛出。</p></li><li><p>说说 final、finally、finalize 的区别？<br>答：<br>final 是 Java 中的关键字，可以用来修饰类、方法和变量。当一个类被声明为 final 时，它不能被继承；当一个方法被声明为 final 时，它不能被重写；当一个变量被声明为 final 时，它的值不能被修改。</p><p>finally 是 Java 中的关键字，用于定义一个代码块，无论是否发生异常，该代码块中的代码都会被执行。通常用于释放资源、关闭连接等操作。</p><p>finalize 是 Java 中的 Object 类中的一个方法，用于在对象被垃圾回收器回收之前执行一些清理操作。一般不建议在代码中显式调用该方法，而是让垃圾回收器自动调用。</p></li><li><p>如果不使用 try-catch，程序出现异常会如何？<br>答：<br>如果不使用 try-catch，程序出现异常会导致程序崩溃，并在控制台输出异常信息。这可能会导致数据丢失，影响程序的正常运行。使用 try-catch 可以捕获异常并进行处理，避免程序崩溃，保证程序的稳定性和可靠性。</p></li><li><p>try-catch 捕捉的是什么异常？<br>答：<br>try-catch 可以捕捉任何类型的异常，包括系统异常、运行时异常和自定义异常。</p></li><li><p>如果执行 finally 代码块之前方法返回了结果或者 jvm 退出了，这时 finally 块中的代码还会执行吗?<br>答：<br>如果方法返回了结果或者 JVM 退出了，finally 块中的代码也会执行。finally 块是用来确保在任何情况下都会执行特定的代码，无论是正常情况下还是出现异常的情况下。因此，即使方法返回了结果或者 JVM 退出了，finally 块中的代码也会被执行。</p><p>特别的，如果在方法中调用了 System.exit(0)，JVM 会立即退出，finally 块中的代码将不会执行。因为 System.exit(0)会直接终止 JVM，包括所有线程的执行，因此 finally 块中的代码也无法执行。</p></li><li><p>在 try 语句中有 return 语句，最后写 finally 语句，finally 语句中的的代码会不会执行？何时执行？如果执行是在 return 前还是后？<br>答：<br>在 try 语句中有 return 语句时，finally 语句中的代码一定会执行。finally 语句中的代码会在 return 语句执行之前执行。即使在 try 语句块中使用了 return 语句，finally 语句中的代码也会被执行，确保代码块中的资源被正确释放。</p></li><li><p>捕获异常在 catch 块里一定会进入 finally 吗？catch 里能 return 吗？catch 里 return 还会进 finally 吗？在 try 里 return 是什么情况？<br>答：<br>捕获异常在 catch 块里不一定会进入 finally，只有在 try 或 catch 块中有 return、throw 或异常抛出时，才会进入 finally 块。</p><p>catch 里可以 return，但是要注意在 return 之前可能需要释放资源或做一些清理工作。catch 里 return 不会进入 finally。</p><p>在 try 里 return 时，如果 try 块中的代码执行完毕并成功返回，则会直接跳出 try 块并返回值，不会进入 finally。但是如果 try 块中的代码抛出异常，则会先进入 catch 块，处理完异常后再进入 finally 块。</p></li><li><p>throw 和 throws 的区别？<br>答：<br>throw 和 throws 是 Java 中的关键字，用于异常处理。</p><p>throw 用于手动抛出一个异常，它通常用于方法体内部，用于抛出一个异常对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (somethingIsWrong)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"出了问题。"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果 somethingIsWrong 为 true，就会抛出一个 MyException 异常。</p><p>throws 则用于方法声明上，用于声明该方法可能会抛出哪些异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> MyException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 做一些可能引发MyException的事情</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的例子中，方法 method 可能会抛出一个 MyException 异常，因此在方法声明上使用了 throws 关键字。</p><p>总结：<br>throw 用于抛出一个异常对象，通常用于方法体内部。<br>throws 用于方法声明上，用于声明该方法可能会抛出哪些异常。</p></li><li><p>子类重写父类抛出异常的方法，能否抛出比父类更高级别的异常类?<br>答：<br>不可以。子类重写父类抛出异常的方法时，抛出的异常类必须是父类方法抛出异常类的子类或者相同的异常类。抛出更高级别的异常类会破坏异常处理机制的完整性，可能导致程序无法正常处理异常。</p></li><li><p>如何自定义一个异常？<br>答：<br>在 Java 中，我们可以通过继承 Exception 或 RuntimeException 来自定义一个异常类。其中，Exception 表示编译时异常，必须在方法声明中抛出或捕获处理；而 RuntimeException 表示运行时异常，可以不在方法声明中抛出或捕获处理。我们一般建议自定义异常类时继承 Exception。</p><p>自定义异常类需要满足以下要求：<br>① 继承 Exception 或 RuntimeException。<br>② 提供至少两个构造方法，一个是无参构造方法，一个是带有 String 参数的构造方法，用于传递异常信息。<br>③ 建议为异常类提供 serialVersionUID，用于序列化和反序列化操作。<br>下面是一个自定义异常类的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>使用自定义异常类时，可以在方法声明中抛出异常，并在方法体中使用 throw 语句抛出自定义异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> MyException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 做点什么</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"出了问题"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在调用该方法时，需要使用 try-catch 语句捕获该异常或继续向上抛出该异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        doSomething();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (MyException e)</span><br><span class="line">    {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol><h1>第 10 章 多线程</h1><h2 id="10-1-程序、进程与线程">10.1 程序、进程与线程</h2><p>程序(program)：为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码。</p><p>进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。</p><p>进程作为操作系统调度和分配资源的最小单位。</p><p>线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。</p><p>线程作为 CPU 调度和执行的最小单位。</p><p>线程调度策略：</p><ul><li>分时调度：所有线程轮流使用 CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。</li><li>抢占式调度：让优先级高的线程以较大的概率优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java 使用的为抢占式调度。</li></ul><p>单核 CPU 与多核 CPU。</p><p>并行与并发：</p><ul><li><p>并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个 CPU 上同时执行。比如：多个人同时做不同的事。</p><p><img src="https://img-blog.csdnimg.cn/8601636e5ae94f73b28ca4412856a6a8.png" alt="并行"></p></li><li><p>并发（concurrency）：指两个或多个事件在同一个时间段内发生。即在一段时间内，有多条指令在单个 CPU 上快速轮换、交替执行，使得在宏观上具有多个进程同<br>时执行的效果。</p><p><img src="https://img-blog.csdnimg.cn/0ac9b3bf09c24c9580d8ac0d11660f3b.png" alt="并发"></p></li></ul><h2 id="10-2-创建多线程">10.2 创建多线程</h2><h3 id="10-2-1-方式-1：继承-Thread-类">10.2.1 方式 1：继承 Thread 类</h3><p>Java 通过继承 Thread 类来创建并启动多线程。</p><p>步骤如下：<br>① 定义 Thread 类的子类，并重写该类的 run()方法，该 run()方法的方法体就代表了线程需要完成的任务。<br>② 创建 Thread 子类的实例，即创建了线程对象。<br>③ 调用线程对象的 start()方法来启动该线程。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 定义指定线程名称的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 调用父类的 String 参数的构造方法，指定线程的名称</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 run 方法，完成该线程执行的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyThread</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建自定义线程对象 1</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"子线程 1"</span>);</span><br><span class="line">        <span class="comment">// 开启子线程 1</span></span><br><span class="line">        mt1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建自定义线程对象 2</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"子线程 2"</span>);</span><br><span class="line">        <span class="comment">// 开启子线程 2</span></span><br><span class="line">        mt2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在主方法中执行 for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"main 线程！"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-2-2-方式-2：实现-Runnable-接口">10.2.2 方式 2：实现 Runnable 接口</h3><p>Java 有单继承的限制，当我们无法继承 Thread 类时，那么该如何做呢？在核心类库中提供了 Runnable 接口，我们可以实现 Runnable 接口，重写 run()方法，然后再通过 Thread 类的对象代理启动和执行我们的线程体 run()方法。</p><p>步骤如下：<br>① 定义 Runnable 接口的实现类，并重写该接口的 run()方法，该 run()方法的方法体同样是该线程的线程执行体。<br>② 创建 Runnable 实现类的实例，并以此实例作为 Thread 的 target 参数来创建 Thread 对象，该 Thread 对象才是真正 的线程对象。<br>③ 调用线程对象的 start()方法，启动线程。调用 Runnable 接口实现类的 run 方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyRunnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建自定义类对象，线程任务对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">"长江"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"黄河 "</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-2-3-方式-3：实现-Callable-接口-（jdk5-0-新增）">10.2.3 方式 3：实现 Callable 接口 （jdk5.0 新增）</h3><p>与使用 Runnable 相比， Callable 功能更强大些。</p><ul><li>相比 run()方法，可以有返回值。</li><li>方法可以抛出异常。</li><li>支持泛型的返回值（需要借助 FutureTask 类，获取返回结果）。</li></ul><p>Future 接口：</p><ul><li>可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等。</li><li>FutureTask 是 Futrue 接口的唯一的实现类。</li><li>FutureTask 同时实现了 Runnable, Future 接口。它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值</li></ul><p>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个实现 Callable 的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 2.实现 call 方法，将此线程需要执行的操作声明在 call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 3.创建 Callable 接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将此 Callable 接口实现类的对象作为传递到 FutureTask 构造器中，创建 FutureTask 的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收返回值</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 6.获取 Callable 中 call 方法的返回值</span></span><br><span class="line">            <span class="comment">// get()返回值即为 FutureTask 构造器参数 Callable 实现类重写的 call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"总和为："</span> + sum);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">        {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-2-4-方式-4：使用线程池（jdk5-0-新增）">10.2.4 方式 4：使用线程池（jdk5.0 新增）</h3><p>现有问题：</p><ul><li>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</li><li>那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</li></ul><p>思路：</p><ul><li>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li></ul><p><img src="https://img-blog.csdnimg.cn/d54a7c338aee4c129327b8deddec1e9e.png" alt="线程池"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录偶数的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                evenSum += i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> evenSum;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  {</span><br><span class="line">      <span class="comment">// 1. 提供指定线程数量的线程池</span></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">      <span class="type">ThreadPoolExecutor</span> <span class="variable">service2</span> <span class="operator">=</span> (ThreadPoolExecutor) service1;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置线程池的属性</span></span><br><span class="line">        <span class="comment">// 设置线程池中线程数的上限</span></span><br><span class="line">      service2.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接口实现类的对象</span></span><br><span class="line">      service1.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());    <span class="comment">// 适合适用于 Runnable</span></span><br><span class="line">      service1.execute(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());   <span class="comment">// 适合适用于 Runnable</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      {</span><br><span class="line">          <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service1.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());  <span class="comment">// 适合使用于 Callable</span></span><br><span class="line">          System.out.println(<span class="string">"总和为："</span> + future.get());</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">catch</span> (Exception e)</span><br><span class="line">      {</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.关闭连接池</span></span><br><span class="line">      service1.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="10-3-Thread-类的常用方法">10.3 Thread 类的常用方法</h2><h3 id="10-3-1-构造器">10.3.1 构造器</h3><ul><li>public Thread() :分配一个新的线程对象。</li><li>public Thread(String name) :分配一个指定名字的新的线程对象。</li><li>public Thread(Runnable target) :指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法。</li><li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</li></ul><h3 id="10-3-2-常用方法">10.3.2 常用方法</h3><ul><li>public void run() :此线程要执行的任务在此处定义代码。</li><li>public void start() :导致此线程开始执行; Java 虚拟机调用此线程的 run 方法。</li><li>public String getName() :获取当前线程名称。</li><li>public void setName(String name)：设置该线程名称。</li><li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。在 Thread 子类中就是 this，通常用于主线程和 Runnable 实现类。</li><li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li>public static void yield()：yield 只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了 yield 方法暂停之后，线程调度器又将其调度出来重新执行。</li><li>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。</li><li>void join() ：等待该线程终止。</li><li>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果 millis 时间到，将不再等待。</li><li>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</li><li>public final void stop()：已过时，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</li><li>void suspend() / void resume() : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用 resume()。已过时，不建议使用。</li><li>setDaemon(true)：调用 setDaemon(true)方法可将指定线程设置为守护线程。</li></ul><h3 id="10-3-3-线程的优先级">10.3.3. 线程的优先级</h3><ul><li><p>Thread 类内部声明的三个常量：</p><ul><li>MAX_PRIORITY（10）：最高优先级。</li><li>MIN _PRIORITY （1）：最低优先级。</li><li>NORM_PRIORITY （5）：普通优先级，默认情况下 main 线程具有普通优先级。</li></ul></li><li><p>getPriority():获取线程的优先级。</p></li><li><p>setPriority():设置线程的优先级，范围[1,10]。</p></li></ul><h2 id="10-4-多线程的生命周期">10.4 多线程的生命周期</h2><h3 id="10-4-1-jdk5-0-之前的线程的生命周期">10.4.1 jdk5.0 之前的线程的生命周期</h3><p>线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU 需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p><p><img src="https://img-blog.csdnimg.cn/14ec7337c6a449ff9aa85d7fb61aa840.png" alt="jdk5.0之前的线程的生命周期"></p><h3 id="10-4-2-jdk5-0-之后的线程的生命周期">10.4.2 jdk5.0 之后的线程的生命周期</h3><p>jdk5.0 及之后，Thread 类中定义了一个内部类 State。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span></span><br><span class="line">{</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9bcaae9f1b424ada9c7cc5a99d49500b.png" alt="jdk5.0之后的线程的生命周期"></p><h2 id="10-5-线程安全问题">10.5 线程安全问题</h2><p>什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。</p><h3 id="10-5-1-同步机制解决线程安全问题">10.5.1 同步机制解决线程安全问题</h3><p>要解决多线程并发访问一个资源的安全性问题，也就是解决重复票与不存在票问题，Java 中提供了同步机制 (synchronized)来解决。</p><h3 id="10-5-2-同步机制解决线程安全问题的原理">10.5.2 同步机制解决线程安全问题的原理</h3><p>同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。</p><p>因为 Java 对象在堆中的数据分为分为对象头、实例变量、空白的填充。</p><p>对象头中包含：</p><ul><li>Mark Word：记录了和当前对象有关的 GC、锁标记等信息。</li><li>指向类的指针：每一个对象需要记录它是由哪个类创建出来的。</li><li>数组长度（只有数组对象才有）。</li></ul><p>哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的 ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。</p><h3 id="10-5-3-同步代码块">10.5.3 同步代码块</h3><p>同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。</p><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步锁)</span><br><span class="line">{</span><br><span class="line">    需要同步操作的代码</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-5-4-同步方法">10.5.4 同步方法</h3><p>同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。</p><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()</span><br><span class="line">{</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="10-5-5-同步锁机制">10.5.5 同步锁机制</h3><ul><li><p>重点关注两个事：</p><ul><li>共享数据及操作共享数据的代码。</li><li>同步监视器，即同步锁要保证唯一性。</li></ul></li><li><p>在实现 Runnable 接口的方式中，同步监视器可以考虑使用：this。</p></li><li><p>在继承 Thread 类的方式中，同步监视器要慎用 this，可以考虑使用：当前类.class。</p></li><li><p>非静态的同步方法，默认同步监视器是 this</p></li><li><p>静态的同步方法，默认同步监视器是当前类本身。</p></li></ul><h3 id="10-5-6-Lock-锁（jdk5-0-新增）">10.5.6 Lock 锁（jdk5.0 新增）</h3><p>与采用 synchronized 相比，Lock 可提供多种锁方案，更灵活、更强大。Lock 通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当。</p><p>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。</p><p>在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释放锁。</p><ul><li>ReentrantLock 类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一<br>些特性。此外，它还提供了在激烈争用情况下更佳的性能。</li></ul><p>Lock 锁也称同步锁，加锁与释放锁方法，如下：</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockTest</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1. 创建 Lock 的实例，必须确保多个线程共享同一个 Lock 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 2. 调动 lock()，实现需共享的代码的锁定</span></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//保证线程安全的代码;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 3. 调用 unlock()，释放共享代码的锁定</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="10-6-同步机制相关的问题">10.6 同步机制相关的问题</h2><h3 id="10-6-1-单例设计模式的线程安全问题">10.6.1 单例设计模式的线程安全问题</h3><p>懒汉式单例模式的线程安全写法可以使用双重检查锁定（Double-Checked Locking）来实现。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// volatile关键字确保instance的可见性和顺序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">        <span class="comment">// 第一次检查，如果instance已经存在，则直接返回</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)</span><br><span class="line">            {</span><br><span class="line">            <span class="comment">// 加锁，确保只有一个线程进入临界区</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                {</span><br><span class="line">                  <span class="comment">// 第二次检查，防止多个线程同时进入第一次检查后的if语句块</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在以上代码中，使用了双重检查锁定来确保线程安全。第一次检查用于判断 instance 是否已经存在，如果已经存在，则直接返回；否则进入临界区加锁。在加锁后，再次检查 instance 是否已经存在，防止多个线程同时进入第一次检查后的 if 语句块。如果 instance 仍然为 null，则创建一个新的实例。最后，返回 instance。同时，使用 volatile 关键字确保 instance 的可见性和顺序性，避免由于指令重排而导致的线程安全问题。</p><h3 id="10-6-2-死锁">10.6.2 死锁</h3><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p><p>诱发死锁的原因：</p><ul><li>互斥条件。</li><li>占用且等待。</li><li>不可抢夺（或不可抢占）。</li><li>循环等待。</li><li>以上 4 个条件，同时出现就会触发死锁。</li></ul><p>解决死锁：<br>死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。</p><ul><li>针对条件 1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</li><li>针对条件 2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</li><li>针对条件 3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</li><li>针对条件 4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</li></ul><h2 id="10-7-线程间的通信">10.7 线程间的通信</h2><ul><li>在同步机制下，考虑线程间的通信。</li><li>wait()：<br>线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个特别的动作，也即“通知（notify）”或者等待时间到，在这个对象上等待的线程从 wait set 中释放出来，重新进入到调度队列（ready queue）中。</li><li>notify()：则选取所通知对象的 wait set 中的一个线程释放。</li><li>notifyAll()：则释放所通知对象的 wait set 上的全部线程。</li></ul><h2 id="10-8-生产者与消费者问题">10.8 生产者与消费者问题</h2><p>等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。</p><p>生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>生产者与消费者问题中其实隐含了两个问题：</p><ul><li>线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。</li><li>线程的协调工作问题： - 要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产<br>者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducerTest</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line"></span><br><span class="line">        p1.setName(<span class="string">"生产者 1"</span>);</span><br><span class="line">        c1.setName(<span class="string">"消费者 1"</span>);</span><br><span class="line">        c2.setName(<span class="string">"消费者 2"</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"=========生产者开始生产产品========"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                Thread.sleep(<span class="number">40</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 要求 clerk 去增加产品</span></span><br><span class="line">            clerk.addProduct();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"=========消费者开始消费产品========"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                Thread.sleep(<span class="number">90</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 要求 clerk 去减少产品</span></span><br><span class="line">            clerk.minusProduct();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productNum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRODUCT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRODUCT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (productNum &lt; MAX_PRODUCT)</span><br><span class="line">        {</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"生产了第"</span> + productNum + <span class="string">"个产品"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒消费者</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">minusProduct</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (productNum &gt;= MIN_PRODUCT)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"消费了第"</span> + productNum + <span class="string">"个产品"</span>);</span><br><span class="line">            productNum--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒生产者</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="10-9-企业真题">10.9 企业真题</h2><ol><li><p>什么是线程？<br>答：<br>线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位。一个进程可以包含多个线程，每个线程之间可以共享进程的资源，如内存、文件句柄等，同时也可以拥有自己的独立资源，如程序计数器、寄存器等。线程可以在同一进程内并发执行，提高了程序的运行效率。</p></li><li><p>线程和进程有什么区别？<br>答：<br>① 定义：进程是计算机中正在运行的一个程序，它拥有自己的内存空间和系统资源，而线程是进程中的一个执行单元，一个进程可以包含多个线程。<br>② 资源占用：进程拥有独立的内存空间和系统资源，而线程共享所属进程的资源，包括内存、文件等。<br>③ 并发性：进程之间相互独立，互不干扰，而线程之间共享进程的资源，需要通过同步机制来保证并发性。<br>④ 切换开销：进程间切换需要保存和恢复进程的上下文，开销较大，而线程间切换只需要保存和恢复线程的上下文，开销较小。<br>⑤ 安全性：由于线程共享进程的资源，如果一个线程出现问题，可能会影响到整个进程的稳定性和安全性，而进程之间相互独立，一个进程出现问题不会影响其他进程的运行。<br>⑥ 独立性：进程之间可以独立运行，可以实现分布式计算和多任务处理，而线程依赖于进程，不能独立运行。<br>综上所述，进程和线程都是计算机中实现多任务处理的重要概念，它们各自有自己的特点和优势，应根据实际需求选择合适的方式来实现多任务处理。</p></li><li><p>多线程使用场景？<br>答：<br>① 处理大量数据：使用多线程可以同时处理多个数据，提高数据处理的速度。<br>② 并发访问：多线程可以同时访问同一个资源，提高资源的利用效率。<br>③ 服务器端编程：服务器需要同时处理多个客户端请求，使用多线程可以提高服务器的并发处理能力。<br>④ 图形界面程序：图形界面程序需要同时处理多个用户输入事件，使用多线程可以提高程序的响应速度。<br>⑤ 大规模计算：使用多线程可以同时进行多个计算任务，提高计算的效率。<br>⑥ 多媒体处理：多媒体处理需要同时进行多个任务，使用多线程可以提高处理速度。<br>⑦ 游戏开发：游戏需要同时处理多个角色的动作，使用多线程可以提高游戏的流畅度和响应速度。<br>⑧ 数据库操作：数据库需要同时处理多个查询和更新请求，使用多线程可以提高数据库的并发处理能力。</p></li><li><p>如何在 Java 中出实现多线程？<br>答：<br>① 继承 Thread 类并重写 run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>② 实现 Runnable 接口并重写 run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>③ 实现 Callable 接口并重写 call()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="type">MyCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br></pre></td></tr></table></figure><p>④ 使用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池，其中包含5个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交10个任务给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 定义一个任务类，实现Runnable接口</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">private</span> <span class="type">int</span> taskId;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> taskId)</span></span><br><span class="line">          {</span><br><span class="line">              <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">          {</span><br><span class="line">              System.out.println(<span class="string">"任务 "</span> + taskId + <span class="string">" 正在线程中运行。 "</span> + Thread.currentThread().getName());</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>Thread 类中的 start()和 run()有什么区别？<br>答：<br>start()方法用于启动一个新的线程，而 run()方法只是普通的方法调用。当调用 start()方法时，系统会创建一个新的线程，并在该线程中执行 run()方法。如果直接调用 run()方法，那么该方法就会在当前线程中执行，不会创建新的线程。因此，如果想要实现多线程，必须使用 start()方法来启动新线程，而不是直接调用 run()方法。</p></li><li><p>启动一个线程是用 run()还是 start()?<br>答：<br>启动一个线程应该使用 start()方法，而不是直接调用 run()方法。因为直接调用 run()方法不会创建一个新的线程，而只是在当前线程中执行 run()方法的代码。而使用 start()方法会创建一个新的线程并在新线程中执行 run()方法的代码。这样可以避免阻塞当前线程的执行，提高程序的并发性能。</p></li><li><p>Java 中 Runnable 和 Callable 有什么不同？<br>答：<br>在 Java 中，Runnable 和 Callable 都是用来实现多线程的接口，但是它们有以下不同点：<br>① 返回值类型不同：Runnable 的 run()方法没有返回值，而 Callable 的 call()方法有返回值。<br>② 异常处理不同：Runnable 的 run()方法不能抛出 checked exception，但是 Callable 的 call()方法可以抛出 checked exception，需要在调用时进行处理。<br>③ 使用方式不同：Runnable 接口通常用于执行一些没有返回值的简单任务，而 Callable 接口通常用于执行一些有返回值的复杂任务，例如计算、查询等。<br>④ 使用线程池时不同：如果使用线程池来执行任务，Runnable 可以直接提交给线程池执行，但是 Callable 需要使用 Future 来获取返回值。</p><p>总之，Runnable 和 Callable 都是用来实现多线程的接口，但是它们的使用方式和作用略有不同。</p></li><li><p>什么是线程池，为什么要使用它？<br>答：<br>线程池是一种管理和复用线程的机制，它可以在应用程序中预先创建一定数量的线程，并将这些线程放入一个池中，当需要执行任务时，从线程池中取出一个线程来执行任务，任务执行完毕后，该线程不被销毁，而是返回线程池等待下一次任务的到来。</p><p>使用线程池的好处在于：<br>① 减少线程的创建和销毁次数，避免频繁创建和销毁线程对系统资源的消耗。<br>② 提高线程的复用率，使线程可以被重复利用，减少线程的阻塞等待时间。<br>③ 控制线程的数量，避免线程数量过多导致系统资源的浪费和线程调度的开销。<br>④ 提高系统的稳定性和可靠性，避免线程的崩溃和异常对系统的影响。<br>⑤ 提高程序的响应速度和吞吐量，提高程序的并发能力。</p></li><li><p>sleep() 和 yield()区别？<br>答：<br>sleep()和 yield()都是线程控制的方法，但它们的作用不同。<br>① sleep()会让当前线程进入阻塞状态，让出 CPU，不参与调度，直到休眠时间结束或被中断才会继续执行。sleep()方法是静态方法，可以通过 Thread 类直接调用。<br>② yield()会让当前线程让出 CPU，但是不会进入阻塞状态，而是重新回到就绪状态，等待线程调度器再次调度。yield()方法也是静态方法，可以通过 Thread 类直接调用。</p><p>因此，sleep()和 yield()的区别在于 sleep()会让线程进入阻塞状态，而 yield()则不会。另外，sleep()方法可以指定休眠的时间，而 yield()方法则不可以。</p></li><li><p>线程创建的中的方法、属性？<br>答：<br>线程创建时可以指定以下方法和属性：</p><p>方法：<br>① start()：启动线程。<br>② run()：线程的执行体，需要自行实现。<br>③ join()：等待线程执行完毕。<br>④ interrupt()：中断线程。</p><p>属性：<br>① name：线程名字。<br>② daemon：是否为守护线程。<br>③ priority：线程优先级。<br>④ isAlive()：线程是否处于活动状态。<br>⑤ isDaemon()：线程是否为守护线程。<br>⑥ isInterrupted()：线程是否被中断。</p></li><li><p>线程的生命周期？<br>答：<br>Java 中线程的生命周期包括以下五个状态：<br>① 新建状态（New）：当线程对象被创建时，它处于新建状态。此时，线程还没有开始执行，也没有分配到系统资源。<br>② 就绪状态（Runnable）：当线程调用 start()方法后，它进入就绪状态。此时，线程已经分配到了系统资源，但还没有开始执行。处于就绪状态的线程会等待 CPU 时间片的分配。<br>③ 运行状态（Running）：当线程获得 CPU 时间片后，它进入运行状态。此时，线程开始执行 run()方法中的代码。<br>④ 阻塞状态（Blocked）：线程在等待某个条件的时候，可能会进入阻塞状态。比如，线程在等待获取锁时，如果锁已经被其他线程占用，则该线程会进入阻塞状态。<br>⑤ 终止状态（Terminated）：当线程执行完 run()方法中的代码后，它就进入了终止状态。此时，线程已经完成了它的任务，不再占用系统资源。</p></li><li><p>线程的基本状态以及状态之间的关系？<br>答：<br>线程有五种基本状态：<br>① 新建状态（New）：当线程对象被创建时，它处于新建状态。<br>② 就绪状态（Runnable）：当线程被启动后，它进入就绪状态，等待系统调度它运行。<br>③ 运行状态（Running）：当线程被系统调度后，它进入运行状态，开始执行任务。<br>④ 阻塞状态（Blocked）：当线程因为某些原因无法运行时，它进入阻塞状态。<br>⑤ 终止状态（Terminated）：当线程执行完任务后，或者因为异常或其他原因被强制终止时，它进入终止状态。</p><p>线程状态之间的关系如下：<br>① 新建状态可以转化为就绪状态。<br>② 就绪状态可以转化为运行状态。<br>③ 运行状态可以转化为就绪状态或阻塞状态。<br>④ 阻塞状态可以转化为就绪状态。<br>⑤ 运行状态或阻塞状态可以转化为终止状态。</p></li><li><p>stop()和 suspend()方法为何不推荐使用？<br>答：<br>stop()方法会立即停止线程，可能会导致线程资源无法释放，造成死锁或者数据不一致等问题，因此不推荐使用。</p><p>suspend()方法会暂停线程，但是不会释放线程占用的资源，如果在暂停期间其他线程需要使用该资源，就会发生死锁等问题，因此也不推荐使用。同时，suspend()方法还可能导致线程状态不可预测，无法保证线程的正确性。</p></li><li><p>Java 线程优先级是怎么定义的？<br>答：<br>Java 线程优先级是通过整数来定义的，范围从 1 到 10。默认情况下，所有线程都具有相同的优先级，即 NORM_PRIORITY（5）。较高的优先级使线程更有可能在竞争资源时获得 CPU 时间，但不能保证高优先级的线程总是优先于低优先级的线程。线程优先级的设置可以使用 Thread 类的 setPriority()方法进行设置。</p></li><li><p>你如何理解线程安全的？线程安全问题是如何造成的？<br>答：<br>线程安全是指当多个线程同时访问同一个共享资源时，不会出现任何意外的结果，即程序执行的结果与单线程执行的结果是一致的。线程安全问题通常是由于多个线程同时访问同一个共享资源时，对该资源的读写操作没有得到正确的同步处理所导致的，例如在并发环境下访问同一个全局变量、共享缓存、共享文件等。这样可能会导致数据不一致、死锁、竞态条件等问题，从而影响程序的正确性和稳定性。为了解决线程安全问题，常见的做法是使用锁、信号量、原子操作等同步机制来保证多个线程对共享资源的访问是有序的，从而避免出现竞争条件和数据不一致的问题。</p></li><li><p>多线程共用一个数据变量需要注意什么？<br>答：<br>① 线程安全：多线程共用一个数据变量时，需要确保数据的安全性，即线程之间不能互相干扰或破坏数据。<br>② 同步机制：为了保证数据的正确性，需要使用同步机制，例如锁、信号量等，确保同一时间只有一个线程能够访问数据变量。<br>③ 内存可见性：多线程共用一个数据变量时，需要确保数据的内存可见性，即当一个线程修改了数据变量时，其他线程能够及时看到这个变化。<br>④ 死锁问题：当多个线程同时需要访问多个共用的数据变量时，可能会出现死锁问题。因此需要避免多个线程同时访问多个共用的数据变量。<br>⑤ 性能问题：多线程共用一个数据变量时，需要考虑线程之间的调度和竞争问题，以及锁的开销等因素，确保程序的性能。</p></li><li><p>多线程保证线程安全一般有几种方式？<br>答：<br>Java 多线程保证线程安全一般有以下几种方式：<br>① 同步代码块：使用 synchronized 关键字来同步代码块，使得多个线程在执行该代码块时只能有一个线程执行。<br>② 同步方法：将需要同步的方法声明为 synchronized 方法，同一时间只能有一个线程执行该方法。<br>③ Lock 锁：使用 Lock 接口提供的 lock()和 unlock()方法来实现同步，相比于 synchronized 关键字，Lock 锁提供了更灵活的同步方式。<br>④ volatile 关键字：使用 volatile 关键字来保证变量的可见性和禁止指令重排，从而保证多线程环境下变量的正确性。<br>⑤ 原子类：使用 Java 提供的原子类来保证操作的原子性，如 AtomicInteger、AtomicLong 等。<br>⑥ ThreadLocal 类：使用 ThreadLocal 类来实现线程本地变量，保证每个线程都有自己的变量副本，从而避免并发访问问题。<br>⑦ 并发容器：Java 提供了许多线程安全的容器类，如 ConcurrentHashMap、ConcurrentLinkedQueue 等，可以直接使用这些容器类来避免并发访问问题。</p></li><li><p>用什么关键字修饰同步方法?<br>答：<br>Java 中，可以使用 synchronized 关键字修饰同步方法。</p></li><li><p>synchronized 加载静态方法和普通方法区别？<br>答：<br>在 Java 中，synchronized 关键字可以用于修饰静态方法和普通方法，但它们之间有一些区别。</p><p>对于静态方法，同步锁是当前类的 Class 对象。而对于普通方法，同步锁是当前实例对象。因此，如果一个线程访问一个静态 synchronized 方法，那么其他线程将不能访问该类的任何其他静态 synchronized 方法，但是可以访问该类的非静态 synchronized 方法。而如果一个线程访问一个非静态 synchronized 方法，那么其他线程将不能访问该实例的其他非静态 synchronized 方法，但是可以访问该类的所有静态 synchronized 方法。</p><p>因此，不同的方法使用不同的同步监视器，这是它们之间的区别。静态方法使用类的 Class 对象作为同步监视器，而普通方法使用实例对象作为同步监视器。</p></li><li><p>Java 中 synchronized 和 ReentrantLock 有什么不同？<br>答：<br>synchronized 和 ReentrantLock 都是用于实现线程同步的机制，但它们有以下不同：<br>① 性能：ReentrantLock 性能比 synchronized 更好，因为它是基于 CAS (Compare and Swap) 实现的，而 synchronized 是基于 JVM 实现的。在高并发情况下，ReentrantLock 的性能优势更加明显。<br>② 可中断性：ReentrantLock 具有可中断性，即当一个线程正在等待获取锁时，可以通过调用 lockInterruptibly() 方法来让该线程中断等待，而 synchronized 没有这个特性。<br>③ 公平锁：ReentrantLock 可以是公平锁，即按照等待时间的先后顺序来获取锁，而 synchronized 只能是非公平锁。<br>④ 可重入性：synchronized 是可重入锁，即线程可以重复获取已经持有的锁，而 ReentrantLock 也是可重入锁。<br>⑤ 等待可中断：ReentrantLock 可以设置等待获取锁的超时时间，而 synchronized 没有这个特性。<br>⑥ 条件锁：ReentrantLock 可以通过 Condition 接口来实现条件锁，即只有满足某个条件时才能获取锁，而 synchronized 没有这个特性。</p><p>综上所述，ReentrantLock 相对于 synchronized 更加灵活和强大，但使用起来也更加复杂，需要手动释放锁和处理异常等问题。在需要高并发性能和更多功能的场景下，可以选择使用 ReentrantLock。</p></li><li><p>当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?<br>答：<br>当一个线程进入一个对象的一个 synchronized 方法后，其它线程无法进入此对象的其他 synchronized 方法，因为它们都需要获取同步监视器（也称为锁）才能执行。同步监视器是对象级别的，因此当一个线程持有同步监视器时，其他线程无法获得该监视器。但是，非 synchronized 方法不需要获取同步监视器，因此可以在同一时间被多个线程并发调用。</p></li><li><p>线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？<br>答：<br>线程同步和阻塞是两个概念，它们之间有关联，但并不一定相互依存。</p><p>线程同步是指多个线程在执行过程中，需要协调和同步彼此的操作，以保证数据的正确性和程序的正确性。线程同步可以通过使用锁、信号量等机制来实现。</p><p>阻塞是指线程在执行过程中被暂停，等待某些条件的满足后再继续执行。线程阻塞可以是由于等待某个资源的可用性，或者等待某个操作的完成等原因导致的。</p><p>同步和阻塞之间有关系，因为在进行线程同步的过程中，可能会需要对某些资源进行加锁，这样其他线程就不能访问该资源，从而导致其他线程阻塞。但是同步和阻塞并不一定相互依存，同步操作不一定会导致阻塞，阻塞操作也不一定需要同步。</p><p>例如，线程间的消息传递机制可以实现同步操作，但是不需要阻塞。而单线程中的阻塞操作，也不需要同步。因此，同步和阻塞是两个概念，需要根据具体的场景来进行选择和使用。</p></li><li><p>什么是死锁，产生死锁的原因及必要条件？<br>答：<br>死锁是多个进程或线程在互相等待对方释放资源而陷入无限等待的一种状态。这种状态下，每个进程或线程都在等待其他进程或线程释放资源，而不能继续执行下去。</p><p>死锁产生的原因通常有以下几种：<br>① 资源竞争：多个进程或线程争夺有限的资源，如磁盘、内存等，当某个进程或线程持有一部分资源而又需要其他资源时，就会造成死锁。<br>② 进程或线程的顺序不当：当多个进程或线程按照不同的顺序请求资源时，也容易产生死锁。<br>③ 资源分配不当：当系统分配资源不当时，也会导致死锁的产生。</p><p>死锁产生的必要条件有以下四个：<br>① 互斥条件：至少有一个资源必须处于非共享模式，即一次只能被一个进程或线程使用。<br>② 占有和等待条件：一个进程或线程必须占有至少一个资源，并等待其他进程或线程释放所需的资源。<br>③ 非抢占条件：资源不能被抢占，只能由占有资源的进程或线程显式地释放。<br>④ 循环等待条件：多个进程或线程形成一个循环等待资源的环路。</p></li><li><p>如何避免死锁？<br>答：<br>死锁是指两个或多个进程在执行过程中因争夺资源而产生的一种僵局，彼此都在等待对方先释放资源而无法继续执行下去。以下是避免死锁的几种方法：<br>① 避免资源竞争：尽量避免多个进程同时竞争同一资源，可以通过资源分配策略、资源复制等方式来实现。<br>② 避免持有和等待：一个进程不能持有某个资源并等待另一个进程占用的资源，可以通过一次性获取所有需要的资源来避免此情况。<br>③ 避免循环等待：多个进程之间不能形成循环等待资源的关系，可以通过给资源编号，按照一定顺序申请资源来避免。<br>④ 破坏资源占用和等待条件：通过限制进程的最大资源需求量、强制进程释放已占用的资源等方式来破坏资源占用和等待条件。<br>⑤ 破坏进程等待条件：通过限制进程等待时间、强制进程放弃等待的资源等方式来破坏进程等待条件。<br>总之，避免死锁需要综合考虑多种因素，采用合适的方法来解决问题。</p></li><li><p>Java 中 notify()和 notifyAll()有什么区别？<br>答：<br>notify()和 notifyAll()都是用于线程间通信的方法，它们的主要区别在于：<br>① notify()只会唤醒等待队列中的一个线程，而 notifyAll()会唤醒等待队列中的所有线程。<br>② notify()是随机唤醒等待队列中的一个线程，而 notifyAll()会唤醒所有等待队列中的线程，让它们去竞争锁。</p><p>因此，如果你想唤醒所有等待队列中的线程，可以使用 notifyAll()；如果你只想唤醒一个线程，可以使用 notify()。但是需要注意的是，notify()可能会导致某些线程一直等待下去，因为它只唤醒一个线程，如果唤醒的是不需要的线程，那么这个线程就会一直等待下去，而 notifyAll()则不会有这个问题。</p></li><li><p>为什么 wait()和 notify()方法要在同步块中调用？<br>答：<br>wait()和 notify()方法需要在同步块（synchronized block）中调用，主要是因为它们都需要获取对象的监视器（monitor）才能执行。监视器是 Java 中的一种内部锁机制，用于控制并发访问。在同步块中，线程可以获取对象的监视器，从而保证对共享资源的访问是同步的。</p><p>具体来说，wait()方法会释放对象的监视器，让其他线程可以获取并修改共享资源。notify()方法会通知等待在对象上的一个线程，让其重新竞争该对象的监视器。如果这些方法不在同步块中调用，就可能会导致多个线程同时竞争对象的监视器，从而破坏同步性和线程安全性。</p><p>因此，为了保证线程安全和同步性，wait()和 notify()方法必须在同步块中调用，以确保线程能够正确获取和释放对象的监视器。</p></li><li><p>多线程中生产者消费者代码（同步、wait、notifly 编程）？<br>答：<br>以下是一个使用同步、wait 和 notify 编程的生产者消费者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建一个空的列表用于存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 定义列表的最大长度为 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 同步代码块，确保线程安全</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.size() == maxSize)</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">// 如果列表已经达到最大长度</span></span><br><span class="line">                wait();    <span class="comment">// 线程进入等待状态</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);    <span class="comment">// 生成一个随机数</span></span><br><span class="line"></span><br><span class="line">            buffer.add(num);    <span class="comment">// 将随机数添加到列表中</span></span><br><span class="line">            System.out.println(<span class="string">"Produced: "</span> + num);    <span class="comment">// 输出生产的数据</span></span><br><span class="line"></span><br><span class="line">            notify(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 同步代码块，确保线程安全</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.size() == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">// 如果列表为空</span></span><br><span class="line">                wait();    <span class="comment">// 线程进入等待状态</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> buffer.remove(<span class="number">0</span>);    <span class="comment">// 从列表中删除第一个元素</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Consumed: "</span> + num);    <span class="comment">// 输出消费的数据</span></span><br><span class="line"></span><br><span class="line">            notify();    <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">ProducerConsumer</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConsumer</span>();    <span class="comment">// 创建一个生产者消费者对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 创建一个用于生产数据的线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                      <span class="comment">// 一直循环</span></span><br><span class="line">                        pc.produce();    <span class="comment">// 生产数据</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);    <span class="comment">// 线程休眠1秒</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 创建一个用于消费数据的线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                      <span class="comment">// 一直循环</span></span><br><span class="line">                        pc.consume();    <span class="comment">// 消费数据</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);    <span class="comment">// 线程休眠1秒</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        t1.start();    <span class="comment">// 启动生产数据的线程</span></span><br><span class="line">        t2.start();    <span class="comment">// 启动消费数据的线程</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>在这个示例中，生产者和消费者都在同一个类中实现。buffer 是一个用于存储数据的列表，maxSize 是列表的最大长度。produce()和 consume()方法都使用 synchronized 关键字来保证线程安全。在 produce()方法中，如果 buffer 已经达到最大长度，则线程会进入等待状态，直到有其他线程调用 notify()方法唤醒它。然后，它会生成一个随机数并将其添加到 buffer 中。在 consume()方法中，如果 buffer 为空，则线程会进入等待状态，直到有其他线程调用 notify()方法唤醒它。然后，它会从 buffer 中删除第一个元素。</p><p>在 main()方法中，我们创建了两个线程，一个用于生产数据，另一个用于消费数据。这两个线程会一直运行，直到程序被终止。</p></li><li><p>wait()和 sleep()有什么区别？调用这两个函数后，线程状态分别作何改变？<br>答：<br>wait()和 sleep()在 Java 中都是用于线程的暂停，但是它们的用途和行为是不同的。</p><p>wait()是 Object 类的方法，用于线程间的协调。调用 wait()方法的线程会释放对象锁并进入等待状态，直到其他线程调用对象的 notify()或 notifyAll()方法来唤醒它。调用 wait()方法后，线程状态变为 WAITING。</p><p>sleep()是 Thread 类的方法，用于让线程暂停一段时间。调用 sleep()方法后，线程会进入阻塞状态，并且不会释放对象锁。sleep()方法会让线程休眠指定的时间，然后自动唤醒线程。调用 sleep()方法后，线程状态变为 TIMED_WAITING。</p><p>综上所述，wait()和 sleep()的区别在于它们的用途和行为，调用后线程的状态也不同。wait()用于线程间的协调，调用后线程状态变为 WAITING；sleep()用于让线程暂停一段时间，调用后线程状态变为 TIMED_WAITING。</p></li><li><p>手写一个线程安全的单例模式(Singleton)。<br>答：<br>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>安全的懒汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上三种方式都是线程安全的单例模式，其中饿汉式在类加载时就创建了实例，安全的懒汉式使用了 synchronized 关键字来保证线程安全，而内部类则利用了类加载的线程安全性来保证单例。</p></li><li><p>手写一个懒汉式的单例模式，解决其线程安全问题，并且说明为什么这样子去解决？<br>答：<br>懒汉式单例模式指的是在需要使用实例时才去创建实例，而不是在类加载时就创建实例。线程安全问题是因为多个线程同时访问时可能会创建多个实例，导致不符合单例模式的定义。</p><p>为了解决线程安全问题，可以使用 synchronized 关键字来实现同步锁，保证在多线程环境下只会创建一个实例。</p><p>以下是手写的懒汉式单例模式代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在 getInstance 方法上添加 synchronized 关键字，保证在多线程环境下只有一个线程可以进入创建实例的代码块，从而避免创建多个实例的问题。</p><p>这样子去解决的原因是因为 synchronized 关键字可以保证在同一时刻只有一个线程可以进入同步代码块，其它线程需要等待该线程执行完毕后才能进入。这样可以保证在多线程环境下只会创建一个实例，从而解决了线程安全问题。</p></li></ol><h1>第 11 章 常用类与基础 API</h1><h2 id="11-1-String-类">11.1 String 类</h2><h3 id="11-1-1-String-的特性">11.1.1 String 的特性</h3><ul><li>java.lang.String 类代表字符串。Java 程序中所有的字符串文字（例如"hello" ）都可以看作是实现此类的实例。</li><li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li><li>字符串 String 类型本身是 final 声明的，意味着我们不能继承 String。</li><li>String 对象的字符内容是存储在一个字符数组 value[]中的。“hello” 等效于 char[] data={‘h’,‘e’,‘l’,‘l’,‘o’}。</li><li>String 的两种定义方式：<br>① 字面量的定义方式 String s = “hello”<br>② new 的方式：String s = new String(“hello”);</li><li>Java 语言提供对字符串串联符号（“+”）以及将其他对象转换为字符串的特殊支持（toString()方法）。</li></ul><h3 id="11-1-2-String-的内存解析">11.1.2 String 的内存解析</h3><p>字符串常量池、堆内存。</p><p><img src="https://img-blog.csdnimg.cn/fbc5240ed9904c88bf5da8e4de62ccfc.png" alt="String的内存解析"></p><h3 id="11-1-3-String-的常用-API">11.1.3 String 的常用 API</h3><ul><li><p>构造器</p><ul><li>public String() ：初始化新创建的 String 对象，以使其表示空字符序列。</li><li>String(String original)： 初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li><li>public String(char[] value) ：通过当前参数中的字符数组来构造新的 String。</li><li>public String(char[] value,int offset, int count) ：通过字符数组的一部分来构造新的 String。</li><li>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。</li><li>public String(byte[] bytes,String charsetName) ：通过使用指定的字符集解码当前参数中的字节数组来构造新的 String。</li></ul></li><li><p>String 与其他结构之间的转换</p><ul><li>字符串 ——&gt; 基本数据类型、包装类：<ul><li>Integer 包装类的 public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li><li>类似地，使用 java.lang 包中的 Byte、Short、Long、Float、Double 类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li></ul></li><li>基本数据类型、包装类 ——&gt; 字符串： - 调用 String 类的 public String valueOf(int n)可将 int 型转换为字符串。 - 相应的 valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、<br>valueOf(boolean b)可由参数的相应类型到字符串的转换。</li><li>字符数组 ——&gt; 字符串： - String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字<br>符数组中的全部字符和部分字符创建字符串对象。</li><li>字符串 ——&gt; 字符数组：<ul><li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</li><li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</li></ul></li><li>字符串 ——&gt; 字节数组：（编码）<ul><li>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li></ul></li><li>字节数组 ——&gt; 字符串：（解码）<ul><li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置 offset 开始取 length 个字节构造一个字符串对象。</li><li>String(byte[], String charsetName ) 或 new String(byte[], int, int,String charsetName )：解码，按照指定的编码方式进行解码。</li></ul></li></ul></li><li><p>常用方法</p><ul><li>boolean isEmpty()：字符串是否为空。</li><li>int length()：返回字符串的长<br>度。</li><li>String concat(xx)：拼接。</li><li>boolean equals(Object obj)：比较字符串是否相等，区分大小写。</li><li>boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写。</li><li>int compareTo(String other)：比较字符串<br>大小，区分大小写，按照 Unicode 编码值比较大小。</li><li>int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写 。</li><li>String toLowerCase()：将字符串中大写字母转为小写。</li><li>StringtoUpperCase()：将字符串中小写字母转为大写。</li><li>String trim()：去掉字符串前后空白符。</li><li>public String intern()：结果在常量池中共享。</li></ul></li><li><p>查找</p><ul><li>boolean contains(xx)：是否包含 xx。</li><li>int indexOf(xx)：从前往后找当前字符串中 xx，即如果有返回第一次出现的下标，要是没有返回-1。</li><li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</li><li>int lastIndexOf(xx)：从后往前找当前字符串中 xx，即如果有返回最后一次出现的下标，要是没有返回-1。</li><li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li></ul></li><li><p>字符串截取</p><ul><li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串。</li><li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从 beginIndex<br>开始截取到 endIndex(不包含)的一个子字符串。</li></ul></li><li><p>和字符、字符数组相关</p><ul><li>char charAt(index)：返回[index]位置的字符。</li><li>char[] toCharArray()： 将此字符串转换为一个新的字符数组返回。</li><li>static String valueOf(char[] data) ：返回指定数组中表示该字符序列的 String。</li><li>static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String。</li><li>static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String。</li><li>static String copyValueOf(char[] data, int<br>offset, int count)：返回指定数组中表示该字符序列的 String。</li></ul></li><li><p>开头与结尾</p><ul><li>boolean startsWith(xx)：测试此字符串是否以指定的前缀开始。</li><li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</li><li>boolean endsWith(xx)：测试此字符串是否以指定的后缀结束。</li></ul></li><li><p>替换</p><ul><li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。</li><li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</li><li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</li><li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li></ul></li></ul><h2 id="11-2-StringBuffer、StringBuilder-类">11.2 StringBuffer、StringBuilder 类</h2><p>因为 String 对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK 又在 java.lang 包提供了可变字符序列 StringBuffer 和 StringBuilder 类型。</p><p>区分 String、StringBuffer、StringBuilder</p><ul><li>String:不可变的字符序列； 底层使用 char[]数组存储。(JDK8.0)</li><li>StringBuffer:可变的字符序列；线程安全（方法有 synchronized 修饰），效率低；底层使用 char[]数组存储 。(JDK8.0)</li><li>StringBuilder:可变的字符序列； jdk1.5 引入，线程不安全的，效率高；底层使用 char[]数组存储。(JDK8.0)</li></ul><h2 id="11-3-jdk8-之前的日期、时间-API">11.3 jdk8 之前的日期、时间 API</h2><h3 id="11-3-1-java-lang-System-类的日期、时间-API">11.3.1 java.lang.System 类的日期、时间 API</h3><p>System 类提供的 public static long currentTimeMillis()：用来返回当前时间与 1970 年 1 月 1 日 0 时 0 分 0 秒之间以毫秒为单位的时间差。</p><ul><li>此方法适于计算时间差。</li></ul><h3 id="11-3-2-java-util-Date-类的日期、时间-API">11.3.2 java.util.Date 类的日期、时间 API</h3><p>表示特定的瞬间，精确到毫秒。</p><ul><li><p>构造器</p><ul><li>Date()：使用无参构造器创建的对象可以获取本地当前时间。</li><li>Date(long 毫秒数)：把该毫秒值换算成日期时间对象。</li></ul></li><li><p>常用方法</p><ul><li>getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li><li>toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz 是时间标准。</li></ul></li></ul><h3 id="11-3-3-java-text-SimpleDateFormat">11.3.3 java.text.SimpleDateFormat</h3><ul><li><p>java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p></li><li><p>可以进行格式化：日期 ——&gt; 文本。</p></li><li><p>可以进行解析：文本 ——&gt; 日期。</p></li><li><p>构造器</p><ul><li>SimpleDateFormat() ：默认的模式和语言环境创建对象。</li><li>public SimpleDateFormat(String pattern)：该构造方法可以用参数 pattern 指定的格式创建一个对象。</li></ul></li><li><p>格式化</p><ul><li>public String format(Date date)：方法格式化时间对象 date。</li></ul></li><li><p>解析</p><ul><li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。</li></ul></li></ul><h3 id="11-3-4-java-util-Calendar-日历">11.3.4 java.util.Calendar(日历)</h3><ul><li><p>Calendar 类是一个抽象类，主用用于完成日期字段之间相互操作的功能。</p></li><li><p>获取 Calendar 实例的方法</p><ul><li>使用 Calendar.getInstance()方法。</li><li>调用它的子类 GregorianCalendar（公历）的构造器。</li></ul></li><li><p>一个 Calendar 的实例是系统时间的抽象表示，可以修改或获取 YEAR、MONTH、DAYOFWEEK、HOUROFDAY 、MINUTE、SECOND 等日历字段对应的时间值。</p><ul><li>public int get(int field)：返回给定日历字段的值。</li><li>public void set(int field,int value) ：将给定的日历字段设置为指定的值。</li><li>public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量。</li><li>public final Date getTime()：将 Calendar 转成 Date 对象。</li><li>public final void setTime(Date date)：使用指定的 Date 对象重置 Calendar 的时间。</li></ul></li></ul><h2 id="11-4-jdk8-中新的日期、时间-API">11.4 jdk8 中新的日期、时间 API</h2><h3 id="11-4-1-本地日期时间：LocalDate、LocalTime、LocalDateTime">11.4.1 本地日期时间：LocalDate、LocalTime、LocalDateTime</h3><p><img src="https://img-blog.csdnimg.cn/7c62f672b3a34ea79b8b8bb514c576ca.png" alt="LocalDate、LocalTime、LocalDateTime"></p><p><img src="https://img-blog.csdnimg.cn/6811ade5091643a1b0c293a1e639351a.png" alt="LocalDate、LocalTime、LocalDateTime"></p><ul><li>LocalDate、LocalTime、LocalDateTime ——&gt;类似于 Calendar。</li></ul><h3 id="11-4-2-瞬时：Instant">11.4.2 瞬时：Instant</h3><p>• Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。<br><img src="https://img-blog.csdnimg.cn/5355e0d615414a7085bb8a13ed115673.png" alt="Instant"></p><p><img src="https://img-blog.csdnimg.cn/baff2f8f6cee47b4848a6981c314b7a7.png" alt="Instant"></p><ul><li>Instant ——&gt;类似于 Date。</li></ul><h3 id="11-4-3-日期时间格式化：DateTimeFormatter">11.4.3 日期时间格式化：DateTimeFormatter</h3><p><img src="https://img-blog.csdnimg.cn/f4f610bf29964394818763898f2fd616.png" alt="DateTimeFormatter"></p><p><img src="https://img-blog.csdnimg.cn/be4d2b2230b94f808a3bba2217378b49.png" alt="DateTimeFormatter"></p><ul><li>DateTimeFormatter ——&gt;类似于 SimpleDateFormat。</li></ul><h2 id="11-5-比较器">11.5 比较器</h2><p>在 Java 中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</p><p>Java 实现对象排序的方式有两种：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><h3 id="11-5-1-自然排序：java-lang-Comparable">11.5.1 自然排序：java.lang.Comparable</h3><p>Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</p><p>实现 Comparable 的类必须实现 compareTo(Object obj)方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象 obj，则返回正整数，如果当前对象 this 小于形参对象 obj，则返回负整数，如果当前对象 this 等于形参对象 obj，则返回零。</p><h3 id="11-5-2-定制排序：java-util-Comparator">11.5.2 定制排序：java.util.Comparator</h3><p>思考：</p><ul><li>当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码。（例如：一些第三方的类，你只有.class 文件，没有源文件）</li><li>如果一个类，实现了 Comparable 接口，也指定了两个对象的比较大小的<br>规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</li></ul><p>JDK 在设计类库之初，也考虑到这种情况，所以又增加了一个 java.util.Comparator 接口。强行对多个对象进行整体排序的比较。</p><ul><li>重写 compare(Object o1,Object o2)方法，比较 o1 和 o2 的大小：如果方法返回正整数，则表示 o1 大于 o2；如果返回 0，表示相等；返回负整数，表示 o1 小于 o2。</li><li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</li></ul><h2 id="11-6-系统相关类">11.6 系统相关类</h2><h3 id="11-6-1-java-lang-System-类">11.6.1 java.lang.System 类</h3><p>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包。</p><p>由于该类的构造器是 private 的，所以无法创建该类的对象。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。</p><p>成员变量：</p><ul><li>Scanner scan = new Scanner(<a href="http://System.in">System.in</a>);</li><li>System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li></ul><p>成员方法：</p><ul><li>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间(格林威治时间)1970 年 1 月 1 号 0 时 0 分 0 秒所差的毫秒数。</li><li>void exit(int status)： 该方法的作用是退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程<br>中实现程序的退出功能等。</li><li>void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li><li>String getProperty(String key)： 该方法的作用是获得系统中属性名为 key 的属性对应的值。</li></ul><h3 id="11-6-2-java-lang-Runtime-类">11.6.2 java.lang.Runtime 类</h3><ul><li>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。</li><li>public static Runtime getRuntime()： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。</li><li>public long totalMemory()：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的 1/64。</li><li>public long maxMemory()：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的 1/4。</li><li>public long freeMemory()：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</li></ul><h2 id="11-7-数学相关的类">11.7 数学相关的类</h2><h3 id="11-7-1-java-lang-Math">11.7.1 java.lang.Math</h3><p>java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><h3 id="11-7-2-BigInteger">11.7.2 BigInteger</h3><p>Integer 类作为 int 的包装类，能存储的最大整型值为 2^31 - 1。</p><p>Long 类也是有限的，最大为 2^63 - 1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p><p>java.math 包的 BigInteger 可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p><p>构造器：</p><ul><li>BigInteger(String val)：根据字符串构建 BigInteger 对象</li></ul><p>方法：</p><ul><li>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。</li><li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。</li><li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。</li><li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。</li><li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li><li>BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li></ul><h3 id="11-7-3-BigDecimal">11.7.3 BigDecimal</h3><p>一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类。</p><p>BigDecimal 类支持不可变的、任意精度的有符号十进制定点数。</p><p>构造器：</p><ul><li>public BigDecimal(double val)</li><li>public BigDecimal(String val)</li></ul><p>常用方法：</p><ul><li>public BigDecimal add(BigDecimal augend)</li><li>public BigDecimal subtract(BigDecimal subtrahend)</li><li>public BigDecimal multiply(BigDecimal multiplicand)</li><li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)：divisor 是除数，scale 指明保留几位小数，roundingMode<br>指明舍入模式。（ROUNDUP :向上加 1、ROUNDDOWN :直接舍去、ROUNDHALFUP:四舍五入）</li></ul><h3 id="11-7-4-java-util-Random">11.7.4 java.util.Random</h3><ul><li>用于产生随机数。</li><li>boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。</li><li>void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。</li><li>double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。</li><li>float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。</li><li>double nextGaussian():返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。</li><li>int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。</li><li>int nextInt(int n):返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。</li><li>long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</li></ul><h2 id="11-8-企业真题">11.8 企业真题</h2><ol><li><p>以下两种方式创建的 String 对象有什么不同？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure><p>答：<br>① 直接赋值创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><p>这种方式创建的 String 对象是在字符串常量池中创建的，如果已经存在相同的字符串常量，就会直接返回该常量的引用，而不会重新创建。</p><p>② 使用 new 关键字创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure><p>这种方式创建的 String 对象是在堆内存中创建的，不会共享存储空间，即使是相同的字符串内容也会创建多个对象。</p><p>因此，使用直接赋值方式创建 String 对象更加高效，能够节省存储空间和创建对象的时间。</p></li><li><p>String s = new String(“xyz”);创建了几个 String Object?<br>答：<br>如果我们只考虑这一行代码，确实只创建了一个 String Object。但是，由于 Java 有一个字符串池（string pool）的概念，如果字符串池中没有"xyz"这个字符串，那么这个字符串会被添加到字符串池中。因此，实际上可能会创建两个 String Object：一个在堆中，一个在字符串池中。但是，这取决于 JVM 的实现方式和优化策略，因此不是绝对的。</p></li><li><p>String a=“abc” String b=“a”+“bc” ，那么 a==b?<br>答：<br>true，因为"a"+“bc"会被编译器优化为"abc”，所以 a 和 b 都是指向值为"abc"的 String 对象。</p></li><li><p>String 中 “+” 怎样实现?<br>答：<br>在 Java 中，字符串连接可以使用 “+” 运算符来实现。当两个字符串相加时，Java 会将它们连接起来，形成一个新的字符串。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"World"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1 + <span class="string">" "</span> + str2;</span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure><p>输出结果为: “Hello World”。</p><p>在底层实现中，Java 会使用 StringBuilder 或 StringBuffer 类来实现字符串连接。这两个类都提供了 append() 方法来实现字符串的拼接，而 “+” 运算符就是使用了这些方法。在实际开发中，建议使用 StringBuilder 或 StringBuffer 类来进行字符串拼接，因为它们的效率更高。</p></li><li><p>Java 中 String 是不是 final 的？<br>答：<br>是的，Java 中的 String 是 final 的，这意味着它们是不可变的。一旦一个 String 对象被创建，它的值就不能被改变。如果需要修改一个字符串，必须创建一个新的 String 对象来代替原来的对象。这种不可变性使得 String 对象在多线程环境下更加安全和可靠。</p></li><li><p>String 为啥不可变，在内存中的具体形态？<br>答：<br>String 不可变的原因是因为它的值被创建后就不能再被修改。这是因为 String 类被设计为 final 类，因此它的方法都不能被重写，也不能被子类化。这就意味着一旦一个 String 对象被创建，它的值就不能被更改，只能创建一个新的 String 对象来代替。</p><p>在内存中，每个 String 对象都有一个字符串常量池。字符串常量池是一个特殊的内存区域，用于存储所有的字符串常量。当创建一个 String 对象时，如果字符串常量池中已经存在相同值的字符串常量，则返回该常量的引用，否则就会在常量池中新建一个字符串常量，并返回该常量的引用。</p><p>具体来说，当我们使用字符串字面值创建一个 String 对象时，Java 会首先在字符串常量池中查找是否已经存在相同值的字符串常量。如果存在，则返回该常量的引用；如果不存在，则在字符串常量池中新建一个字符串常量，并返回该常量的引用。如果我们使用 new 关键字显式创建一个 String 对象，则该对象会被存储在堆内存中，而不是字符串常量池中。</p><p>总之，String 的不可变性是由 final 关键字和其设计决定的，而字符串常量池则是一种优化机制，用于避免重复创建相同值的字符串常量。</p></li><li><p>String 可以在 switch 中使用吗?<br>答：<br>是的，从 Java 7 开始，String 类型可以在 switch 语句中使用。在之前的版本中，只能使用基本数据类型和枚举类型。在使用字符串时，每个 case 分支都必须是一个字符串常量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">switch</span> (str)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    System.out.println(<span class="string">"World!"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">"Other!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>注意，在 switch 语句中使用字符串时，需要使用双引号将字符串括起来。</p></li><li><p>String 中有哪些方法?列举几个。<br>答：<br>① length()：返回字符串的长度。<br>② charAt(int index)：返回指定位置的字符。<br>③ indexOf(String str)：返回指定字符串在该字符串中第一次出现的位置。<br>④ substring(int beginIndex, int endIndex)：返回从指定位置开始到结束位置的子字符串。<br>⑤ equals(Object obj)：比较字符串是否相等。<br>⑥ toUpperCase()：将字符串转换为大写。<br>⑦ toLowerCase()：将字符串转换为小写。<br>⑧ replace(char oldChar, char newChar)：用新字符替换旧字符。<br>⑨ trim()：去除字符串两端的空格。<br>⑩ split(String regex)：将字符串按照指定正则表达式分割成字符串数组。</p></li><li><p>subString()到底做了什么?<br>答：<br>Java 中的 subString()方法用于从一个字符串中获取一个子字符串。它接受两个参数，即要提取的子字符串的起始索引和结束索引。它返回从起始索引到结束索引（不包括结束索引）的子字符串。</p><p>subString()方法实际上在原始字符串上创建了一个新的字符串对象，该字符串对象包含从原始字符串中提取的子字符串。这个新字符串对象是原始字符串的一个子字符串，它与原始字符串共享相同的字符数组。因此，如果在原始字符串中进行更改，则可能会影响子字符串。</p><p>需要注意的是，如果传递给 subString()方法的起始索引或结束索引超出了字符串的范围，则会抛出 StringIndexOutOfBoundsException 异常。</p></li><li><p>Java 中操作字符串有哪些类？他们之间有什么区别？<br>答：<br>Java 中操作字符串的类有 String、StringBuffer 和 StringBuilder。它们之间的区别如下：<br>① String 类是不可变的，意味着一旦创建了一个字符串对象，就不能改变它的值，任何对字符串的修改都会创建一个新的字符串对象。String 类适用于字符串不需要频繁修改的场景。<br>② StringBuffer 类是可变的，可以对字符串进行修改，适用于需要频繁修改字符串的场景。在多线程环境下，StringBuffer 是线程安全的。<br>③ StringBuilder 类也是可变的，与 StringBuffer 类相似，但不保证线程安全。StringBuilder 类适用于在单线程环境下，需要频繁修改字符串的场景。</p><p>总之，如果需要频繁修改字符串并且在多线程环境下，建议使用 StringBuffer 类。如果在单线程环境下需要频繁修改字符串，建议使用 StringBuilder 类。如果字符串不需要频繁修改，使用 String 类即可。</p></li><li><p>String 的线程安全问题？<br>答：<br>String 是不可变对象，因此它是线程安全的。多个线程可以同时访问同一个 String 对象，而不会出现竞争条件或线程安全问题。但是，如果在多个线程之间共享可变的 StringBuilder 或 StringBuffer 对象时，就会出现线程安全问题，因为这些对象是可变的。在这种情况下，需要使用同步机制来保证线程安全。</p></li><li><p>StringBuilder 和 StringBuffer 的线程安全问题？<br>答：<br>StringBuilder 和 StringBuffer 都是可变字符串的实现类，区别在于 StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的。</p><p>线程安全的意思是多个线程同时操作一个对象时，不会出现数据不一致或者异常的情况。在多线程环境下，如果使用 StringBuilder 进行字符串的操作，可能会出现数据不一致的问题。因为 StringBuilder 不是线程安全的，多个线程同时操作一个 StringBuilder 对象时，会出现竞争条件，导致数据不一致。</p><p>而 StringBuffer 是线程安全的，它的所有公共方法都是同步的，保证了多个线程同时操作一个 StringBuffer 对象时，数据的一致性。</p><p>因此，如果在多线程环境下需要进行字符串的操作，应该使用 StringBuffer，而不是 StringBuilder。如果在单线程环境下进行字符串的操作，建议使用 StringBuilder，因为它比 StringBuffer 更高效。</p></li><li><p>简单说说 Comparable 和 Comparator 的区别和场景？<br>答：<br>Comparable 是一个接口，它是 Java 中的一个内部比较器，可以通过实现该接口来定义类的内部比较规则。实现 Comparable 接口的类可以进行自然排序，即按照类的内部定义的比较规则进行排序。</p><p>Comparator 也是一个接口，它是 Java 中的一个外部比较器，可以通过实现该接口来定义类的外部比较规则。实现 Comparator 接口的类可以进行定制排序，即按照自己定义的比较规则进行排序。</p><p>总的来说，Comparable 是用于定义类的内部比较规则，Comparator 是用于定义类的外部比较规则。如果我们需要对已有的类进行排序，而该类没有实现 Comparable 接口，或者我们需要按照不同的比较规则进行排序，那么就需要使用 Comparator 接口来进行定制排序。</p></li><li><p>Comparable 接口和 Comparator 接口实现比较？<br>答：<br>Comparable 接口是 Java 中的一个接口，它只有一个方法 compareTo(Object obj)，用于定义对象之间的自然排序。如果一个类实现了 Comparable 接口，就可以使用 Collections.sort 或 Arrays.sort 方法对该类的对象进行排序。</p><p>Comparator 接口也是 Java 中的一个接口，它有两个方法 compare(Object obj1, Object obj2) 和 equals(Object obj)，用于定义对象之间的比较。如果一个类实现了 Comparator 接口，就可以使用 Collections.sort 或 Arrays.sort 方法，并传入该类的对象作为比较器，对其他类的对象进行排序。</p><p>两者的区别在于 Comparable 接口是在对象内部实现的，而 Comparator 接口是在对象外部实现的。如果一个类只需要一种排序方式，可以实现 Comparable 接口；如果需要多种排序方式，或者需要对其他类的对象进行排序，可以实现 Comparator 接口。</p></li></ol><h1>第 12 章 集合框架</h1><h2 id="12-1-数组存储数据方面的特点和弊端">12.1 数组存储数据方面的特点和弊端</h2><p>数组存储多个数据方面的特点：</p><ul><li>数组一旦初始化，其长度就是确定的。</li><li>数组中的多个元素是依次紧密排列的，有序的，可重复的。</li><li>数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。</li><li>元素的类型既可以是基本数据类型，也可以是引用数据类型。</li></ul><p>数组存储多个数据方面的弊端：</p><ul><li>数组一旦初始化，其长度就不可变了。</li><li>数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。</li><li>数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。</li><li>针对于数组中元素的删除、插入操作，性能较差。</li></ul><h2 id="12-2-集合框架概述">12.2 集合框架概述</h2><ul><li>Java 集合可分为 Collection 和 Map 两大体系。</li><li>Collection 接口：用于存储一个一个的数据，也称单列数据集合。<ul><li>List 子接口：用来存储有序的、可以重复的数据。（主要用来替换数组，"动态"数组）<ul><li>实现类：ArrayList(主要实现类)、LinkedList、Vector。</li></ul></li><li>Set 子接口：用来存储无序的、不可重复的数据。<ul><li>实现类：HashSet(主要实现类)、LinkedHashSet、TreeSet。</li></ul></li></ul></li><li>Map 接口：用于存储具有映射关系“key-value 对”的集合，即一对一对的数据，也称双列数据集合。<ul><li>HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties。</li></ul></li><li>JDK 提供的集合 API 位于 java.util 包内。</li></ul><p><img src="https://img-blog.csdnimg.cn/69d2b28710414407b29bfec3c95c1021.png" alt="Collection 接口继承树"></p><p><img src="https://img-blog.csdnimg.cn/3924577fd5fe4caaa5de35a99dea2402.png" alt="Map 接口继承树"></p><h2 id="12-3-Collection-接口的常用方法">12.3 Collection 接口的常用方法</h2><h3 id="12-3-1-添加">12.3.1 添加</h3><ul><li>add(E obj)：添加元素对象到当前集合中。</li><li>addAll(Collection other)：添加 other 集合中的所有元素对象到当前集合中。</li></ul><h3 id="12-3-2-判断">12.3.2 判断</h3><ul><li>int size()：获取当前集合中实际存储的元素个数。</li><li>boolean isEmpty()：判断当前集合是否为空集合。</li><li>boolean contains(Object obj)：判断当前集合中是否存在一个与 obj 对象 equals 返回 true 的元素。</li><li>boolean containsAll(Collection coll)：判断 coll 集合中的元素是否在当前集合中都存在。即 coll 集合是否是当前集合的“子集” 。</li><li>boolean equals(Object obj)：判断当前集合与 obj 是否相等。</li></ul><h3 id="12-3-3-删除">12.3.3 删除</h3><ul><li>void clear()：清空集合元素。</li><li>boolean remove(Object obj) ：从当前集合中删除第一个找到的与 obj 对象 equals 返回 true 的元素。</li><li>boolean removeAll(Collection coll)：从当前集合中删除所有与 coll 集合中相同的元素。</li><li>boolean retainAll(Collection coll)：从当前集合<br>中删除两个集合中不同的元素，使得当前集合仅保留与 coll 集合中的元素相同的元素，即当前集合中仅保留两个集合的交集。</li></ul><h3 id="12-3-4-其它">12.3.4 其它</h3><ul><li>Object[] toArray()：返回包含当前集合中所有元素的数组。</li><li>hashCode()：获取集合对象的哈希值。</li><li>iterator()：返回迭代器对象，用于集合遍历。</li></ul><h2 id="12-4-Iterator-迭代器-接口">12.4 Iterator(迭代器)接口</h2><h3 id="12-4-1-Iterator-接口">12.4.1 Iterator 接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK 专门提供了一个接口 java.util.Iterator。Iterator 接口也是 Java 集合中的一员，但它与 Collection、Map 接口有所不同。</p><p>Collection 接口与 Map 接口主要用于存储元素。</p><p>Iterator，被称为迭代器接口，本身并不提供存储对象的能力，主要用于遍历 Collection 中的元素。</p><p>Collection 接口继承了 java.lang.Iterable 接口，该接口有一个 iterator()方法，那么所有实现了 Collection 接口的集合类都有一个 iterator()方法，用以返回一个实现了 Iterator 接口的对象。</p><ul><li>public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。</li><li>集合对象每次调用 iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li></ul><p>Iterator 接口的常用方法如下：</p><ul><li>public E next():返回迭代的下一个元素。</li><li>public boolean hasNext():如果仍有元素可以迭代，则返回 true。</li></ul><p>注意：在调用 it.next()方法之前必须要调用 it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用 it.next()会抛出 NoSuchElementException 异常。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如何获取迭代器(Iterator)对象？</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如何实现遍历</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// next():①指针下移 ② 将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="12-4-2-迭代器的执行原理">12.4.2 迭代器的执行原理</h3><p>Iterator 迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示 Iterator 对象迭代元素的过程：</p><p><img src="https://img-blog.csdnimg.cn/f965e74ae7704eb0855593264bb8d941.png" alt="迭代器的执行原理"></p><p>使用 Iterator 迭代器删除元素：java.util.Iterator 迭代器中有一个方法：void remove()。</p><p>注意：</p><ul><li>Iterator 可以删除集合的元素，但是遍历过程中通过迭代器对象的 remove 方法，不是集合对象的 remove 方法。</li><li>如果还未调用 next()或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用 remove()都会报 IllegalStateException。</li><li>Collection 已经有 remove(xx)方法了，为什么 Iterator 迭代器还要提供删除方法呢？因为迭代器的 remove()可以按指定的条件进行删除。</li></ul><blockquote><p>迭代器的执行原理是设计模式的一种。<br>迭代器不负责数据的存储，负责对集合类的遍历。</p></blockquote><h3 id="12-4-3-foreach-循环">12.4.3 foreach 循环</h3><p>foreach 循环（也称增强 for 循环）是 JDK5.0 中定义的一个高级 for 循环，专门用来遍历数组和集合的。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(元素的数据类型 局部变量 : Collection 集合或数组)</span><br><span class="line">{</span><br><span class="line">    //操作局部变量的输出操作</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>对于集合的遍历，增强 for 的内部原理其实是个 Iterator 迭代器。</p><h2 id="12-5-Collection-的子接口：List">12.5 Collection 的子接口：List</h2><h3 id="12-5-1-List-接口概述">12.5.1 List 接口概述</h3><p>鉴于 Java 中数组用来存储数据的局限性，我们通常使用 java.util.List 替代数组。</p><p>List 集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p><p>JDK API 中 List 接口的实现类常用的有：ArrayList、LinkedList 和 Vector。</p><h3 id="12-5-2-List-接口方法">12.5.2 List 接口方法</h3><p>List 除了从 Collection 集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。</p><ul><li><p>插入元素</p><ul><li>void add(int index, Object ele):在 index 位置插入 ele 元素。</li><li>boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来。</li></ul></li><li><p>获取元素</p><ul><li>Object get(int index):获取指定 index 位置的元素。</li><li>List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合。</li></ul></li><li><p>获取元素索引</p><ul><li>int indexOf(Object obj):返回 obj 在集合中首次出现的位置。</li><li>int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置。</li></ul></li><li><p>删除和替换元素</p><ul><li>Object remove(int index):移除指定 index 位置的元素，并返回此元素。</li><li>Object set(int index, Object ele):设置指定 index 位置的元素为 ele。</li></ul></li></ul><h3 id="12-5-3-List-接口主要实现类：ArrayList">12.5.3 List 接口主要实现类：ArrayList</h3><p>ArrayList 是 List 接口的主要实现类</p><p>本质上，ArrayList 是对象引用的一个”变长”数组。</p><p>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。Arrays.asList(…) 返回值是一个固定长度的 List 集合。</p><h3 id="12-5-4-List-的实现类：LinkedList">12.5.4 List 的实现类：LinkedList</h3><p>对于频繁的插入或删除元素的操作，建议使用 LinkedList 类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。</p><p>方法：</p><ul><li>void addFirst(Object obj)</li><li>void addLast(Object obj)</li><li>Object getFirst()</li><li>Object getLast()</li><li>Object removeFirst()</li><li>Object removeLast()</li></ul><h3 id="12-5-5-List-的实现类：Vector">12.5.5 List 的实现类：Vector</h3><p>Vector 是一个古老的集合，JDK1.0 就有了。大多数操作与 ArrayList 相同，区别之处在于 Vector 是线程安全的。</p><p>在各种 List 中，最好把 ArrayList 作为默认选择。当插入、删除频繁时，使用 LinkedList；Vector 总是比 ArrayList 慢，所以尽量避免使用。</p><p>方法：</p><ul><li>void addElement(Object obj)</li><li>void insertElementAt(Object obj,int index)</li><li>void setElementAt(Object obj,int index)</li><li>void removeElement(Object obj)</li><li>void removeAllElements()</li></ul><h2 id="12-6-Collection-的子接口：Set">12.6 Collection 的子接口：Set</h2><h3 id="12-6-1-Set-接口概述">12.6.1 Set 接口概述</h3><p>Set 接口是 Collection 的子接口，Set 接口相较于 Collection 接口没有提供额外的方法。</p><p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p><p>Set 集合支持的遍历方式和 Collection 集合一样：foreach 和 Iterator。</p><p>Set 的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p><h3 id="12-6-2-Set-主要实现类：HashSet">12.6.2 Set 主要实现类：HashSet</h3><p>HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。</p><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。</p><p>HashSet 具有以下特点：</p><ul><li>不能保证元素的排列顺序。</li><li>HashSet 不是线程安全的。</li><li>集合元素可以是 null。</li></ul><p>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法得到的哈希值相等，并且两个对象的 equals()方法返回值为 true。</p><p>对于存放在 Set 容器中的对象，对应的类一定要重写 hashCode()和 equals(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p><p>HashSet 集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的 hashCode()调用后返回的 hash 值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。</p><h3 id="12-6-3-Set-实现类：LinkedHashSet">12.6.3 Set 实现类：LinkedHashSet</h3><p>LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。</p><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的。</p><p>LinkedHashSet 插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p><h3 id="12-6-4-Set-实现类：TreeSet">12.6.4 Set 实现类：TreeSet</h3><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。</p><p>TreeSet 底层使用红黑树结构存储数据。</p><p>方法：</p><ul><li>Comparator comparator()</li><li>Object first()</li><li>Object last()</li><li>Object lower(Object e)</li><li>Object higher(Object e)</li><li>SortedSet subSet(fromElement, toElement)</li><li>SortedSet headSet(toElement)</li><li>SortedSet tailSet(fromElement)</li></ul><p>TreeSet 特点：不允许重复、实现排序。（自然排序或定制排序）</p><p>TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</p><ul><li>自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。<ul><li>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。</li><li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</li></ul></li><li>定制排序：如果元素所属的类没有实现 Comparable 接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过 Comparator 接口来实现。需要重写 compare(T o1,T o2)方法。<ul><li>利用 int compare(T o1,T o2)方法，比较 o1 和 o2 的大小：如果方法返回正整数，则表示 o1 大于 o2；如果返回 0，表示相等；返回负整数，表示 o1 小于 o2。</li><li>要实现定制排序，需要将实现 Comparator 接口的实例作为形参传递给 TreeSet 的构造器。</li></ul></li></ul><h2 id="12-7-Map-接口">12.7 Map 接口</h2><p>Java 提供了专门的集合框架用来存储这种映射关系的对象，即 java.util.Map 接口。</p><h3 id="12-7-1-Map-接口概述">12.7.1 Map 接口概述</h3><p>Map 与 Collection 并列存在。用于保存具有映射关系的数据：key-value。</p><p>Collection 集合称为单列集合，元素是孤立存在的。</p><p>Map 集合称为双列集合，元素是成对存在的。</p><p>Map 中的 key 和 value 都可以是任何引用类型的数据。但常用 String 类作为 Map 的“键”。</p><p>Map 接口的常用实现类：HashMap、LinkedHashMap、TreeMap 和 Properties。其中，HashMap 是 Map 接口使用频率最高的实现类。</p><h3 id="12-7-2-Map-中-key-value-特点">12.7.2 Map 中 key-value 特点</h3><p>这里主要以 HashMap 为例说明。HashMap 中存储的 key、value 的特点如下：</p><ul><li>Map 中的 key 用 Set 来存放，不允许重复，即同一个 Map 对象所对应的类，须重写 hashCode()和 equals()方法。</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value，不同 key 对应的 value 可以重复。value 所在的类要重写 equals()方法。</li><li>key 和 value 构成一个 entry。所有的 entry 彼此之间是无序的、不可重复的。</li></ul><p><img src="https://img-blog.csdnimg.cn/daa16cc35b7749619e0651c6168fac5c.png" alt="Map 中 key-value 特点"></p><h3 id="12-7-3-Map-接口的常用方法">12.7.3 Map 接口的常用方法</h3><p>添加、修改操作：</p><ul><li>Object put(Object key,Object value)：将指定 key-value 添加到(或修改)当前 map 对象中。</li><li>void putAll(Map m):将 m 中的所有 key-value 对存放到当前 map 中。</li></ul><p>删除操作：</p><ul><li>Object remove(Object key)：移除指定 key 的 key-value 对，并返回 value。</li><li>void clear()：清空当前 map 中的所有数据。</li></ul><p>元素查询的操作：</p><ul><li>Object get(Object key)：获取指定 key 对应的 value。</li><li>boolean containsKey(Object key)：是否包含指定的 key。</li><li>boolean containsValue(Object value)：是否包含指定的 value。</li><li>int size()：返回 map 中 key-value 对的个数。</li><li>boolean isEmpty()：判断当前 map 是否为空。</li><li>boolean equals(Object obj)：判断当前 map 和参数对象 obj 是否相等。</li></ul><p>元视图操作的方法：</p><ul><li>Set keySet()：返回所有 key 构成的 Set 集合。</li><li>Collection values()：返回所有 value 构成的 Collection 集合。</li><li>Set entrySet()：返回所有 key-value 对构成的 Set 集合。</li></ul><h3 id="12-7-4-Map-的主要实现类：HashMap">12.7.4 Map 的主要实现类：HashMap</h3><p>HashMap 是 Map 接口使用频率最高的实现类。</p><p>HashMap 是线程不安全的。允许添加 null 键和 null 值。</p><p>存储数据采用的哈希表结构，底层使用一维数组 + 单向链表 + 红黑树进行 key-value 数据的存储。与 HashSet 一样，元素的存取顺序不能保证一致。</p><p>HashMap 判断两个 key 相等的标准是：两个 key 的 hashCode 值相等，通过 equals() 方法返回 true。</p><p>HashMap 判断两个 value 相等的标准是：两个 value 通过 equals() 方法返回 true。</p><h3 id="12-7-5-Map-实现类：LinkedHashMap">12.7.5 Map 实现类：LinkedHashMap</h3><p>LinkedHashMap 是 HashMap 的子类。</p><p>存储数据采用的哈希表结构+链表结构，在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致。</p><p>通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写 hashCode()方法、equals()方法。</p><h3 id="12-7-6-Map-实现类：TreeMap">12.7.6 Map 实现类：TreeMap</h3><p>TreeMap 存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。</p><p>TreeSet 底层使用红黑树结构存储数据</p><p>TreeMap 的 Key 的排序：</p><ul><li>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。</li><li>定制排序：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key<br>实现 Comparable 接口。</li></ul><p>TreeMap 判断两个 key 相等的标准：两个 key 通过 compareTo()方法或者 compare()<br>方法返回 0。</p><h3 id="12-7-7-Map-实现类：Hashtable">12.7.7 Map 实现类：Hashtable</h3><p>Hashtable 是 Map 接口的古老实现类，JDK1.0 就提供了。不同于 HashMap，Hashtable 是线程安全的。</p><p>Hashtable 实现原理和 HashMap 相同，功能相同。底层都使用哈希表结构（数组 + 单向链表），查询速度快。</p><p>与 HashMap 一样，Hashtable 也不能保证其中 Key-Value 对的顺序。</p><p>Hashtable 判断两个 key 相等、两个 value 相等的标准，与 HashMap 一致。</p><p>与 HashMap 不同，Hashtable 不允许使用 null 作为 key 或 value。</p><h3 id="12-7-8-Map-实现类：Properties">12.7.8 Map 实现类：Properties</h3><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件。</p><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型。</p><p>存取数据时，建议使用 setProperty(String key,String value)方法和 getProperty(String key)方法。</p><h2 id="12-8-Collections-工具类">12.8 Collections 工具类</h2><p>参考操作数组的工具类：Arrays，Collections 是一个操作 Set、List 和 Map 等集合的工具类。</p><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法（均为 static 方法）。</p><p>排序操作：</p><ul><li>reverse(List)：反转 List 中元素的顺序。</li><li>shuffle(List)：对 List 集合元素进行随机排序。</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序。</li><li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行<br>排序。<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换。</li></ul><p>查找：</p><ul><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素。</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合<br>中的最大元素。</li><li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素。</li><li>Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合<br>中的最小元素。</li><li>int binarySearch(List list,T key)在 List 集合中查找某个元素的下标，但是 List 的元素必须是 T 或 T 的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li><li>int binarySearch(List list,T key,Comparator c)在 List 集合中查找某个元素的下标，但是 List 的元素必须是 T 或 T 的子类对象，而且集合也事先必须是按照 c 比较器规则进行排序过的，否则结果不确定。</li><li>int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数。</li></ul><p>复制、替换：</p><ul><li>void copy(List dest,List src)：将 src 中的内容复制到 dest 中。</li><li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值。</li><li>提供了多个 unmodifiableXxx()方法，该方法返回指定 Xxx 的不可修改的视图。</li></ul><p>添加：</p><ul><li>boolean addAll(Collection c,T… elements)将所有指定元素添加到指定 collection 中。</li></ul><p>同步：</p><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</li></ul><h2 id="12-9-企业真题">12.9 企业真题</h2><ol><li><p>List，Set，Map 是否继承自 collection 接口？<br>答：<br>在 Java 中，List，Set 和 Map 是三种常用的集合类型，它们分别属于 java.util 包中的不同接口。List 和 Set 继承自 Collection 接口，而 Map 接口与 Collection 接口并无直接关系。这里是它们的关系层次：</p><ul><li>java.util.Collection<ul><li>java.util.List</li><li>java.util.Set</li></ul></li><li>java.util.Map</li></ul><p>Collection 接口是 Java 集合框架的根接口，定义了一组操作集合的基本方法，如 add，remove，size 等。List 和 Set 是 Collection 接口的两个子接口，分别表示有序可重复和无序不可重复的集合。</p><p>Map 接口表示键值对的映射关系，它不能直接视为一种集合类型，因为它不继承自 Collection 接口。但是，它提供了一些方法可以将其键值对转换成 Set 或 Collection 类型的集合，例如 keySet()方法可以返回一个包含所有键的 Set 集合，values()方法可以返回一个包含所有值的 Collection 集合。</p></li><li><p>说说 List,Set,Map 三者的区别？<br>答：<br>List、Set 和 Map 都是 Java 中的集合类型，它们之间的主要区别如下：<br>① List 是一个有序的集合，它允许重复的元素。List 中的元素可以通过索引访问，也可以使用迭代器进行遍历。<br>② Set 是一个不允许重复元素的集合，它不保证元素的顺序。Set 中的元素可以使用迭代器进行遍历，但不能通过索引访问。<br>③ Map 是一个键值对的集合，每个元素都包含一个键和一个值。Map 中的键是唯一的，但值可以重复。Map 中的元素可以使用键来访问，也可以使用迭代器进行遍历。</p></li></ol><p>总的来说，List 适用于需要有序并且可以重复的元素的场景，Set 适用于需要去重并且不需要保证元素顺序的场景，Map 适用于需要按键访问值的场景。</p><ol start="3"><li><p>写出 list、map、set 接口的实现类，并说出其特点？<br>答：<br>List、Map、Set 都是 Java 中常用的接口，它们的实现类如下：<br>① List 的实现类：</p><ul><li>ArrayList：基于数组实现的 List，支持快速随机访问，但插入和删除元素的效率相对较低。</li><li>LinkedList：基于链表实现的 List，插入和删除元素的效率比 ArrayList 高，但随机访问的效率较低。</li></ul><p>② Map 的实现类：</p><ul><li>HashMap：基于哈希表实现的 Map，支持快速的插入、删除和查找操作。</li><li>TreeMap：基于红黑树实现的 Map，支持有序遍历和范围查找。</li></ul><p>③ Set 的实现类：</p><ul><li>HashSet：基于哈希表实现的 Set，支持快速的插入、删除和查找操作。</li><li>TreeSet：基于红黑树实现的 Set，支持有序遍历和范围查找。</li></ul><p>这些实现类的特点可以总结如下：</p><ul><li>ArrayList 和 LinkedList 都是有序的 List 实现，但它们的实现方式不同，因此它们的性能特点也不同。</li><li>HashMap 和 HashSet 都是基于哈希表实现的，具有快速的插入、删除和查找操作的特点。</li><li>TreeMap 和 TreeSet 都是基于红黑树实现的，支持有序遍历和范围查找，但相对于哈希表实现的容器，它们的插入、删除和查找操作的速度较慢。</li></ul></li><li><p>常见集合类的区别和适用场景？<br>答：<br>Java 中常见的集合类包括 List、Set、Map 等，它们的区别和适用场景如下：<br>① List：List 是一个有序的集合，可以存储重复的元素。常见的实现类有 ArrayList 和 LinkedList。ArrayList 适用于随机访问，而 LinkedList 适用于插入和删除操作频繁的情况。<br>② Set：Set 是一个不允许重复元素的集合，通常用于去重。常见的实现类有 HashSet、LinkedHashSet 和 TreeSet。HashSet 是最常用的实现类，它使用哈希算法来实现元素的存储和查找，具有很好的性能。LinkedHashSet 继承自 HashSet，保留了插入顺序。TreeSet 则是基于红黑树实现的，可以对元素进行排序。<br>③ Map：Map 是一种键值对映射的集合，每个键只能对应一个值。常见的实现类有 HashMap、LinkedHashMap 和 TreeMap。HashMap 是最常用的实现类，它使用哈希算法来实现键值对的存储和查找，具有很好的性能。LinkedHashMap 继承自 HashMap，保留了插入顺序。TreeMap 则是基于红黑树实现的，可以对键进行排序。</p><p>适用场景：<br>① List 适用于需要按照插入顺序存储数据、允许存储重复元素的情况。<br>② Set 适用于需要去重的情况。<br>③ Map 适用于需要按照键值对方式存储数据的情况。</p></li><li><p>集合的父类是谁？哪些安全的？<br>答：<br>Java 中集合的父类是 java.util.Collection。<br>线程安全的集合类有：<br>① java.util.concurrent.ConcurrentHashMap<br>② java.util.concurrent.CopyOnWriteArrayList<br>③ java.util.concurrent.CopyOnWriteArraySet<br>④ java.util.concurrent.ConcurrentSkipListMap<br>⑤ java.util.concurrent.ConcurrentSkipListSet<br>⑥ java.util.Collections.synchronizedList<br>⑦ java.util.Collections.synchronizedSet<br>⑧ java.util.Collections.synchronizedMap</p><p>这些集合类在多线程环境下使用是安全的，因为它们内部实现了同步机制来保证线程安全。</p><p>线程不安全的集合类有：<br>① java.util.ArrayList<br>② java.util.LinkedList<br>③ java.util.HashSet<br>④ java.util.TreeSet<br>⑤ java.util.HashMap<br>⑥ java.util.TreeMap</p><p>这些集合类在多线程环境下使用时可能会出现线程安全问题，需要在使用时进行同步处理来保证线程安全。</p></li><li><p>集合说一下哪些是线程不安全的？<br>答：<br>在 Java 集合框架中，有一些集合类是线程不安全的，也就是说在多线程环境下使用它们可能会导致数据不一致或者其他并发问题。以下是一些线程不安全的 Java 集合类：<br>① ArrayList</p><ul><li>ArrayList 是一个可变数组，当多个线程同时修改同一个 ArrayList 实例时，可能会导致数据不一致问题，因为 ArrayList 内部并没有实现同步机制。</li></ul><p>② HashMap</p><ul><li>HashMap 是一个哈希表，也是线程不安全的。当多个线程同时修改同一个 HashMap 实例时，可能会导致数据不一致问题，因为 HashMap 内部并没有实现同步机制。</li></ul><p>③ HashSet</p><ul><li>HashSet 是一个基于 HashMap 实现的集合类，因此它也是线程不安全的。</li></ul><p>④ LinkedList</p><ul><li>LinkedList 是一个链表，也是线程不安全的。当多个线程同时修改同一个 LinkedList 实例时，可能会导致数据不一致问题，因为 LinkedList 内部并没有实现同步机制。</li></ul><p>⑤ TreeMap</p><ul><li>TreeMap 是一个基于红黑树实现的映射表，也是线程不安全的。当多个线程同时修改同一个 TreeMap 实例时，可能会导致数据不一致问题，因为 TreeMap 内部并没有实现同步机制。</li></ul><p>要在多线程环境中使用这些集合类，可以考虑使用它们的线程安全版本，例如：Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。这些线程安全的集合类可以保证在多线程环境中使用时不会出现数据不一致或者其他并发问题。</p></li><li><p>遍历集合的方式有哪些？<br>答：<br>在 Java 中，遍历集合的方式主要有以下几种：<br>① 使用迭代器（Iterator）：通过调用集合的 iterator() 方法获取迭代器，然后使用 while 循环和 hasNext()、next() 方法遍历集合中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">{</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>② 使用增强型 for 循环（foreach）：Java 5 引入了 foreach 循环，可以更方便地遍历集合中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : list)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>③ 使用 Lambda 表达式：Java 8 引入了 Lambda 表达式，可以更简洁地遍历集合中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.forEach(element -&gt; {</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">});</span><br></pre></td></tr></table></figure><p>④ 使用 Stream API：Java 8 还引入了 Stream API，可以更灵活地对集合中的元素进行过滤、转换等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.stream().filter(element -&gt; element.startsWith(<span class="string">"a"</span>)).forEach(element -&gt; {</span><br><span class="line">    <span class="comment">// 处理元素</span></span><br><span class="line">});</span><br></pre></td></tr></table></figure><p>以上是 Java 中比较常用的几种遍历集合的方式，选择具体的方式可以根据实际情况进行考虑。</p></li><li><p>List 下面有哪些实现？<br>答：<br>在 Java 中，List 是一个接口，它定义了一组操作有序集合元素的方法。List 接口有许多实现，其中一些最常用的包括：<br>① ArrayList：基于数组实现的可调整大小的列表，支持快速的随机访问和在列表末尾的常数时间添加和删除元素。<br>② LinkedList：基于链表实现的列表，支持 O(1)时间复杂度的添加和删除元素，但随机访问元素的时间复杂度为 O(n)。<br>③ Vector：与 ArrayList 类似的动态数组，但是所有公共操作都是同步的，因此效率较低，通常不推荐使用。<br>④ Stack：基于 Vector 实现的栈，支持 LIFO（后进先出）操作。</p><p>除了这些常见的实现，还有其他一些实现可以根据具体需要选择使用，例如 CopyOnWriteArrayList、ImmutableList 等。</p></li><li><p>ArrayList 与 LinkedList 区别？<br>答：<br>ArrayList 和 LinkedList 是 Java 中常用的两种集合框架。它们的最主要的区别在于它们实现的数据结构不同。</p><p>ArrayList 是基于数组实现的动态数组，它允许随机访问元素，因此可以通过索引快速访问集合中的任何元素。当需要频繁地访问、遍历元素时，ArrayList 的性能很好。但是，当需要在集合的中间或起始位置插入或删除元素时，需要对数组进行移动，因此这样的操作会比较耗时。</p><p>LinkedList 是基于链表实现的双向链表，它允许快速地在任何位置插入或删除元素，因为只需要改变相应节点的指针即可。但是，由于链表中每个节点都需要存储指向前后节点的指针，因此需要更多的内存空间来存储相同数量的元素。此外，由于无法随机访问元素，所以当需要访问或遍历元素时，LinkedList 的性能会比 ArrayList 差。</p><p>因此，当需要频繁地插入或删除元素时，可以选择 LinkedList，而当需要频繁地访问元素时，可以选择 ArrayList。</p></li><li><p>ArrayList 与 Vector 区别呢？为什么要用 ArrayList 取代 Vector 呢？<br>答：<br>ArrayList 和 Vector 都是 Java 中的集合类，它们的主要区别在于线程安全和性能方面。</p><p>Vector 是线程安全的，它的所有方法都是同步的，因此在多线程环境下使用是安全的。但是，同步会带来一定的性能开销，所以在单线程环境下使用 Vector 可能会比较慢。</p><p>而 ArrayList 不是线程安全的，它的方法都不是同步的，因此在多线程环境下使用需要额外考虑线程安全的问题。但是，由于不需要同步，所以在单线程环境下使用 ArrayList 比 Vector 快。</p><p>因此，如果在多线程环境下需要使用集合类，则应使用 Vector；如果在单线程环境下使用集合类，则应使用 ArrayList。</p><p>另外，由于现在计算机的硬件性能越来越高，而且 Java 的并发编程库也越来越完善，所以在很多情况下，使用线程安全的 Vector 反而会成为性能瓶颈。因此，一般建议在单线程环境下使用 ArrayList，同时在多线程环境下使用 Java 的并发编程库中的线程安全集合类，如 ConcurrentHashMap、ConcurrentLinkedQueue 等。</p></li><li><p>Java.util.ArrayList 常用的方法有哪些？<br>答：<br>Java.util.ArrayList 是一个常用的动态数组类，提供了许多有用的方法来操作和管理数组元素。以下是一些常见的方法：<br>① add(Object obj)：向列表中添加一个元素。<br>② add(int index, Object obj)：在指定索引处添加一个元素。<br>③ remove(Object obj)：从列表中删除指定元素。<br>④ remove(int index)：从列表中删除指定索引处的元素。<br>⑤ get(int index)：返回列表中指定索引处的元素。<br>⑥ set(int index, Object obj)：将列表中指定索引处的元素替换为指定元素。<br>⑦ size()：返回列表中元素的个数。<br>⑧ clear()：从列表中删除所有元素。<br>⑨ isEmpty()：如果列表为空，则返回 true，否则返回 false。<br>⑩ contains(Object obj)：如果列表包含指定元素，则返回 true，否则返回 false。</p><p>这些方法可以让您方便地操作和管理 Java.util.ArrayList 中的元素。</p></li><li><p>Arraylist 是有序还是无序？为什么？<br>答：<br>ArrayList 是有序的。它是一个基于数组的动态数据结构，可以根据索引访问其中的元素。插入和删除元素时，它会自动调整内部数组的大小和元素的位置，以保持元素的顺序。</p><p>在 ArrayList 中，元素的顺序是按照它们添加到列表中的顺序排列的。因此，第一个添加到 ArrayList 的元素将始终是第一个元素，第二个添加的元素将始终是第二个元素，以此类推。</p><p>相比之下，HashSet 和 HashMap 是无序的，因为它们使用哈希表来存储元素，而哈希表中的元素没有特定的顺序。</p></li><li><p>Set 集合有哪些实现类，分别有什么特点？<br>答：<br>Java 中，Set 集合有以下实现类：<br>① HashSet：基于哈希表实现，不保证元素的顺序，允许使用 null 元素，具有快速的添加、删除和查找操作。<br>② LinkedHashSet：基于哈希表和双向链表实现，可以维护元素的插入顺序，允许使用 null 元素，具有快速的添加、删除和查找操作。<br>③ TreeSet：基于红黑树实现，可以按照元素的自然顺序或指定的 Comparator 进行排序，不允许使用 null 元素，具有快速的添加、删除和查找操作，但是比 HashSet 和 LinkedHashSet 慢。</p><p>这些实现类都实现了 Set 接口，因此具有相同的基本功能，包括添加、删除、查找元素等。不同的实现类适用于不同的场景，可以根据需求选择合适的实现类。例如，如果需要快速的添加、删除和查找操作，可以选择 HashSet 或 LinkedHashSet；如果需要按照元素的顺序进行排序，则可以选择 TreeSet。</p></li><li><p>List 集合和 Set 集合的区别？<br>答：<br>在 Java 中，List 和 Set 都是集合接口，它们都可以用来存储一组对象。但是，它们有以下区别：<br>① 重复元素：List 允许重复元素，而 Set 不允许重复元素。如果你尝试向一个 Set 中添加已经存在的元素，它将不会被添加到 Set 中。<br>② 排序：List 是有序的，而 Set 是无序的。在 List 中，元素按照它们被添加的顺序排序。而 Set 中没有这种顺序，元素的顺序是不确定的。<br>③ 访问元素：List 可以通过索引访问元素，而 Set 不能。在 List 中，你可以通过索引来访问特定位置的元素。而在 Set 中，你需要遍历整个集合来查找特定的元素。<br>④ 实现类：List 有许多实现类，如 ArrayList、LinkedList 等，而 Set 只有几个主要的实现类，如 HashSet、TreeSet 等。这些实现类具有不同的性能和行为特性，你需要根据你的需求来选择合适的实现类。</p><p>总之，如果你需要一个有序的集合并且允许重复元素，那么使用 List 是更好的选择；如果你需要一个不允许重复元素的无序集合，那么使用 Set 是更好的选择。</p></li><li><p>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?<br>答：<br>在 Java 中，Set 的元素是不能重复的，是通过比较对象的 equals()方法来判断元素是否重复的，而不是通过 == 运算符。</p><p>== 运算符比较的是两个对象的引用是否相同，即它们是否指向同一个对象。而 equals()方法比较的是两个对象的内容是否相同，即它们的属性值是否相等。</p><p>例如，假设有一个 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和getter/setter方法省略</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的代码中，equals()方法比较的是 Person 对象的属性值是否相等，而 hashCode()方法则返回一个基于属性值计算出来的哈希码，用于在 Set 中快速查找元素。</p><p>当你向一个 Set 中添加 Person 对象时，Set 会首先调用该对象的 hashCode()方法获取哈希码，然后根据哈希码找到相应的桶(bucket)，再在桶中查找是否有与该对象相等的元素。如果没有找到相等的元素，该对象就会被添加到 Set 中。</p><p>如果两个 Person 对象的属性值完全相同，那么它们的 hashCode()方法返回的哈希码也应该相同，这样才能使它们被放到同一个桶中。而 equals()方法则用于在桶中查找元素时比较两个对象是否相等。</p></li><li><p>TreeSet 两种排序方式在使用的时候怎么起作用？<br>答：<br>在 Java 中，TreeSet 是基于红黑树实现的集合类，它可以按照元素自然顺序（natural ordering）或者通过传入的 Comparator 排序来存储元素。</p><p>默认情况下，TreeSet 使用元素自然顺序进行排序。这意味着，如果要存储的元素实现了 Comparable 接口，即实现了 compareTo() 方法，那么 TreeSet 将使用该方法对元素进行排序。如果要存储的元素没有实现 Comparable 接口，那么在添加元素时会抛出 ClassCastException 异常。</p><p>如果要指定 TreeSet 使用传入的 Comparator 进行排序，需要在创建 TreeSet 对象时传入一个实现了 Comparator 接口的比较器对象。Comparator 接口中有一个 compare() 方法，可以用来比较两个元素的大小。在使用 Comparator 排序时，TreeSet 会使用该比较器对象的 compare() 方法来进行排序。</p><p>例如，以下代码演示了如何创建一个按照元素长度排序的 TreeSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        TreeSet&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">// 默认排序方式</span></span><br><span class="line">        set1.add(<span class="string">"apple"</span>);</span><br><span class="line">        set1.add(<span class="string">"banana"</span>);</span><br><span class="line">        set1.add(<span class="string">"orange"</span>);</span><br><span class="line">        System.out.println(set1); <span class="comment">// 输出 [apple, banana, orange]</span></span><br><span class="line"></span><br><span class="line">        Comparator&lt;String&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()</span><br><span class="line">        {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        TreeSet&lt;String&gt; set2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparator); <span class="comment">// 指定排序方式</span></span><br><span class="line">        set2.add(<span class="string">"apple"</span>);</span><br><span class="line">        set2.add(<span class="string">"banana"</span>);</span><br><span class="line">        set2.add(<span class="string">"orange"</span>);</span><br><span class="line">        System.out.println(set2); <span class="comment">// 输出 [apple, orange, banana]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>TreeSet 的数据结构？<br>答：<br>Java 中的 TreeSet 是一种基于红黑树的数据结构，它实现了 SortedSet 接口，并且能够保证集合中的元素处于有序状态。TreeSet 中的元素按照它们的自然顺序进行排序，或者可以通过提供一个 Comparator 来指定排序规则。</p><p>TreeSet 的基本操作包括添加、删除和查询元素，这些操作的时间复杂度都是 O(log n)，其中 n 是集合中的元素个数。由于 TreeSet 维护了一个有序状态，因此它还提供了一些与有序集合相关的操作，例如获取第一个元素、获取最后一个元素、获取小于或等于给定元素的最大元素、获取大于或等于给定元素的最小元素等等。</p><p>需要注意的是，TreeSet 中不允许存储重复的元素，因为它是一个集合而不是一个列表。如果需要存储重复的元素，可以考虑使用 Java 中的其他集合类，例如 ArrayList 或 LinkedList。</p></li><li><p>说一下 Java 的集合 Map 有哪些 Map？<br>答：<br>Java 中的集合 Map 是一种键值对存储结构，其中每个元素由一对键和值组成。Java 提供了多种不同类型的 Map，包括：<br>① HashMap：基于哈希表实现，提供快速的插入、查找和删除操作。它不保证元素的顺序，也不保证在多线程环境下的并发安全性。<br>② TreeMap：基于红黑树实现，提供有序的插入、查找和删除操作。它按照键的自然顺序或者指定的比较器进行排序。<br>③ LinkedHashMap：基于哈希表和双向链表实现，保证元素的插入顺序，也可以按照访问顺序进行排序。<br>④ WeakHashMap：基于哈希表实现，键值对的键是“弱引用”，当键不再被引用时会自动从 Map 中删除。<br>⑤ IdentityHashMap：基于哈希表实现，比较键时使用对象的“身份标识”而不是“相等性”。<br>⑥ EnumMap：基于数组实现，键必须是枚举类型，提供了枚举类型的高效存储和访问。<br>⑦ ConcurrentHashMap：基于分段锁机制实现，支持高并发的插入、查找和删除操作。</p><p>这些 Map 都实现了 Map 接口，提供了类似于 put、get、remove 等方法，但它们的实现方式和性能特点有所不同，开发者可以根据具体的需求选择合适的 Map 实现。</p></li><li><p>final 怎么用，修饰 Map 可以继续添加数据吗？<br>答：<br>在 Java 中，使用 final 关键字修饰的 Map 变量只是保证了该变量的引用不可更改，即不能再将该变量指向另一个 Map 对象。但是，Map 本身是可变的数据结构，即使使用 final 修饰，仍然可以向其中添加、删除、修改键值对。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"key1"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"key2"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map); <span class="comment">// 输出 {key1=1, key2=2}</span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">"key3"</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(map); <span class="comment">// 输出 {key1=1, key2=2, key3=3}</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，map 变量被声明为 final，但是我们仍然可以向其中添加新的键值对，而不会引发编译错误或运行时异常。</p><p>需要注意的是，如果在初始化 Map 对象时使用了 Collections.unmodifiableMap()方法，那么得到的 Map 对象就是不可变的，任何对其的修改操作都会导致 UnsupportedOperationException 异常。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, Integer&gt; map = Collections.unmodifiableMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">map.put(<span class="string">"key1"</span>, <span class="number">1</span>); <span class="comment">// 抛出 UnsupportedOperationException 异常</span></span><br></pre></td></tr></table></figure></li><li><p>Set 和 Map 的比较？<br>答：<br>Set 和 Map 是 Java 集合框架中两个不同的接口，它们之间有以下几个区别：<br>① 目的不同：Set 用于存储不重复的元素，而 Map 用于存储键值对。<br>② 实现方式不同：Set 使用了 HashSet、TreeSet 等实现方式，而 Map 使用了 HashMap、TreeMap 等实现方式。<br>③ 存储方式不同：Set 中只存储元素，而 Map 中存储键值对。<br>④ 访问方式不同：Set 中只能访问元素，而 Map 中可以通过键获取对应的值。<br>⑤ 迭代方式不同：Set 中使用迭代器遍历元素，而 Map 中使用迭代器遍历键值对或者通过遍历键或值的集合来遍历。</p><p>总之，Set 和 Map 是 Java 集合框架中两个不同的接口，它们之间的区别在于目的、实现方式、存储方式、访问方式和迭代方式。在使用时需要根据实际需求选择使用哪一个接口。</p></li><li><p>HashMap 说一下，线程安全吗？<br>答：<br>HashMap 是 Java 中的一种数据结构，它提供了一种快速的键值对映射关系。HashMap 不是线程安全的，因为它的实现是非同步的，它不能保证在多线程环境下的正确性。</p><p>在多线程环境下使用 HashMap 会存在并发访问的问题，可能会导致数据的不一致性或者抛出异常。如果需要在多线程环境下使用 HashMap，可以考虑使用 ConcurrentHashMap 或者使用同步控制来保证线程安全。ConcurrentHashMap 是线程安全的 HashMap 实现，使用了更加高效的并发控制算法，能够在多线程环境下保证线程安全和高效性能。而同步控制则可以使用 synchronized 或者 ReentrantLock 等机制来实现。</p></li><li><p>HashMap 和 Hashbable 的区别？<br>答：<br>HashMap 和 Hashable 是两个不同的概念。</p><p>在 Java 中，HashMap 是一种基于哈希表实现的数据结构，用于存储键值对。它允许快速访问、添加和删除元素，其时间复杂度为 O(1)。HashMap 中的键和值都可以为 null。在使用 HashMap 时，需要重写 hashCode()和 equals()方法。</p></li><li><p>Hashtable 是怎么实现的，为什么线程安全？<br>答：<br>Hashtable 是一种将键映射到值的数据结构，其实现方式基于哈希表。在哈希表中，每个键都被映射到一个整数索引，该索引指向存储值的桶。在 Hashtable 中，每个键值对都被存储在一个 Entry 对象中，该对象包括键、值和指向下一个 Entry 对象的指针。哈希表中的每个桶都是一个链表，存储具有相同哈希值的 Entry 对象。</p><p>Hashtable 是线程安全的，因为它的访问方法都是同步的。Hashtable 的每个公共方法都使用 synchronized 关键字进行同步，以确保在多线程环境下数据的正确性和一致性。当一个线程访问 Hashtable 中的一个方法时，它会获取对象的锁定，这将阻止其他线程同时访问 Hashtable。因此，Hashtable 保证了在多线程环境中的线程安全性。然而，由于同步是需要开销的，所以在高并发环境下，使用 ConcurrentHashMap 等其他并发集合可能会比 Hashtable 更高效。</p></li><li><p>HashMap 和 LinkedHashMap 的区别？<br>答：<br>HashMap 和 LinkedHashMap 都是 Java 中的 Map 接口的实现类，它们的主要区别在于它们维护键值对的方式不同。</p><p>HashMap 使用哈希表来存储键值对，它通过将键对象的哈希码映射到内部数组中的位置来快速查找值。由于哈希表的内部结构是基于哈希函数的，所以 HashMap 的查找效率非常高。但是，由于哈希表不维护插入元素的顺序，因此 HashMap 并不保证遍历顺序和插入顺序相同。</p><p>相反，LinkedHashMap 维护了一个双向链表来保持插入顺序。它在 HashMap 的基础上添加了一个指向前一个节点和后一个节点的指针来维护插入顺序。因此，当你遍历一个 LinkedHashMap 时，它的遍历顺序就是插入顺序。</p><p>在使用 HashMap 和 LinkedHashMap 时，你需要根据自己的需求来选择不同的实现类。如果你需要高效的查找操作，并且不需要保证遍历顺序和插入顺序相同，那么 HashMap 是更好的选择。如果你需要保证遍历顺序和插入顺序相同，那么你应该使用 LinkedHashMap。</p></li><li><p>HashMap 和 TreeMap 的区别？<br>答：<br>HashMap 和 TreeMap 都是 Java 中常用的集合类，它们的主要区别在于实现方式和性能表现。</p><p>HashMap 是基于哈希表实现的，它可以快速地进行插入、查找和删除操作，时间复杂度为 O(1)。但是 HashMap 中的元素是无序的，不支持按照键的顺序进行遍历。</p><p>TreeMap 是基于红黑树实现的，它可以自动按照键的顺序进行排序，因此支持按照键的顺序进行遍历。但是 TreeMap 的插入、查找和删除操作的时间复杂度为 O(log n)，稍微慢一些。</p><p>另外，HashMap 允许 key 和 value 为 null，而 TreeMap 不允许 key 为 null。在使用 HashMap 时需要注意 key 的 hashcode 和 equals 方法的正确实现，否则可能会出现意外的结果；而在使用 TreeMap 时需要注意 key 的比较器的正确实现，否则也可能会出现意外的结果。</p><p>因此，如果需要快速地进行插入、查找和删除操作，并且不需要按照键的顺序进行遍历，可以使用 HashMap；如果需要按照键的顺序进行遍历，可以使用 TreeMap。</p></li><li><p>HashMap 里面实际装的是什么？<br>答：<br>在 JDK 7 中，HashMap 内部使用 Entry 类来表示键值对，每个 Entry 包含一个 key 和一个 value，并且可以用链表的形式将多个 Entry 连接起来，以处理哈希冲突。但是，在 JDK 8 中，Entry 被替换为了 Node，它与 Entry 类似，但是还包含了一个 hash 值，用于快速定位桶中的元素。</p><p>通过使用 Node，JDK 8 可以更高效地处理哈希冲突，同时还可以减少在桶中存储的对象数量，从而减少了内存开销。此外，JDK 8 还引入了红黑树来优化 HashMap，当链表长度过长时，会将链表转换为红黑树，以提高性能。</p></li><li><p>HashMap 的 key 存储在哪里？和 value 存储在一起吗？那么 value 存储在哪里？说具体点？<br>答：<br>在 Java 中，HashMap 的 key 是存储在一个数组中的，而 value 则是存储在相应的节点(Node)中。具体来说，HashMap 是通过一个数组来实现键值对存储的，该数组中的每个元素都是一个单向链表的头节点，每个链表节点则包含了一个键值对。如果链表中的元素数量过多，链表会被转换为红黑树，以提高查找效率。</p><p>下面是 HashMap 中的主要组成部分：<br>① 数组：HashMap 内部存储键值对的数据结构是一个数组，数组中的每个元素都是一个单向链表的头节点。<br>② 链表：当 HashMap 中的元素数量较少时，每个数组元素对应的链表中会存储一个或多个键值对。<br>③ Node：当 HashMap 中的元素数量较多时，每个数组元素对应的链表会被转换为红黑树，每个节点都是一个 Node 对象，包含了一个键值对，以及指向下一个节点的指针。<br>④ 红黑树：当链表中的元素数量过多时，链表会被转换为红黑树，以提高查找效率。</p><p>因此，HashMap 的 key 存储在数组中，而 value 则存储在节点(Node)中，这些节点可以是链表节点或红黑树节点。每个节点都包含了一个键值对，以及指向下一个节点的指针。</p></li><li><p>自定义类型可以作为 Key 么？<br>答：<br>是的，Java 中自定义类型可以作为 Key。</p><p>在 Java 中，作为 Key 的类型必须实现 equals()和 hashCode()方法，这是因为 Java 中的 Map 和 Set 都是基于哈希表实现的。如果自定义类型没有实现这两个方法，那么在使用 Map 或 Set 时可能会导致意外的行为。</p><p>equals()方法用于比较两个对象是否相等，通常需要比较对象的成员变量。hashCode()方法用于计算哈希码，通常需要基于对象的成员变量计算哈希码。</p><p>例如，假设我们有一个自定义类型 Person，它有两个成员变量 name 和 age：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里我们实现了 equals()和 hashCode()方法，使得 Person 类型可以作为 Map 或 Set 的 Key。在比较两个 Person 对象是否相等时，我们比较它们的 name 和 age 成员变量。在计算哈希码时，我们基于 name 和 age 计算哈希码。这样，我们就可以在 Map 或 Set 中使用 Person 类型作为 Key 了。</p></li><li><p>集合类的工具类是谁？用过工具类哪些方法？<br>答：<br>Java 中，集合类的工具类是 java.util.Collections。</p><p>java.util.Collections 类提供了很多静态方法来操作集合，例如：</p><ul><li>sort(List<t> list)：对给定的列表进行升序排序。</t></li><li>reverse(List<t> list)：反转给定列表中元素的顺序。</t></li><li>shuffle(List&lt;?&gt; list)：随机打乱给定列表中元素的顺序。</li><li>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)：在给定的列表中使用二分查找算法查找指定元素。</li><li>addAll(Collection&lt;? super T&gt; c, T… elements)：向给定的集合中添加一个或多个元素。</li><li>frequency(Collection&lt;?&gt; c, Object o)：返回给定集合中指定元素的出现次数。</li><li>max(Collection&lt;? extends T&gt; coll)：返回给定集合中的最大元素。</li><li>min(Collection&lt;? extends T&gt; coll)：返回给定集合中的最小元素。</li></ul><p>这些方法是 java.util.Collections 类中的一部分，还有其他方法可供使用。使用这些方法可以方便地对集合进行操作。</p></li><li><p>Collection 和 Collections 的区别？<br>答：<br>Collection 和 Collections 是两个不同的概念。</p><p>Collection 是 Java 中的一个接口，它是 Java 集合框架中的一个基础接口，定义了一些常用的集合操作方法，包括添加、删除、遍历、查询等。它是 List、Set、Queue、Deque、Map 等集合接口的父接口。</p><p>Collections 是 Java 中的一个工具类，它提供了一系列静态方法，用于操作集合对象。它包括了对集合的排序、查找、替换、填充、复制等操作。它是对 Java 集合框架的一个补充，可以方便地操作集合对象。</p><p>因此，可以看出，Collection 和 Collections 是两个不同的概念。Collection 是一个接口，定义了集合的基本操作；而 Collections 是一个工具类，提供了对集合进行操作的静态方法。</p></li><li><p>ArrayList 如何实现排序？<br>答：<br>在 Java 中，可以使用 Collections 类的 sort() 方法对 ArrayList 进行排序。</p><p>假设要对一个 ArrayList 对象进行排序，可以按照以下步骤进行：<br>① 导入 java.util.Collections 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br></pre></td></tr></table></figure><p>② 调用 Collections 类的 sort() 方法，将要排序的 ArrayList 对象作为参数传递给该方法。例如，假设要对名为 list 的 ArrayList 对象进行排序，可以使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure><p>③ 如果要对自定义对象进行排序，则需要在该对象中实现 Comparable 接口，并重写 compareTo() 方法。compareTo() 方法用于定义对象之间的比较规则，以便在排序时进行比较。例如，假设要对一个名为 Person 的自定义类进行排序，可以使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 compareTo() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 根据年龄进行比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个类中使用 sort() 方法进行排序</span></span><br><span class="line">ArrayList&lt;Person&gt; people = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">people.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Bob"</span>, <span class="number">30</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Charlie"</span>, <span class="number">20</span>));</span><br><span class="line">Collections.sort(people);</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 类实现了 Comparable 接口，并重写了 compareTo() 方法，根据年龄进行比较。在排序时，使用 Collections.sort() 对 people 列表进行排序。</p></li><li><p>HashMap 是否线程安全，怎样解决 HashMap 的线程不安全？<br>答：<br>HashMap 是非线程安全的数据结构，因为它不是同步的。这意味着，如果多个线程同时访 HashMap，并且其中一个线程在对其进行修改，则可能导致 HashMap 的状态不一致，从而导致数据的破坏。</p><p>为了解决 HashMap 的线程不安全问题，可以采用以下几种方法：</p><p>① 使用 ConcurrentHashMap 类：ConcurrentHashMap 是 Java 中一个线程安全的 Map 实现，它使用锁分段技术来保证线程安全，使得多个线程可以同时访问不同的分段，从而提高并发性能。</p><p>② 使用 Collections.synchronizedMap()方法：该方法将 HashMap 包装成一个线程安全的 Map，使用了同步块来保证线程安全，但是性能相对较差，因为所有的操作都需要获得同步锁。</p><p>③ 使用 Lock 接口：可以使用 Java 中的 Lock 接口来实现线程安全的 HashMap，例如使用 ReentrantLock。这种方法需要手动加锁和解锁，需要注意加锁和解锁的顺序，否则可能会导致死锁。</p><p>总之，如果需要在多线程环境下使用 HashMap，应该使用线程安全的 Map 实现，例如 ConcurrentHashMap，以避免数据的破坏和不一致。</p></li></ol><h1>第 13 章 泛型</h1><h2 id="13-1-泛型的理解">13.1 泛型的理解</h2><p>&lt; E &gt; ，泛型参数，使用引用数据类型来赋值。</p><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值或参数的类型。这个类型参数将在使用时（例如，继承或实现这个接口、创建对象或调用方法时）确定（即传入实际的类型参数，也称为类型实参）。</p><h2 id="13-2-泛型在集合、比较器中的使用">13.2 泛型在集合、比较器中的使用</h2><p>Java 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。同时，代码更加简洁、健壮。</p><p>把一个集合中的内容限制为一个特定的数据类型，这就是泛型背后的核心思想。</p><h3 id="13-2-1-集合中使用泛型">13.2.1 集合中使用泛型</h3><p>Java 泛型可以在集合中用于定义集合中元素的类型。使用泛型可以确保集合中只包含指定类型的元素，避免了类型转换错误和运行时错误。下面是 Java 泛型在 List 和 Map 中的使用示例：</p><p>List 中的泛型代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 List，元素类型为 String</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">"apple"</span>);</span><br><span class="line">list.add(<span class="string">"banana"</span>);</span><br><span class="line">list.add(<span class="string">"orange"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (String fruit : list)</span><br><span class="line">{</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Map 中的泛型代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Map，键类型为 String，值类型为 Integer</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">map.put(<span class="string">"apple"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"banana"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"orange"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</span><br><span class="line">{</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">" -&gt; "</span> + entry.getValue());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这些示例中，泛型 &lt; String &gt; 和 &lt; String, Integer &gt; 定义了集合中元素的类型。在 List 中，我们可以将元素添加到集合中并遍历集合中的元素。在 Map 中，我们可以将键值对添加到集合中并遍历键值对。</p><h3 id="13-2-2-比较器中使用泛型">13.2.2 比较器中使用泛型</h3><p>Java 泛型可以在比较器中使用，以便于对不同类型的对象进行比较。下面是一个代码示例，演示如何使用 Java 泛型创建一个比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T a, T b)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 T extends Comparable&lt; T &gt; 来限定泛型类型 T 必须实现 Comparable 接口，这样我们才能使用 a.compareTo(b) 方法比较两个对象的大小。</p><p>我们还可以使用 T 类型的 Comparator 对象来创建一个比较器，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        numbers.add(<span class="number">3</span>);</span><br><span class="line">        numbers.add(<span class="number">1</span>);</span><br><span class="line">        numbers.add(<span class="number">4</span>);</span><br><span class="line">        numbers.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> <span class="title class_">MyComparator</span>&lt;&gt;();</span><br><span class="line">        Collections.sort(numbers, comparator);</span><br><span class="line"></span><br><span class="line">        System.out.println(numbers); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们创建了一个 MyComparator 对象，并将其传递给 Collections.sort 方法进行排序。由于 MyComparator 实现了 Comparator&lt; Integer &gt; 接口，因此可以将其用于比较 Integer 类型的对象。最后，我们输出了排序后的结果。</p><p>注意，在上面的示例中，我们使用了 Integer 类型作为泛型类型，但实际上，任何实现了 Comparable 接口的类型都可以作为泛型类型。</p><h2 id="13-3-自定义泛型类、泛型接口、泛型方法">13.3. 自定义泛型类、泛型接口、泛型方法</h2><p>泛型（Generics）是 Java 中的一项重要特性，它可以让我们编写更加通用和类型安全的代码。Java 中的泛型可以应用于类、接口、方法等不同的场景中。</p><h3 id="13-3-1-自定义泛型类">13.3.1 自定义泛型类</h3><p>在 Java 中，我们可以通过在类名后面使用尖括号定义泛型参数，来创建一个泛型类。泛型类可以使用任意类型作为其参数类型，包括基本类型和引用类型。</p><p>以下是一个简单的泛型类代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyGenericClass</span><span class="params">(T data)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 MyGenericClass 的泛型类，它有一个类型参数 T。在构造方法中，我们使用泛型参数 T 来定义一个数据成员 data。在 getData() 方法中，我们使用泛型参数 T 作为返回值类型。</p><p>使用泛型类时，我们需要在实例化时指定具体的类型参数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyGenericClass&lt;Integer&gt; myIntObj = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">MyGenericClass&lt;String&gt; myStringObj = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;&gt;(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们分别创建了一个 MyGenericClass 类型的对象 myIntObj 和 myStringObj，它们的类型参数分别是 Integer 和 String。</p><h3 id="13-3-2-自定义泛型接口">13.3.2 自定义泛型接口</h3><p>在 Java 中，我们也可以定义泛型接口。定义方式与泛型类类似，只需在接口名后面添加尖括号并指定泛型参数即可。</p><p>以下是一个简单的泛型接口代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyGenericInterface</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 MyGenericInterface 的泛型接口，它有一个类型参数 T。在接口中，我们定义了一个 getValue() 方法，它的返回值类型为泛型参数 T。</p><p>实现泛型接口时，需要指定具体的类型参数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntegerClass</span> <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;Integer&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringClass</span> <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;String&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们分别实现了 MyGenericInterface 接口，并指定了具体的类型参数。MyIntegerClass 类的 getValue() 方法返回一个 Integer 类型的值，而 MyStringClass 类的 getValue() 方法返回一个 String 类型的值。</p><h3 id="13-3-3-自定义泛型方法">13.3.3 自定义泛型方法</h3><p>除了泛型类和泛型接口外，Java 中还支持定义泛型方法。泛型方法是在方法返回类型前添加尖括号并指定泛型参数的方法。</p><p>以下是一个简单的泛型方法代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getValue</span><span class="params">(T[] arr, <span class="type">int</span> index)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 getValue 的泛型方法，它有两个参数：一个泛型数组 arr 和一个整型变量 index。在方法返回类型前，我们使用泛型参数 T 来指定返回值类型。在方法体中，我们通过数组下标获取指定位置的元素，并返回它。</p><p>使用泛型方法时，我们可以在调用方法时指定具体的类型参数，也可以让编译器自动推断类型参数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">String[] strArr = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">intVal</span> <span class="operator">=</span> MyGenericMethod.&lt;Integer&gt;getValue(intArr, <span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> MyGenericMethod.&lt;String&gt;getValue(strArr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(intVal); <span class="comment">// 输出 2</span></span><br><span class="line">System.out.println(strVal); <span class="comment">// 输出 "hello"</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们分别调用了 MyGenericMethod.getValue() 方法，并指定了具体的类型参数。我们也可以省略类型参数，让编译器根据方法参数类型推断出类型参数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">intVal</span> <span class="operator">=</span> MyGenericMethod.getValue(intArr, <span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> MyGenericMethod.getValue(strArr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(intVal); <span class="comment">// 输出 2</span></span><br><span class="line">System.out.println(strVal); <span class="comment">// 输出 "hello"</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们省略了类型参数，编译器根据方法参数类型自动推断出类型参数。</p><h2 id="13-4-泛型在继承上的体现">13.4 泛型在继承上的体现</h2><ul><li><p>类 SuperA 是类 A 的父类，则 G&lt; SuperA &gt; 与 G&lt; A &gt; 的关系：G&lt; SuperA &gt; 和 G&lt; A &gt;是并列的两个类，没有任何子父类的关系。</p></li><li><p>比如：ArrayList&lt; Object &gt; 、ArrayList&lt; String &gt;没有关系。</p></li><li><p>类 SuperA 是类 A 的父类或接口，SuperA&lt; G &gt; 与 A&lt; G &gt;的关系：SuperA&lt; G &gt; 与 A&lt; G &gt; 有继承或实现的关系。即 A&lt; G &gt;的实例可以赋值给 SuperA&lt; G &gt;类型的引用（或变量）。</p></li><li><p>比如：List&lt; String &gt; 与 ArrayList&lt; String &gt;。</p></li></ul><h2 id="13-5-通配符的使用">13.5 通配符的使用</h2><ul><li>? 的使用<ul><li>以集合为例：可以读取数据、不能写入数据。（例外：null）</li></ul></li><li>? extends A<ul><li>以集合为例：可以读取数据、不能写入数据。（例外：null）</li></ul></li><li>? super A<ul><li>以集合为例：可以读取数据、可以写入 A 类型或 A 类型子类的数据。（例外：null）</li></ul></li></ul><h2 id="13-6-企业真题">13.6 企业真题</h2><ol><li><p>Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？<br>答：<br>Java 的泛型是一种编程语言特性，它允许在编写代码时指定一种数据类型，这种类型可以在运行时确定。具体来说，泛型可以用来创建类、接口和方法，允许在定义这些结构时使用类型参数。</p><p>Java 泛型的好处和优点有很多，包括：<br>① 类型安全性：使用泛型可以在编译时检查类型匹配，避免在运行时出现类型错误导致的异常。<br>② 代码重用性：使用泛型可以编写通用代码，可以用于处理各种类型的数据，从而提高代码重用性。<br>③ 代码可读性：使用泛型可以使代码更加清晰和易读，因为它可以显式地指定参数类型，避免了类型转换和强制类型声明的冗余代码。<br>④ 更好的性能：使用泛型可以消除对象类型转换的开销，从而提高程序的性能。</p><p>JDK 不同版本的泛型有一些区别，主要是在编译器的类型擦除和泛型语法的支持方面。以下是一些主要的区别：</p><p>① Java 5 之前的版本没有泛型，需要使用 Object 类型来实现类似的功能。<br>② Java 5 中引入了泛型，但是它的实现方式是通过类型擦除来实现的，这意味着在编译期间会将泛型类型擦除为原始类型，从而在运行时无法获得泛型类型信息。<br>③ Java 7 中引入了菱形语法，允许在实例化泛型类型时省略泛型类型的实际参数。<br>④ Java 8 中引入了类型推断，允许编译器根据上下文推断泛型类型，从而提高代码的可读性和简洁性。</p><p>总的来说，泛型是 Java 语言中非常有用的特性，可以提高程序的安全性、可读性和性能，同时也有很多实际应用场景。</p></li><li><p>说说你对泛型的了解？<br>答：<br>泛型是一种编程语言特性，它可以让代码具有更高的灵活性和可重用性。泛型可以在类型安全的前提下，让代码适用于多种不同的数据类型，从而避免了代码的重复编写和维护，提高了代码的可维护性和可读性。</p><p>在 Java 中，泛型可以用来定义类、接口和方法。通过在定义时使用类型参数（例如，T、E 等），可以将类型的具体实现推迟到使用泛型的时候再确定。这样，一个泛型类或方法可以适用于多种不同的数据类型，而不需要为每种数据类型都编写一个独立的类或方法。Java 中的泛型可以实现类型擦除，即在编译时擦除类型信息，使得泛型代码在运行时和非泛型代码一样高效。</p><p>泛型是一种非常有用的编程特性，可以提高代码的可重用性和可读性，是面向对象编程中不可或缺的一部分。</p></li></ol><h1>第 14 章 数据结构与集合源码</h1><h2 id="14-1-数据结构">14.1 数据结构</h2><p>数据结构，就是一种程序设计优化的方法论，研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，目的是加快程序的执行速度、减少内存占用的空间。</p><p><img src="https://img-blog.csdnimg.cn/be633cdc591e401996112d941f0d8acc.png" alt="数据结构"></p><h3 id="14-1-1-研究对象一：数据间逻辑关系">14.1.1 研究对象一：数据间逻辑关系</h3><p>数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。</p><ul><li>集合结构：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。</li><li>线性结构：数据结构中的元素存在一对一的相互关系。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列。</li><li>树形结构：数据结构中的元素存在一对多的相互关系。</li><li>图形结构：数据结构中的元素存在多对多的相互关系。</li></ul><h3 id="14-1-2-研究对象二：数据的存储结构">14.1.2 研究对象二：数据的存储结构</h3><p>数据的物理结构/存储结构：包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p><ul><li><p>结构 1：顺序结构</p><ul><li>顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。</li><li>优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。</li><li>缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低</li></ul></li><li><p>结构 2：链式结构</p><ul><li>不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。</li><li>优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。</li><li>缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。</li></ul></li><li><p>结构 3：索引结构</p><ul><li>除建立存储节点信息外，还建立附加的索引表来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。</li><li>优点：用节点的索引号来确定结点存储地址，检索速度快。</li><li>缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。</li></ul></li><li><p>结构 4：散列结构</p><ul><li>根据元素的关键字直接计算出该元素的存储地址，又称为 Hash 存储。</li><li>优点：检索、增加和删除结点的操作都很快。</li><li>缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。</li></ul></li></ul><h3 id="14-1-3-研究对象三：运算结构">14.1.3 研究对象三：运算结构</h3><ul><li>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li><li>分配资源，建立结构，释放资源。</li><li>插入和删除。</li><li>获取和遍历。</li><li>修改和排序。</li></ul><h2 id="14-2-数组">14.2 数组</h2><p>在 Java 中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。</p><p>物理结构特点：</p><ul><li>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</li><li>不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢。</li><li>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</li></ul><h2 id="14-3-链表">14.3 链表</h2><ul><li>逻辑结构：线性结构。</li><li>物理结构：不要求连续的存储空间。</li><li>存储特点：链表由一系列结点 node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</li><li>常见的链表结构有：单链表、双链表、循环单链表。</li></ul><h2 id="14-4-栈">14.4 栈</h2><ul><li><p>栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。</p></li><li><p>栈按照先进后出(FILO,first in last out)的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。</p></li><li><p>核心类库中的栈结构有 Stack 和 LinkedList。</p><ul><li>Stack 就是顺序栈，它是 Vector 的子类。</li><li>LinkedList 是链式栈。</li></ul></li><li><p>体现栈结构的操作方法：</p><ul><li>peek()方法：查看栈顶元素，不弹出。</li><li>pop()方法：弹出栈。</li><li>push(E e)方法：压入栈。</li></ul></li><li><p>时间复杂度:</p><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul></li></ul><h2 id="14-5-队列">14.5 队列</h2><ul><li>队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。</li><li>队列是逻辑结构，其物理结构可以是数组，也可以是链表。</li><li>队列的修改原则：队列的修改是依先进先出（FIFO）的原则进行的。新来的成员总是加入队尾（即不允许"加塞"），每次离开的成员总是队列头上的（不允许中途离队），即当前"最老的"成员离队。</li></ul><h2 id="14-6-树与二叉树">14.6 树与二叉树</h2><h3 id="14-6-1-树">14.6.1 树</h3><ul><li>结点：树中的数据元素都称之为结点。</li><li>根节点：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根。</li><li>父节点：结点的上层结点。</li><li>子节点：节点的下层结点。</li><li>兄弟节点：具有相同父节点的结点称为兄弟节点。</li><li>结点的度数：每个结点所拥有的子树的个数称之为结点的度。</li><li>树叶：度数为 0 的结点，也叫作终端结点。</li><li>非终端节点（或分支节点）：树叶以外的节点，或度数不为 0 的节点。</li><li>树的深度（或高度）：树中结点的最大层次数。</li><li>结点的层数：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为 1，其余结点的层数等于其父亲结点的层数 + 1。</li><li>同代：在同一棵树中具有相同层数的节点。</li></ul><h3 id="14-6-2-二叉树的基本概念">14.6.2 二叉树的基本概念</h3><p>二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p><h3 id="14-6-3-二叉树的遍历">14.6.3 二叉树的遍历</h3><ul><li><p>前序遍历：中左右（根左右）</p><ul><li>即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。</li></ul></li><li><p>中序遍历：左中右（左根右）</p><ul><li>即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。</li></ul></li><li><p>后序遍历：左右中（左右根）</p><ul><li>即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。</li></ul></li></ul><h3 id="14-6-4-经典二叉树">14.6.4 经典二叉树</h3><ul><li><p>满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第 n 层的结点数是 2 的 n - 1 次方，总的结点个数是 2 的 n 次方 - 1。</p></li><li><p>完全二叉树： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p></li><li><p>二叉排序/查找/搜索树：即为 BST (binary search/sort tree)。满足如下性质：</p><ul><li>若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值。</li><li>若它的右子树上所有结点的值均大于它的根节点的值。</li><li>它的左、右子树也分别为二叉排序/查找/搜索树。</li></ul></li><li><p>平衡二叉树：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：</p><ul><li>它是一棵空树或它的左右两个子树的高度差的<br>绝对值不超过 1。</li><li>并且左右两个子树也都是一棵平衡二叉树。</li><li>不要求非叶节点都有两个子结点。</li></ul></li><li><p>平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。</p></li><li><p>红黑树：即 Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p></li><li><p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。</p></li><li><p>红黑树的特性：</p><ul><li>每个节点是红色或者黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL 或 NULL)的叶子节点）</li><li>每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。（确保没有一条路径会比其他路径长出 2 倍）</li></ul></li><li><p>当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上 5 个要求，那么此时就需要进行处理，使得它继续满足以上的 5 个要求：</p><ul><li>recolor ：将某个节点变红或变黑。</li><li>rotation ：将红黑树某些结点分支进行旋转。（左旋或右旋）</li></ul></li><li><p>红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是 O(logN)，效率非常之高。</p></li></ul><h2 id="14-7-List-接口下的实现类的源码剖析">14.7 List 接口下的实现类的源码剖析</h2><h3 id="14-7-1-List-接口特点">14.7.1 List 接口特点</h3><ul><li><p>List 集合所有的元素是以一种线性方式进行存储的，例如，存元素的顺序是 11、22、33。那么集合中，元素的存储就是按照 11、22、33 的顺序完成的）。</p></li><li><p>它是一个元素存取有序的集合。即元素的存入顺序和取出顺序有保证。</p></li><li><p>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p></li><li><p>集合中可以有重复的元素，通过元素的 equals 方法，来比较是否为重复的元素。</p></li><li><p>注意：<br>List 集合关心元素是否有序，而不关心是否重复。</p></li><li><p>List 接口的主要实现类</p><ul><li>ArrayList：动态数组。</li><li>Vector：动态数组。</li><li>LinkedList：双向链表。</li><li>Stack：栈。</li></ul></li></ul><h3 id="14-7-2-动态数组-ArrayList-与-Vector">14.7.2 动态数组 ArrayList 与 Vector</h3><ul><li><p>Java 的 List 接口的实现类中有两个动态数组的实现：ArrayList 和 Vector。</p></li><li><p>ArrayList 与 Vector 的区别</p><ul><li>它们的底层物理结构都是数组，我们称为动态数组。</li><li>ArrayList 是新版的动态数组，线程不安全，效率高，Vector 是旧版的动态数组，线程安全，效率低。</li><li>动态数组的扩容机制不同，ArrayList 默认扩容为原来的 1.5 倍，Vector 默认扩容增加为原来的 2 倍。</li><li>数组的初始化容量，如果在构建 ArrayList 与 Vector 的集合对象时，没有显式指定初始化容量，那么 Vector 的内部数组的初始容量默认为 10，而 ArrayList 在 JDK 6.0 及之前的版本也是 10，JDK8.0 之后的版本 ArrayList 初始化为长度为 0 的空数组，之后在添加第一个元素时，再创建长度为 10 的数组。</li><li>原因：<ul><li>用的时候，再创建数组，避免浪费。因为很多方法的返回值是 ArrayList 类型，需要返回一个 ArrayList 的对象，例如：后期从数据库查询对象的方法，返回值很多就是 ArrayList。有可能你要查询的数据不存在，要么返回 null，要么返回一个没有元素的 ArrayList 对象。</li></ul></li></ul></li></ul><h3 id="14-7-3-ArrayList-部分源码分析">14.7.3 ArrayList 部分源码分析</h3><ul><li><p>JDK1.7 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[]elementData;    <span class="comment">// 存储底层数组元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;    <span class="comment">// 记录数组中存储的元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);    <span class="comment">// 指定初始容量为 10</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查初始容量的合法性</span></span><br><span class="line">    <span class="keyword">if</span>(initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组初始化为长度为 initialCapacity 的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);    <span class="comment">// 查看当前数组是否够多存一个元素</span></span><br><span class="line">    elementData[size++] = e;    <span class="comment">// 将元素 e 添加到 elementData 数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 if 条件满足，则进行数组的扩容</span></span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="comment">// 当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="comment">// 新数组容量是旧数组容量的1.5倍</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)    <span class="comment">// 判断旧数组的 1.5 倍是否够</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断旧数组的 1.5 倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    rangeCheck(index);    <span class="comment">//判断 index 是否在有效的范围内</span></span><br><span class="line">    modCount++;    <span class="comment">//修改次数加 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;    <span class="comment">// 确定要移动的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要移动元素，就用 System.arraycopy 移动元素</span></span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 elementData[size-1]位置置空，让 GC 回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= size)    <span class="comment">//index 不合法的情况</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">}</span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 返回指定位置的元素</span></span><br><span class="line">    <span class="keyword">return</span>(E)elementData[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：set()方法相关</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line">{</span><br><span class="line">    rangeCheck(index);    <span class="comment">// 检验 index 是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 element 替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    rangeCheck(index);    <span class="comment">// 检验 index 是否合法</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);    <span class="comment">// 返回[index]位置的元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 分为 o 是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 从前往后找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span>(elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">             <span class="keyword">if</span>(o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：lastIndexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 分为 o 是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 从后往前找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    <span class="comment">// 初始化为空数组</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法:add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 查看当前数组是否够多存一个元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);    <span class="comment">// Increments modCount!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入新元素到[size]位置，然后 size 自增 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果当前数组还是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 那么 minCapacity 取 DEFAULT_CAPACITY 与 minCapacity 的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    modCount++;    <span class="comment">// 修改次数加 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="comment">// 当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="comment">// 新数组容量是旧数组容量的 1.5 倍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看旧数组的 1.5 倍是否够</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看旧数组的 1.5 倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-7-4-ArrayList-相关方法图示">14.7.4 ArrayList 相关方法图示</h3><ul><li><p>ArrayList 采用数组作为底层实现</p><p><img src="https://img-blog.csdnimg.cn/bf35acb6eec4491e9fa060f68a7cd594.png" alt="ArrayList 采用数组作为底层实现"></p></li><li><p>ArrayList 自动扩容过程</p><p><img src="https://img-blog.csdnimg.cn/747abc14935540c38e2f06039edb204f.png" alt="ArrayList 自动扩容过程"></p></li><li><p>ArrayList 的 add(E e)方法</p><p><img src="https://img-blog.csdnimg.cn/7b8b54c1590844cf812a962997103aa4.png" alt="ArrayList 的 add(E e)方法"></p></li><li><p>ArrayList 的 add(int index,E e)方法</p><p><img src="https://img-blog.csdnimg.cn/9a8f4bf2dc3e458c822aa339f6223711.png" alt="ArrayList 的 add(int index,E e)方法"></p></li></ul><h3 id="14-7-5-Vector-部分源码分析">14.7.5 Vector 部分源码分析</h3><ul><li><p>JDK1.8 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);    <span class="comment">// 指定初始容量 initialCapacity 为 10</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);    <span class="comment">// 指定 capacityIncrement 增量为 0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断了形参初始容量 initialCapacity 的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个 Object[]类型的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量，默认是 0，如果是 0，后面就按照 2 倍增加，如果不是 0，后面就按照你指定的增量进行增量</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：add()相关方法</span></span><br><span class="line"><span class="comment">// synchronized 意味着线程安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看是否需要扩容</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新的元素存入[elementCount]，存入后，elementCount 元素的个数增 1</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 看是否超过了当前数组的容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);    <span class="comment">// 扩容</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> 、</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="comment">// 获取目前数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 capacityIncrement 增量是 0，新容量 = oldCapacity 的 2 倍</span></span><br><span class="line">    <span class="comment">// 如果 capacityIncrement 增量是不是 0，新容量 = oldCapacity + capacityIncrement 增量;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">              capacityIncrement : oldCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把旧数组中的数据复制到新数组中，新数组的长度为 newCapacity</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span></span><br><span class="line">{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 obj 在当前 Vector 中的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        removeElementAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 要查找的元素是 null 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)    <span class="comment">// 如果是 null 值，用==null 判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//要查找的元素是非 null 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))    <span class="comment">// 如果是非 null 值，用 equals 判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：removeElementAt()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// j 是要移动的元素的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要移动元素，就调用 System.arraycopy 进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 把 index+1 位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">// index+1 的位置的元素移动到 index 位置，依次类推一共移动 j 个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被 GC 回收</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* to let gc do its work */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-7-6-链表-LinkedList">14.7.6 链表 LinkedList</h3><p>Java 中有双链表的实现：LinkedList，它是 List 接口的实现类。</p><h3 id="14-7-7-链表与动态数组的区别">14.7.7 链表与动态数组的区别</h3><ul><li>动态数组底层的物理结构是数组，因此根据索引访问的效率非常高。但是非末尾位置的插入和删除效率不高，因为涉及到移动元素。另外添加操作时涉及到扩容问题，就会增加时空消耗。</li><li>链表底层的物理结构是链表，因此根据索引访问的效率不高，即查找元素慢。但是插入和删除不需要移动元素，只需要修改前后元素的指向关系即可，所以插入、删除元素快。而且链表的添加不会涉及到扩容问题。</li></ul><h3 id="14-7-8-LinkedList-源码分析">14.7.8 LinkedList 源码分析</h3><ul><li><p>JDK1.8 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;   <span class="comment">// 记录第一个结点的位置</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;    <span class="comment">// 记录当前链表的尾元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    linkLast(e);    <span class="comment">// 默认把新元素链接到链表尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;    <span class="comment">// 用 l 记录原来的最后一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">      <span class="comment">// 那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 否则把新结点链接到原来的最后一个结点的 next 中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，Node 类定义如下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;</span><br><span class="line">{</span><br><span class="line">    E item;    <span class="comment">// 元素数据</span></span><br><span class="line">    Node&lt;E&gt; next;    <span class="comment">// 下一个结点</span></span><br><span class="line">    Node&lt;E&gt; prev;    <span class="comment">// 前一个结点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：获取 get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：插入 add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line">{</span><br><span class="line">    checkPositionIndex(index);   <span class="comment">// 检查 index 范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)   <span class="comment">// 如果 index==size，连接到当前链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">}</span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">isElementIndex</span><span class="params">(index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    index &lt; (size &gt;&gt; 1)采用二分思想，先将 index 与长度 size 的一半比较，</span></span><br><span class="line"><span class="comment">    如果 index&lt;size/2，就只从位置 0往后遍历到位置 index 处，</span></span><br><span class="line"><span class="comment">    而如果 index&gt;size/2，就只从位置 size 往前遍历到位置 index 处。</span></span><br><span class="line"><span class="comment">    这样可以减少一部分不必要的遍历。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 如果 index&lt;size/2，就从前往后找目标结点</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>))</span><br><span class="line">    {</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 否则从后往前找目标结点</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把新结点插入到[index]位置的结点 succ 前面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// succ 是[index]位置对应的结点</span></span><br><span class="line">    <span class="keyword">assert</span> succ != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;    <span class="comment">// [index]位置的前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新结点的 prev 是原来[index]位置的前一个结点</span></span><br><span class="line">    <span class="comment">// 新结点的 next 是原来[index]位置的结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [index]位置对应的结点的 prev 指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;    <span class="comment">// 原来[index]位置的前一个结点的 next 指向新结点</span></span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 分 o 是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 找到 o 对应的结点 x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                unlink(x);   <span class="comment">// 删除 x 结点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 找到 o 对应的结点 x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">            {</span><br><span class="line">                unlink(x);   <span class="comment">// 删除 x 结点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// x 是要被删除的结点</span></span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;    <span class="comment">// 被删除结点的数据</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;    <span class="comment">// 被删除结点的下一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;    <span class="comment">// 被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 被删除结点不是第一个结点</span></span><br><span class="line">        <span class="comment">// 被删除结点的上一个结点的 next 指向被删除结点的下一个结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开被删除结点与上一个结点的链接</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;    <span class="comment">// 使得 GC 回收</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 被删除结点不是最后一个结点</span></span><br><span class="line">        <span class="comment">// 被删除结点的下一个结点的 prev 执行被删除结点的上一个结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开被删除结点与下一个结点的连接</span></span><br><span class="line">        x.next = <span class="literal">null</span>;     <span class="comment">// 使得 GC 回收</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把被删除结点的数据也置空，使得 GC 回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数减少</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除结点的数据</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// index 是要删除元素的索引位置</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-7-9-LinkedList-相关方法图示">14.7.9 LinkedList 相关方法图示</h3><ul><li><p>只有 1 个元素的 LinkedList</p><p><img src="https://img-blog.csdnimg.cn/1a033ae656dc401b8334d21a9cf15f94.png" alt="只有 1 个元素的 LinkedList"></p></li><li><p>包含 4 个元素的 LinkedList</p><p><img src="https://img-blog.csdnimg.cn/0b7c3dbfc1de4e89a51d5820b12000ca.png" alt="包含 4 个元素的 LinkedList"></p></li><li><p>add(E e)方法</p><p><img src="https://img-blog.csdnimg.cn/d740cd8e572c4fc88b5924ebb88cbf27.png" alt="add(E e)方法"></p></li><li><p>add(int index,E e)方法</p><p><img src="https://img-blog.csdnimg.cn/5b03330c959a460d8940b2a6111e2be0.png" alt="add(int index,E e)方法"></p></li><li><p>remove(Object obj)方法</p><p><img src="https://img-blog.csdnimg.cn/e5b40e0b1fc3485495ea49289ee3ba3f.png" alt="remove(Object obj)方法"></p></li><li><p>remove(int index)方法</p><p><img src="https://img-blog.csdnimg.cn/02ac4449813e4b15843fac76efb46817.png" alt="remove(int index)方法"></p></li></ul><h2 id="14-8-Map-接口下的实现类的源码剖析">14.8 Map 接口下的实现类的源码剖析</h2><h3 id="14-8-1-哈希表的物理结构">14.8.1 哈希表的物理结构</h3><ul><li><p>HashMap 和 Hashtable 底层都是哈希表（也称散列表），其中维护了一个长度为 2 的幂次方的 Entry 类型的数组 table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个 Map.Entry 类型的对象，放到某个 table[index]桶中。</p></li><li><p>使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个 table[index]。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/f770dbb2920f413fbded363375037f42.png" alt="Java8 HashMap 结构"></p><h3 id="14-8-2-HashMap-中数据添加过程">14.8.2 HashMap 中数据添加过程</h3><ul><li><p>JDK7 中过程分析：</p><ul><li><p>在底层创建了长度为 16 的 Entry[] table 的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure><ul><li><p>分析过程如下：<br>① 将 (key1,value1) 添加到当前 hashmap 的对象中。首先会调用 key1 所在类的 hashCode() 方法，计算 key1 的哈希值 1，此哈希值 1 再经过某种运算(hash())，得到哈希值 2。此哈希值 2 再经过某种运算(indexFor())，确定在底层 table 数组中的索引位置 i。</p><ul><li><p>如果数组索引为 i 上的数据为空，则 (key1,value1) 直接添加成功，位置 1。</p></li><li><p>如果数组索引为 i 上的数据不为空，有 (key2,value2)，则需要进一步判断：</p><ul><li>判断 key1 的哈希值 2 与 key2 的哈希值是否相同：<ul><li>如果哈希值不同，则 (key1,value1) 直接添加成功，位置 2。</li><li>如果哈希值相同，则需要继续调用 key1 所在类的 equals() 方法，将 key2 放入 equals() 形参进行判断：<ul><li>equals 方法返回 false：则 (key1,value1) 直接添加成功，位置 3。</li><li>equals 方法返回 true：默认情况下，value1 会覆盖 value2。</li></ul></li></ul></li><li>位置 1：直接将 (key1,value1) 以 Entry 对象的方式存放到 table 数组索引 i 的位置。</li><li>位置 2、位置 3：(key1,value1) 与现有的元素以链表的方式存储在 table 数组索引 i 的位置，新添加的元素指向旧添加的元素。</li></ul><p>② 在不断的添加的情况下，满足如下条件的情况下，会进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) :</span><br></pre></td></tr></table></figure><p>默认情况下，当要添加的元素个数超过 12（即：数组的长度 * loadFactor 得到的结果）时，就要考虑扩容。</p></li><li><p>补充：JDK7 源码中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>获取 Map 集合中 key1 对应的 value 值的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.get(key1);</span><br></pre></td></tr></table></figure><p>① 计算 key1 的 hash 值，用这个方法 hash(key1)。<br>② 找 index = table.length-1 &amp; hash。<br>③ 如果 table[index] 不为空，那么就挨个比较哪个 Entry 的 key 与它相同，就返回它的 value。</p></li><li><p>从 Map 集合中删除 key1 及其对应的 value 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.remove(key1);</span><br></pre></td></tr></table></figure><p>① 计算 key1 的 hash 值，用这个方法 hash(key1)。<br>② 找 index = table.length-1 &amp; hash。<br>③ 如果 table[index] 不为空，那么就挨个比较哪个 Entry 的 key 与它相同，就删除它，把它前面的 Entry 的 next 的值修改为被删除 Entry 的 next。</p></li></ul></li><li><p>JDK8 中过程分析：</p><ul><li><p>下面说明是 JDK8 相较于 JDK7 的不同之处：<br>① 使用 HashMap()的构造器创建对象时，并没有在底层初始化长度为 16 的 table 数组。<br>② jdk8 中添加的 key,value 封装到了 HashMap.Node 类的对象中。而非 jdk7 中的 HashMap.Entry。<br>③ jdk8 中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非 jdk7 中的新的元素指向旧的元素。“七上八下”<br>④ jdk7 时底层的数据结构是：数组+单向链表。 而 jdk8 时，底层的数据结构是：数组+单向链表+红黑树。</p></li><li><p>红黑树出现的时机：当某个索引位置 i 上的链表的长度达到 8，且数组的长度超过 64 时，此索引位置上的元素要从单向链表改为红黑树。如果索引 i 位置是红黑树的结构，当不断删除元素的情况下，当前索引 i 位置上的元素的个数低于 6 时，要从红黑树改为单向链表。</p></li></ul></li></ul><h3 id="14-8-3-HashMap-源码剖析">14.8.3 HashMap 源码剖析</h3><ul><li><p>JDK1.7 中的源代码：</p><p><img src="https://img-blog.csdnimg.cn/a4e8983fc4e74d23904de144173277fd.png" alt="JDK1.7 中的 HashMap 结构"></p><ul><li><p>Entry：<br>key-value 被封装为 HashMap.Entry 类型，而这个类型实现了 Map.Entry 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="type">int</span> hash;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n)</span><br><span class="line">        {</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table 数组的默认初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表中 key-value 的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界值、阈值（扩容的临界值）</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY：默认初始容量 16</span></span><br><span class="line">    <span class="comment">// DEFAULT_LOAD_FACTOR：默认加载因子 0.75</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 校验 initialCapacity 合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal initial capacity:"</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 initialCapacity 合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 loadFactor 合法性</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算得到 table 数组的长度（保证 capacity 是 2 的整次幂）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载因子，初始化为 0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threshold 初始为默认容量</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 table 数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>put()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果 key 是 null，单独处理，存储到 table[0]中，如果有另一个 key 为 null，value 覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对 key 的 hashCode 进行干扰，算出一个 hash 值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * hashCode 值 xxxxxxxxxx table.length-1 000001111</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * hashCode 值 xxxxxxxxxx 无符号右移几位和原来的 hashCode 值做^运算， 使得 hashCode</span></span><br><span class="line"><span class="comment">     * 高位二进制值参与计算， 也发挥作用，降低 index 冲突的概率。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算新的映射关系应该存到 table[i]位置， i = hash &amp; table.length-1，可以保证 i</span></span><br><span class="line">    <span class="comment">// 在[0,table.length-1]范围内</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检查 table[i]下面有没有 key 与我新的映射关系的 key 重复，如果重复替换 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">    {</span><br><span class="line">        Object k;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">        {</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    modCount++;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加新的映射关系</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果 key 是 null，直接存入[0]的位置</span></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 判断是否有重复的 key，如果有重复的，就替换 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    modCount++;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 把新的映射关系存入[0]的位置，而且 key 的 hash 值用 0 表示</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (useAltHashing)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        h = hashSeed;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 判断是否需要库容</span></span><br><span class="line">    <span class="comment">// 扩容：（1）size 达到阈值（2）table[i]正好非空</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex]))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// table 扩容为原来的 2 倍，并且扩容后，会重新调整所有 key-value 的存储位置</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 新的 key-value 的 hash 和 index 也会重新计算</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 存入 table 中</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span></span><br><span class="line">{</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 原来 table[i]下面的映射关系作为新的映射关系 next</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p>JDK1.8 中的源代码：</p><p><img src="https://img-blog.csdnimg.cn/a7ef561869dc4f7db6212de447b08ec7.png" alt="JDK1.8 中的 HashMap 结构"></p><ul><li><p>Node：<br>key-value 被封装为 HashMap.Node 类型或 HashMap.TreeNode 类型，它俩都直接或间接的实现了 Map.Entry 接口。<br>存储到 table 数组的可能是 Node 结点对象，也可能是 TreeNode 结点对象，它们也是 Map.Entry 接口的实现类。即 table[index]下的映射关系可能串起来一个链表或一棵红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node 类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其它结构：......</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TreeNode 类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;</span><br><span class="line">    {</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red;    <span class="comment">// 是红结点还是黑结点</span></span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;    <span class="comment">// 默认的初始容量16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">// 最大容量 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;    <span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;    <span class="comment">// 默认树化阈值 8，当链表的长度达到这个值后，要考虑树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;    <span class="comment">// 默认反树化阈值 6，当树中结点的个数达到此阈值后要考虑变为链表</span></span><br><span class="line"><span class="comment">// 当单个的链表的结点个数达到 8，并且 table 的长度达到 64，才会树化。</span></span><br><span class="line"><span class="comment">// 当单个的链表的结点个数达到 8，但是 table 的长度未达到 64，会先扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;    <span class="comment">// 最小树化容量 64</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;    <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;   <span class="comment">// 记录有效映射关系的对数，也是 Entry 对象的个数</span></span><br><span class="line"><span class="type">int</span> threshold;    <span class="comment">// 阈值，当 size 达到阈值时，考虑扩容</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 加载因子，影响扩容的频率</span></span><br></pre></td></tr></table></figure></li><li><p>构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;    <span class="comment">// all other fields defaulted (其他字段都是默认值)</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>put()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 如果 key 是 null，hash 是 0</span></span><br><span class="line">    <span class="comment">// 如果 key 非 null，用 key 的 hashCode 值 与 key 的 hashCode 值高 16 进行异或</span></span><br><span class="line">    <span class="comment">// 即就是用 key 的 hashCode 值高 16 位与低 16 位进行了异或的干扰运算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">    如果用 key 的原始的 hashCode 值 与 table.length-1 进行按位与，那么基本上高 16 没机会用上。</span></span><br><span class="line"><span class="comment">    这样就会增加冲突的概率，为了降低冲突的概率，把高 16 位加入到 hash 信息中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">{</span><br><span class="line">    Node&lt;K,V&gt;[] tab;    <span class="comment">// 数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;    <span class="comment">// 一个结点</span></span><br><span class="line">    <span class="type">int</span> n, i;    <span class="comment">// n 是数组的长度 i 是下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab 和 table 等价</span></span><br><span class="line">    <span class="comment">// 如果 table 是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        tab = resize();</span></span><br><span class="line"><span class="comment">        n = tab.length;*/</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果 table 是空的，resize()完成了</span></span><br><span class="line"><span class="comment">        ①创建了一个长度为 16 的数组</span></span><br><span class="line"><span class="comment">        ②threshold = 12</span></span><br><span class="line"><span class="comment">        n = 16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">    <span class="comment">// p = tab[i] 第 1 个结点</span></span><br><span class="line">    <span class="comment">// if(p == null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 把新的映射关系直接放入 table[i]</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// newNode（）方法就创建了一个 Node 类型的新结点，新结点的 next 是 null</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 是 table[i]中第一个结点</span></span><br><span class="line">        <span class="comment">// if(table[i]的第一个结点与新的映射关系的 key 重复)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  <span class="comment">// 用 e 记录这个 table[i]的第一个结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//如果 table[i]第一个结点是一个树结点</span></span><br><span class="line">            <span class="comment">//单独处理树结点</span></span><br><span class="line">            <span class="comment">//如果树结点中，有 key 重复的，就返回那个重复的结点用 e 接收，即 e!=null</span></span><br><span class="line">            <span class="comment">//如果树结点中，没有 key 重复的，就把新结点放到树中，并且返回 null，即 e=null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// table[i]的第一个结点不是树结点，也与新的映射关系的 key 不重复</span></span><br><span class="line">            <span class="comment">// binCount 记录了 table[i]下面的结点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 如果 p 的下一个结点是空的，说明当前的 p 是最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 把新的结点连接到 table[i]的最后</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 binCount&gt;=8-1，达到 7 个时</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)    <span class="comment">// -1 for 1s</span></span><br><span class="line">                        <span class="comment">// 要么扩容，要么树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 key 重复了，就跳出 for 循环，此时 e 结点记录的就是那个 key 重复的结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                p = e;    <span class="comment">// 下一次循环，e=p.next，就类似于 e=e.next，往链表下移动</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个 e 不是 null，说明有 key 重复，就考虑替换原来的 value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">            afterNodeAccess(e);    <span class="comment">// 什么也没干</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 元素个数增加</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// size 达到阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();    <span class="comment">// 一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);    <span class="comment">// 什么也没干</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()</span><br><span class="line">{</span><br><span class="line"><span class="comment">// oldTab 原来的 table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldCap：原来数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldThr：原来的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//最开始 threshold 是 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newCap，新容量</span></span><br><span class="line">    <span class="comment">// newThr：新阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>)    <span class="comment">// 说明原来不是空数组</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY)    <span class="comment">// 是否达到数组最大限制</span></span><br><span class="line">        {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">            <span class="comment">// 新容量：32,64，...</span></span><br><span class="line">            <span class="comment">// oldCap &gt;= 初始容量 16</span></span><br><span class="line">            <span class="comment">// 新阈值重新算 = 24，48 ....</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;    <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)    <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    {</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;    <span class="comment">// 新容量是默认初始化容量 16</span></span><br><span class="line">        <span class="comment">// 新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    threshold = newThr;    <span class="comment">// 阈值赋值为新阈值 12，24.。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个新数组，长度为 newCap，16，32,64.。。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>)    <span class="comment">// 原来不是空数组</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 把原来的 table 中映射关系，倒腾到新的 table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j)</span><br><span class="line">        {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>)    <span class="comment">// e 是 table 下面的结点</span></span><br><span class="line">            {</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;    <span class="comment">// 把旧的 table[j]位置清空</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)    <span class="comment">// 如果是最后一个结点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;    <span class="comment">// 重新计算 e 的在新 table 中的存储位置，然后放入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)    <span class="comment">// 如果 e 是树结点</span></span><br><span class="line">                    <span class="comment">// 把原来的树拆解，放到新的 table</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">// preserve order</span></span><br><span class="line">                {</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 把原来 table[i]下面的整个链表，重新挪到了新的 table 中</span></span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    {</span><br><span class="line">                        next = e.next;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line"></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line"></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="literal">null</span>)</span><br><span class="line">                    {</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>)</span><br><span class="line">                    {</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 创建一个新结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> n, index;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MIN_TREEIFY_CAPACITY：最小树化容量 64</span></span><br><span class="line">    <span class="comment">// 如果 table 是空的，或者 table 的长度没有达到 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();    <span class="comment">// 先扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 用 e 记录 table[index]的结点的地址</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        do...while，把 table[index]链表的 Node 结点变为 TreeNode 类型的结点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;    <span class="comment">// hd 记录根结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            tl = p;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 table[index]下面不是空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);   <span class="comment">// 将 table[index]下面的链表进行树化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>HashMap 的 put()执行过程：</p><p><img src="https://img-blog.csdnimg.cn/7d6d131a67464e39ab2bb97f34138491.png" alt="HashMap的put()执行过程"></p></li></ul></li></ul><h3 id="14-8-4-LinkedHashMap-源码剖析">14.8.4 LinkedHashMap 源码剖析</h3><ul><li><p>JDK1.7 中的源代码：</p><p><img src="https://img-blog.csdnimg.cn/21e5ec87847d4f72b8fdaaf82d9a0714.png" alt="JDK1.7 中的 LinkedHashMap 结构"></p><ul><li><p>内部定义的 Entry 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt;</span><br><span class="line">{</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>LinkedHashMap 重写了 HashMap 中的 newNode()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span></span><br><span class="line">{</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span></span><br><span class="line">{</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="14-9-Set-接口下的实现类的源码剖析">14.9 Set 接口下的实现类的源码剖析</h2><h3 id="14-9-1-Set-集合与-Map-集合的关系">14.9.1 Set 集合与 Map 集合的关系</h3><p>Set 的内部实现其实是一个 Map，Set 中的元素，存储在 HashMap 的 key 中。即 HashSet 的内部实现是一个 HashMap，TreeSet 的内部实现是一个 TreeMap，LinkedHashSet 的内部实现是一个 LinkedHashMap。</p><h3 id="14-9-2-HashSet-源码剖析">14.9.2 HashSet 源码剖析</h3><ul><li><p>HashSet 源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line">{</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line">{</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个构造器是给子类 LinkedHashSet 调用的</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy)</span><br><span class="line">{</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator()方法：</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-9-3-LinkedHashSet-源码剖析">14.9.3 LinkedHashSet 源码剖析</h3><ul><li>LinkedHashSet 源代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);    <span class="comment">// 调用 HashSet 的某个构造器</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);    <span class="comment">// 调用 HashSet 的某个构造器</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-9-4-TreeSet-源码剖析">14.9.4 TreeSet 源码剖析</h3><ul><li><p>TreeSet 源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">}</span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-10-HashMap-的相关问题">14.10 HashMap 的相关问题</h2><h3 id="14-10-1-哈希算法的理解？">14.10.1 哈希算法的理解？</h3><p>hash 算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为 hash code、数据摘要或者指纹。比较出名的 hash 算法有 MD5、SHA。hash 是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的 hash code 永远是一样的。</p><h3 id="14-10-2-Entry-中的-hash-属性为什么不直接使用-key-的-hashCode-返回值？">14.10.2 Entry 中的 hash 属性为什么不直接使用 key 的 hashCode() 返回值？</h3><ul><li><p>不管是 JDK1.7 还是 JDK1.8 中，都不是直接用 key 的 hashCode 值直接与 table.length-1 计算求下标的，而是先对 key 的 hashCode 值进行了一个运算，JDK1.7 和 JDK1.8 关于 hash()的实现代码不一样，但是不管怎么样都是为了提高 hash code 值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p><p><img src="https://img-blog.csdnimg.cn/c1a6126a31794ea89518df80d560ebeb.png" alt="哈希过程"></p></li><li><p>JDK1.7 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>虽然算法不同，但是思路都是将 hashCode 值的高位二进制与低位二进制值进行了异或，然高位二进制参与到 index 的计算中。</p><ul><li>为什么要 hashCode 值的二进制的高位参与到 index 计算呢？<ul><li>因为一个 HashMap 的 table 数组一般不会特别大，至少在不断扩容之前，那么 table.length-1 的大部分高位都是 0，直接用 hashCode 和 table.length-1 进行&amp; 运算的话，就会导致总是只有最低的几位是有效的，那么就算你的 hashCode() 实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对 hashcode 的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</li></ul></li></ul></li></ul><h3 id="14-10-3-HashMap-是如何决定某个-key-value-存在哪个桶的？">14.10.3 HashMap 是如何决定某个 key-value 存在哪个桶的？</h3><ul><li><p>因为 hash 值是一个整数，而数组的长度也是一个整数，有两种思路：<br>① hash 值 % table.length 会得到一个 [0,table.length - 1] 范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。<br>②hash 值 &amp; (table.length - 1)，任何数 &amp; (table.length - 1)的结果也一定在[0, table.length - 1]范围。</p></li><li><p>JDK1.7 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-z</span></span><br><span class="line">    ero power of <span class="number">2</span><span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return h &amp; (length-1);    // 此处 h 就是 hash</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 中的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)    <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-10-4-为什么要保持-table-数组一直是-2-的-n-次幂？">14.10.4 为什么要保持 table 数组一直是 2 的 n 次幂？</h3><p>因为如果数组的长度为 2 的 n 次幂，那么 table.length-1 的二进制就是一个高位全是 0，低位全是 1 的数字，这样才能保证每一个下标位置都有机会被用到。</p><h3 id="14-10-5-解决-index-冲突问题？">14.10.5 解决[index]冲突问题？</h3><ul><li><p>虽然从设计 hashCode()到上面 HashMap 的 hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的 hashCode 值相同，或者 hashCode 值就算不同，通过 hash()函数计算后，得到的 index 也会存在大量的相同，因此 key 分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p></li><li><p>JDK1.8 之间使用：数组+链表的结构。</p><p><img src="https://img-blog.csdnimg.cn/804f6f3562ec4c018bb6bdee9e975485.png" alt="JDK1.8 之间使用：数组+链表的结构"></p></li><li><p>JDK1.8 之后使用：数组+链表/红黑树的结构。</p><p><img src="https://img-blog.csdnimg.cn/06ca155a7fb04f00a91d3550706bc9fb.png" alt="JDK1.8 之后使用：数组+链表/红黑树的结构"></p></li><li><p>即 hash 相同或 hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p></li></ul><h3 id="14-10-6-为什么-JDK1-8-会出现红黑树和链表共存？">14.10.6 为什么 JDK1.8 会出现红黑树和链表共存？</h3><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。</p><h3 id="14-10-7-加载因子的值大小有什么关系？">14.10.7 加载因子的值大小有什么关系？</h3><ul><li>如果太大，threshold 就会很大，那么如果冲突比较严重的话，就会导致 table[index]下面的结点个数很多，影响效率。</li><li>如果太小，threshold 就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</li></ul><h3 id="14-10-8-什么时候树化？什么时候反树化？">14.10.8 什么时候树化？什么时候反树化？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;    <span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;    <span class="comment">// 反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;    <span class="comment">// 最小树化容量</span></span><br></pre></td></tr></table></figure><ul><li>当某 table[index]下的链表的结点个数达到 8，并且 table.length&gt;=64，那么如果新 Entry 对象还添加到该 table[index]中，那么就会将 table[index]的链表进行树化。</li><li>当某 table[index]下的红黑树结点个数少于 6 个，此时，<ul><li>当继续删除 table[index]下的树结点，最后这个根结点的左右结点有 null，或根结点的左结点的左结点为 null，会反树化。</li><li>当重新添加新的映射关系到 map 中，导致了 map 重新扩容了，这个时候如果 table[index]下面还是小于等于 6 的个数，那么会反树化。</li></ul></li></ul><h3 id="14-10-9-key-value-中的-key-是否可以修改？">14.10.9 key-value 中的 key 是否可以修改？</h3><ul><li>key-value 存储到 HashMap 中会存储 key 的 hash 值，这样就不用在每次查找时重新计算每一个 Entry 或 Node（TreeNode）的 hash 值了，因此如果已经 put 到 Map 中的 key-value，再修改 key 的属性，而这个属性又参与 hashcode 值的计算，那么会导致匹配不上。</li><li>这个规则也同样适用于 LinkedHashMap、HashSet、LinkedHashSet、Hashtable 等所有散列存储结构的集合。</li></ul><h3 id="14-10-10-JDK1-7-中-HashMap-的循环链表是怎么回事？如何解决？">14.10.10 JDK1.7 中 HashMap 的循环链表是怎么回事？如何解决？</h3><p><img src="https://img-blog.csdnimg.cn/9bc205a1348645a7b0f76312fd699837.png" alt="JDK1.7 中 HashMap 的循环链表问题"></p><ul><li><p>避免 HashMap 发生死循环的常用解决方案：</p><ul><li>多线程环境下，使用线程安全的 ConcurrentHashMap 替代 HashMap，推荐。</li><li>多线程环境下，使用 synchronized 或 Lock 加锁，但会影响性能，不推荐。</li><li>多线程环境下，使用线程安全的 Hashtable 替代，性能低，不推荐。</li></ul></li><li><p>HashMap 死循环只会发生在 JDK1.7 版本中，主要原因：头插法+链表+多线程并发+扩容。</p></li><li><p>在 JDK1.8 中，HashMap 改用尾插法，解决了链表死循环的问题。</p></li></ul><h2 id="14-11-企业真题">14.11 企业真题</h2><ol><li><p>链表和数组有什么区别？<br>答：<br>链表和数组是两种不同的数据结构，它们的区别如下：<br>① 存储方式：数组是一块连续的内存空间，而链表是通过指针将一系列节点连接起来的。<br>② 插入和删除操作：在数组中，如果要插入或删除一个元素，需要将其它元素向前或向后移动以保持连续性；而在链表中，只需要修改指针即可。<br>③ 访问元素的效率：在数组中，可以通过下标直接访问元素，因此访问的效率比较高；而在链表中，需要从头结点开始遍历才能访问到某个节点，因此访问的效率比较低。<br>④ 内存的分配和释放：数组在创建时需要一次性分配连续的内存空间，而链表则可以动态地分配内存空间，只需要在需要时申请新的节点即可。</p><p>总的来说，链表适合处理需要频繁插入、删除操作的情况，而数组适合处理需要快速访问元素的情况。</p></li><li><p>栈是如何运行的？<br>答：<br>栈是一种后进先出（LIFO）的数据结构，它的运行方式是通过将数据压入栈顶或从栈顶弹出数据来实现。当数据被压入栈顶时，它会被放置在栈顶位置，并成为当前栈顶元素；当数据从栈顶弹出时，它会被移除，并将栈顶指针指向下一个元素。栈的基本操作包括压入（push）、弹出（pop）、获取栈顶元素（top）、判断栈是否为空（isEmpty）等。在程序中，栈通常用来存储临时数据、函数调用参数和返回地址等信息。由于栈的大小是有限制的，当栈满时，会抛出栈溢出（StackOverflow）异常。</p></li><li><p>ArrayList 的默认大小是多少，以及扩容机制？<br>答：<br>Java 中，ArrayList 的默认大小是 10，即在创建 ArrayList 对象时，它的内部数组默认的初始大小为 10。如果在添加元素时，发现内部数组已满，则会触发扩容机制，将内部数组的大小翻倍，即扩容为原来的两倍。如果此时需要添加的元素个数超过了新的数组大小，则会再次触发扩容，以此类推。因此，ArrayList 的扩容机制是动态的，可以根据实际需要进行自适应扩容。</p></li><li><p>ArrayList 的底层是怎么实现的?<br>答：<br>Java 中的 ArrayList 底层是通过数组实现的。它是一个动态数组，可以自动扩容。当数组的容量不足时，会自动创建一个新的数组，将原数组中的元素复制到新数组中，然后再将新元素添加到新数组中。</p><p>ArrayList 的实现主要包含以下几个关键点：<br>① 数组：ArrayList 底层是一个 Object 类型的数组，用于存储元素。<br>② size：ArrayList 中元素的个数。<br>③ capacity：ArrayList 数组的容量，即数组的长度。<br>④ add()方法：添加元素时，首先判断数组是否已满，如果已满，则创建一个新数组，并将原数组中的元素复制到新数组中，然后再将新元素添加到新数组中。<br>⑤ remove()方法：删除元素时，将要删除的元素后面的所有元素向前移动一位，然后将最后一个元素设为 null。<br>⑥ indexOf()方法：查找元素时，遍历数组，如果找到了目标元素，则返回其下标，否则返回-1。<br>⑦ get()和 set()方法：获取和设置元素时，通过下标直接访问数组中的元素。</p><p>总之，ArrayList 底层是一个数组，通过动态扩容和数组操作实现了添加、删除、查找和获取元素等功能。</p></li><li><p>在 ArrayList 中 remove 后面几个元素该怎么做?<br>答：<br>在 ArrayList 中删除元素时，删除后面的元素可以直接使用 ArrayList 类中提供的 remove 方法，该方法会自动将被删除元素后面的元素向前移动一个位置，填补删除元素的空缺。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);    <span class="comment">// 删除索引为2的元素，即3</span></span><br><span class="line">System.out.println(list);    <span class="comment">// 输出[1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，删除索引为 2 的元素后，元素 4 和 5 会向前移动一个位置，填补删除元素的空缺。</p></li><li><p>ArrayList 在 JDK1.7 和 JDK1.8 的区别？<br>答：<br>在 JDK1.7 中，ArrayList 是基于数组实现的，它在初始化时就会创建一个默认大小的数组，并在添加元素时动态扩容。这种实现方式被称为“饿汉式”，因为在创建对象时就已经预先分配了内存空间。</p><p>而在 JDK1.8 中，ArrayList 的实现方式发生了改变。它不再在初始化时创建数组，而是在第一次添加元素时才会创建一个默认大小的数组。这种实现方式被称为“懒汉式”，因为它在需要的时候才会分配内存空间。</p><p>这种改变带来了一些好处，例如减少了内存占用和初始化时间，但也带来了一些潜在的问题，例如在高并发环境下可能会出现线程安全问题。因此，在多线程环境下，最好使用线程安全的 ArrayList 实现类，例如 Vector 或 CopyOnWriteArrayList。</p></li><li><p>数组和 ArrayList 的区别？<br>答：<br>数组和 ArrayList 都可以用来存储一组数据，但是它们有以下区别：<br>① 数组长度固定，而 ArrayList 可以动态增长或缩小。<br>② 数组可以存储基本数据类型和对象，而 ArrayList 只能存储对象。<br>③ 数组可以直接访问任意元素，而 ArrayList 需要通过索引访问元素。<br>④ 数组的效率比 ArrayList 高，因为它不需要额外的空间来存储元素的索引。<br>⑤ ArrayList 提供了一些方便的方法来操作元素，如 add、remove、get、set 等，而数组需要手动实现这些方法。</p><p>总的来说，ArrayList 是对数组的常见操作的封装，提供了更加方便和灵活的操作方式。但是在性能方面，数组仍然具有优势。</p></li><li><p>什么是线程安全的 List？<br>答：<br>在 Java 中，线程安全的 List 是指多个线程可以安全地同时访问该 List，而不会导致数据不一致或其他错误。其中，Vector 是线程安全的 List，因为它的方法都是同步的，多个线程同时访问不会导致数据不一致。而 ArrayList 是线程不安全的 List，如果多个线程同时访问，可能会导致数据不一致或其他错误。为了解决 ArrayList 的线程安全问题，可以使用同步机制进行处理，比如使用 Collections.synchronizedList 方法将其转换为线程安全的 List。另外，Java 还提供了一些更高效的线程安全的集合类，比如 JUC 包中的 ConcurrentHashMap。</p></li><li><p>说说 HahMap 底层实现？<br>答：<br>HashMap 底层实现主要是基于哈希表（Hash Table）和链表（LinkedList）的组合实现。</p><p>具体来说，HashMap 中的元素存储在一个数组中，每个数组元素称为桶（Bucket），每个桶存储的是一个链表的头节点。当需要添加一个元素时，首先根据该元素的 hashCode()方法计算出该元素在数组中的位置，如果该位置已经有元素存在，则需要遍历该位置上的链表，找到最后一个节点，将新元素添加到该链表的尾部；如果该位置上没有元素存在，则直接将新元素添加到该位置上。</p><p>当需要查找一个元素时，首先根据该元素的 hashCode()方法计算出该元素在数组中的位置，然后遍历该位置上的链表，查找是否存在该元素。如果存在，则返回该元素；如果不存在，则返回 null。</p><p>当需要删除一个元素时，首先根据该元素的 hashCode()方法计算出该元素在数组中的位置，然后遍历该位置上的链表，查找是否存在该元素。如果存在，则将该元素从链表中删除；如果不存在，则不做任何操作。</p><p>需要注意的是，当链表中的元素数量过多时，会影响 HashMap 的性能，因为需要遍历更长的链表才能找到目标元素。因此，当链表中的元素数量超过一定阈值时，会将该链表转化为红黑树（Tree），以提高查找效率。</p></li><li><p>HashMap 初始值 16，临界值 12 是怎么算的？<br>答：<br>HashMap 的初始容量为 16，这是因为 HashMap 的底层实现是基于数组的，而 16 是一个比较合适的数值，可以保证在大多数情况下，存储的元素可以均匀的分布在数组中，从而达到较好的性能。</p><p>临界值 12 是根据 HashMap 的负载因子（loadFactor）计算得出的。负载因子是 HashMap 中的一个参数，表示当数组中元素的数量达到总容量的百分之多少时，就需要将数组扩容。HashMap 的默认负载因子为 0.75，也就是说当元素数量达到总容量的 75%时，就需要将数组扩容。</p><p>因此，当 HashMap 的容量为 16 时，它的临界值为 16 * 0.75 = 12。当元素数量达到 12 时，就需要将数组扩容，以保证 HashMap 的性能。</p></li><li><p>HashMap 长度为什么是 2 的幂次方？<br>答：<br>HashMap 的长度为 2 的幂次方是为了方便计算元素的索引值，即将元素的哈希值与 HashMap 的长度进行取模运算，得到的结果就是元素在 HashMap 中的索引位置。如果 HashMap 的长度不是 2 的幂次方，那么在进行取模运算时就需要进行复杂的除法运算，降低了效率。而如果 HashMap 的长度是 2 的幂次方，那么取模运算可以转化为位运算，即对 HashMap 的长度进行按位与操作，这样可以大大提高计算效率。</p></li><li><p>HashMap 怎么计算哈希值和索引？扩容机制？怎么解决 hash 冲突？<br>答：<br>① HashMap 计算哈希值和索引：<br>HashMap 的哈希值是通过 key 的 hashCode()方法计算得出的，然后通过哈希函数计算出在数组中的索引位置。哈希函数的计算方法是将哈希值与数组长度进行取模运算，得到的余数就是 key 在数组中的索引位置。</p><p>② HashMap 扩容机制：<br>当 HashMap 中元素的数量超过了负载因子乘以数组长度时，就会发生扩容操作。扩容操作会重新计算每个元素的哈希值和索引位置，并将元素重新放到新的数组中。</p><p>扩容时，数组的长度会翻倍，同时原有的元素也会被重新分配到新的索引位置上。这个过程需要重新计算哈希值和索引位置，因此会比较耗时。</p><p>③ HashMap 解决 hash 冲突的方法：<br>当不同的 key 计算出的哈希值相同时，就会发生哈希冲突。HashMap 使用链表法解决哈希冲突，即在发生哈希冲突时，将新元素插入到链表的末尾。</p><p>如果链表的长度超过了阈值（默认为 8），就会将链表转换为红黑树，以提高查询效率。当红黑树的节点数小于等于 6 时，会将红黑树转换回链表。</p></li><li><p>HashMap 底层是数组 + 链表，有数组很快了，为什么加链表？<br>答：<br>HashMap 加链表是为了解决哈希冲突问题。当不同的键值对经过哈希函数计算后，得到的哈希值相同，即发生了哈希冲突。如果直接将键值对存储在同一个数组位置上，会导致数据覆盖，因此需要在同一个数组位置上使用链表来存储多个键值对。当发生哈希冲突时，HashMap 会将新的键值对添加到链表的末尾，而不是覆盖原有的键值对。这样，当需要访问某个键值对时，HashMap 只需要遍历链表即可，不需要遍历整个数组，提高了访问效率。</p></li><li><p>HashMap 为什么长度达到一定的长度要转化为红黑树？<br>答：<br>在 Java 中，HashMap 是一种基于哈希表实现的数据结构。当 HashMap 中的元素数量达到一定的数量时，哈希表的性能会受到影响，因为哈希表的冲突会变得更加频繁，查找、插入、删除等操作的时间复杂度也会变高。</p><p>为了解决这个问题，Java 中的 HashMap 引入了红黑树，当哈希表中的某个桶中的元素数量达到了一个阈值（默认为 8），且该桶中元素的数量大于等于 64 时，就会将该桶中的元素转化为红黑树。</p><p>红黑树的插入、查找、删除等操作的时间复杂度都是 O(logn)，比单向链表的 O(n)效率高得多，因此使用红黑树可以提高 HashMap 的性能。</p><p>值得注意的是，当哈希表中的元素数量减少时，红黑树会被转化为普通的链表，这是因为链表在元素数量较少时的性能更优。</p></li><li><p>HashMap 什么时候扩充为红黑树，什么时候又返回到链表？<br>答：<br>在 Java 8 中，当 HashMap 的某个桶中元素数量超过 TREEIFY_THRESHOLD（默认为 8）时，该桶中的元素将被转换为红黑树，以提高查找效率。当桶中元素数量小于 UNTREEIFY_THRESHOLD（默认为 6）时，红黑树将被转换回链表，以减少空间占用。</p></li><li><p>在 JDK1.8 中，HashMap 的数据结构与 1.7 相比有什么变化，这些变化的好处在哪里？<br>答：<br>在 JDK1.8 中，HashMap 的数据结构发生了一些变化，具体如下：<br>① 初始化方式：在 JDK1.8 中，当我们创建 HashMap 实例时，底层并没有初始化 table 数组。当首次添加(key,value)时，进行判断，如果发现 table 尚未初始化，则对数组进行初始化。<br>② 内部类：在 JDK1.8 中，HashMap 底层定义了 Node 内部类，替换了 JDK1.7 中的 Entry 内部类。这意味着我们创建的数组是 Node[]。<br>③ 插入方式：在 JDK1.8 中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标 i 中。如果此时角标 i 位置上有元素，旧的元素会指向新的(key,value)元素（尾插法），而在 JDK1.7 中是将新的(key,value)指向已有的旧的元素（头插法）。<br>④ 数据结构：在 JDK1.7 中，HashMap 使用的是数组+单向链表的数据结构。而在 JDK1.8 中，除了数组和单向链表，还使用了红黑树。当数组索引 i 位置上的元素的个数达到 8，并且数组的长度达到 64 时，会将此索引 i 位置上的多个元素改为使用红黑树的结构进行存储。使用红黑树的时间复杂度为 O(logn)，比单向链表的时间复杂度 O(n)更优，因此可以提高 HashMap 的性能。当使用红黑树的索引 i 位置上的元素的个数低于 6 时，就会将红黑树结构退化为单向链表。</p><p>这些变化让 HashMap 在 JDK1.8 中更加高效、可靠，提高了其性能和扩展性。</p></li><li><p>HashMap 的 get()方法的原理?<br>答：<br>Java 中，HashMap 的 get()方法的原理如下：<br>① 首先，HashMap 会根据传入的 key 计算出其对应的 hash 值。<br>② 然后，HashMap 会根据 hash 值找到对应的桶（bucket）。<br>③ 在桶中，HashMap 会遍历所有的键值对，找到与传入的 key 相等的键值对。<br>④ 如果找到了对应的键值对，HashMap 就会返回该键值对的 value 值。<br>⑤ 如果找不到对应的键值对，HashMap 就会返回 null。</p><p>需要注意的是，当 HashMap 中的键值对数量很大时，遍历桶中的键值对可能会比较耗时，因此在实际使用中，应尽量保证 HashMap 中的键值对数量不要过大，以提高 get()方法的性能。</p></li><li><p>hashcode()和 equals()的区别？<br>答：<br>hashcode()和 equals()都是 Object 类中定义的方法，用于判断对象是否相等。但是它们的作用不同：<br>① hashcode()方法用于获取对象的哈希码，返回一个 int 类型的值。哈希码是根据对象的内部信息计算出来的一个数值，可以用于快速查找和比较对象。如果两个对象的 hashcode()值相等，不一定表示它们相等，但如果两个对象不相等，它们的 hashcode()值一定不相等。<br>② equals()方法用于比较两个对象是否相等，返回一个 boolean 类型的值。默认情况下，equals()方法比较的是对象的引用地址，即两个对象的引用地址相同才认为它们相等。但是我们可以重写 equals()方法，根据对象的内部信息来判断两个对象是否相等。如果两个对象相等，它们的 hashcode()值一定相等；如果两个对象的 hashcode()值相等，它们不一定相等，需要再调用 equals()方法进行比较。</p><p>因此，hashcode()和 equals()方法是互相关联的，如果重写 equals()方法，也需要重写 hashcode()方法，保证两个方法的一致性。</p></li><li><p>hashCode() 与 equals() 生成算法、方法怎么重写？<br>答：<br>在 Java 中，hashCode()和 equals()方法都是用来比较对象的，其中 hashCode()方法用来获取对象的哈希码，equals()方法用来比较两个对象是否相等。</p><p>重写 hashCode()方法需要注意以下几点：<br>① hashCode()方法的返回值应该是一个整数，通常使用对象的属性进行计算，保证相同的对象返回相同的 hashCode()值。<br>② hashCode()方法的计算不能依赖于对象的内存地址，因为在不同的 JVM 中，同一对象的内存地址可能不同。<br>③ hashCode()方法的计算应该尽量简单，避免过于复杂的计算，影响性能。</p><p>重写 equals()方法需要注意以下几点：<br>① equals()方法应该比较对象的属性，而不是比较对象的内存地址。<br>② equals()方法应该满足自反性、对称性、传递性和一致性。<br>③ equals()方法应该检查参数是否为 null，并且检查参数类型是否相同。</p><p>以下是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数、getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        result = prime * result + age;</span><br><span class="line">        result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != other.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个示例中，hashCode()方法使用了对象的 name 和 age 属性进行计算，保证相同的对象返回相同的 hashCode()值。equals()方法比较了对象的 name 和 age 属性，满足了自反性、对称性、传递性和一致性。</p></li><li><p>说一下 equals 和 == 的区别，然后问 equals 相等 hash 值一定相等吗？hash 值相等 equals 一定相等吗？<br>答：<br>equals 方法是用来比较两个对象的内容是否相等，而 == 操作符是用来比较两个对象的引用是否相等。</p><p>在 Java 中，equals 相等的两个对象的 hash 值不一定相等，因为 hash 值是根据对象的内容计算得出的，而不是根据对象的引用。而 hash 值相等的两个对象的 equals 不一定相等，因为不同的对象可能具有相同的 hash 值，这种情况称为哈希冲突。</p><p>因此，在使用哈希表等数据结构时，需要同时实现 equals 和 hashCode 方法，并保证它们的一致性，即如果两个对象的 equals 相等，则它们的 hashCode 也相等。这样可以确保在哈希表中查找对象时能够正确地匹配对象。</p></li><li><p>HashSet 存放数据的方式？<br>答：<br>Java 中的 HashSet 使用哈希表（Hash Table）来存储数据。具体地说，HashSet 内部是一个 HashMap 对象，其中的键（key）就是存放的数据，值（value）则是一个固定的 Object 对象。当向 HashSet 中添加元素时，实际上是向 HashMap 中添加键值对，键为存放的数据，值为一个固定的 Object 对象。在查询元素时，HashSet 会根据哈希值（Hash Code）来快速定位元素，从而实现高效的查找。</p></li><li><p>Set 是如何实现元素的唯一性？<br>答：<br>Java 中的 Set 是通过 hashCode()和 equals()方法来实现元素的唯一性的。</p><p>当向 Set 中添加一个元素时，首先会调用该元素的 hashCode()方法，获取该元素的哈希值。Set 会将该元素的哈希值与其他元素的哈希值进行比较，如果存在相同的哈希值，则继续调用 equals()方法进行比较。如果 equals()方法返回 true，则说明该元素已经存在于 Set 中，不会被添加；否则将该元素添加到 Set 中。</p><p>因此，为了保证元素的唯一性，需要重写该元素的 hashCode()和 equals()方法，使它们能够正确地计算元素的哈希值和比较元素的相等性。</p></li><li><p>用哪两种方式来实现集合的排序？<br>答：<br>Java 中可以使用以下两种方式来实现集合的排序：<br>① 实现 Comparable 接口</p><p>在集合元素类中实现 Comparable 接口，并重写 compareTo 方法，实现元素的比较规则。然后使用 Collections.sort 方法进行排序。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, o.age);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">{</span><br><span class="line">    List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Tom"</span>, <span class="number">20</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Jerry"</span>, <span class="number">18</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Alice"</span>, <span class="number">22</span>));</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Person{name='Jerry', age=18}, Person{name='Tom', age=20}, Person{name='Alice', age=22}]</span><br></pre></td></tr></table></figure><p>② 实现 Comparator 接口</p><p>创建一个实现 Comparator 接口的比较器类，并重写 compare 方法，实现元素的比较规则。然后使用 Collections.sort 方法并传入比较器对象进行排序。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Person&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.getAge(), o2.getAge());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">{</span><br><span class="line">    List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Tom"</span>, <span class="number">20</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Jerry"</span>, <span class="number">18</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Alice"</span>, <span class="number">22</span>));</span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> <span class="title class_">PersonComparator</span>());</span><br><span class="line">    System.out.println(list);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Person{name='Jerry', age=18}, Person{name='Tom', age=20}, Person{name='Alice', age=22}]</span><br></pre></td></tr></table></figure><p>以上两种方式都可以实现集合的排序，但实现 Comparable 接口的方式更加方便，因为不需要创建额外的比较器类。但是，如果需要实现多种比较规则，或者对已有的类进行排序，就需要使用实现 Comparator 接口的方式。</p></li></ol><h1>第 15 章 File 类与 IO 流</h1><h2 id="15-1-File-类">15.1 File 类</h2><h3 id="15-1-1-File-类的概述">15.1.1 File 类的概述</h3><p>File 类及本章下的各种流，都定义在 <a href="http://java.io">java.io</a> 包下。</p><p>一个 File 对象代表硬盘或网络中可能存在的一个文件或者文件目录，与平台无关。</p><p>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入、输出流。</p><ul><li>File 对象可以作为参数传递给流的构造器。</li></ul><p>想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java 程序中的一个 File 对象，可能没有一个真实存在的文件或目录。</p><h3 id="15-1-2-File-类的构造器">15.1.2 File 类的构造器</h3><ul><li><p>public File(String pathname) ：以 pathname 为路径创建 File 对象，可以是绝对路径或者相对路径，如果 pathname 是相对路径，则默认的当前路径在系统属性 user.dir 中存储。</p></li><li><p>public File(String parent, String child) ：以 parent 为父路径，child 为子路径创建 File 对象。</p></li><li><p>public File(File parent, String child) ：根据一个父 File 对象和子文件路径创建 File 对象。</p></li><li><p>关于路径：</p><ul><li>绝对路径：从盘符开始的路径，这是一个完整的路径。</li><li>相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。<ul><li>IDEA 中，main 中的文件的相对路径，是相对于"当前工程"。</li><li>IDEA 中，单元测试方法中的文件的相对路径，是相对于"当前 module"。</li></ul></li></ul></li></ul><h3 id="15-1-3-File-类的常用方法">15.1.3 File 类的常用方法</h3><p>获取文件和目录基本信息：</p><ul><li>public String getName() ：获取名称。</li><li>public String getPath() ：获取路径。</li><li>public String getAbsolutePath()：获取绝对路径。</li><li>public File getAbsoluteFile()：获取绝对路径表示的文件。</li><li>public String getParent()：获取上层文件目录路径。若无，返回 null。</li><li>public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</li><li>public long lastModified() ：获取最后一次的修改时间，毫秒值。</li></ul><p>列出目录的下一级：</p><ul><li>public String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li><li>public File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目<br>录。</li></ul><p>File 类的重命名功能：</p><ul><li>public boolean renameTo(File dest):把文件重命名为指定的文件路径。</li></ul><p>判断功能的方法：</p><ul><li>public boolean exists() ：此 File 表示的文件或目录是否实际存在。</li><li>public boolean isDirectory() ：此 File 表示的是否为目录。</li><li>public boolean isFile() ：此 File 表示的是否为文件。</li><li>public boolean canRead() ：判断是否可读。</li><li>public boolean canWrite() ：判断是否可写。</li><li>public boolean isHidden() ：判断是否隐藏。</li></ul><p>创建、删除功能：</p><ul><li>public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回 false。</li><li>public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li><li>public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建。</li><li>public boolean delete() ：删除文件或者文件夹 删除注意事项：<br>① Java 中的删除不走回收站。<br>② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</li></ul><h2 id="15-2-IO-流">15.2 IO 流</h2><h3 id="15-2-1-IO-流的概述">15.2.1 IO 流的概述</h3><p>Java 程序中，对于数据的输入、输出操作以“流(stream)” 的方式进行，可以看做是一种数据的流动。</p><p><img src="https://img-blog.csdnimg.cn/1649139370594810b1a49f4e8a834ab5.png" alt="IO流"></p><p>I/O 流中的 I/O 是 Input/Output 的缩写， I/O 技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</p><ul><li>输入 input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li><li>输出 output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li></ul><h3 id="15-2-2-IO-流的分类">15.2.2 IO 流的分类</h3><ul><li>按数据的流向不同分为：输入流和输出流。<ul><li>输入流 ：把数据从其他设备上读取到内存中的流。以 InputStream、Reader 结尾。</li><li>输出流 ：把数据从内存 中写出到其他设备上的流。以 OutputStream、Writer 结尾。</li></ul></li><li>按操作数据单位的不同分为：字节流（8bit）和字符流（16bit）。<ul><li>字节流 ：以字节为单位，读写数据的流。以 InputStream、OutputStream 结尾。</li><li>字符流 ：以字符为单位，读写数据的流。以 Reader、Writer 结尾。</li></ul></li><li>根据 IO 流的角色不同分为：节点流和处理流。<ul><li>节点流：直接从数据源或目的地读写数据。</li><li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</li></ul></li></ul><h3 id="15-2-3-IO-流的-API">15.2.3 IO 流的 API</h3><p>IO 的 4 个抽象基类：InputStream 、 OutputStream 、 Reader 、 Writer。</p><p>常用的节点流:</p><ul><li>文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter</li><li>字节/字符数组流： ByteArrayInputStream、ByteArrayOutputStream、<br>CharArrayReader、CharArrayWriter - 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li></ul><p>常用处理流：</p><ul><li>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、<br>BufferedWriter - 作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。</li><li>转换流：InputStreamReader、OutputStreamReader<ul><li>作用：实现字节流和字符流之间的转换。</li></ul></li><li>对象流：ObjectInputStream、ObjectOutputStream<ul><li>作用：提供直接读写 Java 对象功能。</li></ul></li></ul><h2 id="15-3-节点流之一：FileReader、FileWriter">15.3 节点流之一：FileReader、FileWriter</h2><h3 id="15-3-1-字符输入流：Reader">15.3.1 字符输入流：Reader</h3><ul><li>java.io.Reader 抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</li><li>public int read()： 从输入流读取一个字符。 虽然读取了一个字符，但是会自动提升为 int 类型。返回该字符的 Unicode 编码值。如果已经到达流末尾了，则返回 -1。</li><li>public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。每次最多读取 cbuf.length 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回 -1。</li><li>public int read(char[] cbuf,int off,int len)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中，从 cbuf[off]开始的位置存储。每次最多读取 len 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回 -1。</li><li>public void close() ：关闭此流并释放与此流相关联的任何系统资源。</li><li>注意：当完成流的操作时，必须调用 close()方法，释放系统资源，否则会造成内存泄漏。</li></ul><h3 id="15-3-2-字符输出流：Writer">15.3.2 字符输出流：Writer</h3><ul><li>java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</li><li>public void write(int c) ：写出单个字符。</li><li>public void write(char[] cbuf)：写出字符数组。</li><li>public void write(char[] cbuf, int off, int len)：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。</li><li>public void write(String str)：写出字符串。</li><li>public void write(String str, int off, int len) ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。</li><li>public void flush()：刷新该流的缓冲。</li><li>public void close() ：关闭此流。</li><li>注意：当完成流的操作时，必须调用 close()方法，释放系统资源，否则会造成内存泄漏。</li></ul><h3 id="15-3-3-文件字符输入流：FileReader">15.3.3 文件字符输入流：FileReader</h3><ul><li>java.io.FileReader 类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</li><li>FileReader(File file)： 创建一个新的 FileReader ，给定要读取的 File 对象。</li><li>FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。</li></ul><h3 id="15-3-4-文件字符输出流：FileWriter">15.3.4 文件字符输出流：FileWriter</h3><ul><li>java.io.FileWriter 类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。</li><li>FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的 File 对象。</li><li>FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。</li><li>FileWriter(File file,boolean append)： 创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。</li></ul><h3 id="15-3-5-关于-flush（刷新）">15.3.5 关于 flush（刷新）</h3><ul><li>因为内置缓冲区的原因，如果 FileWriter 不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 flush() 方法了。</li><li>flush() ：刷新缓冲区，流对象可以继续使用。</li><li>close()：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li><li>注意：即便是 flush()方法写出了数据，操作的最后还是要调用 close 方法，释放系统资源。</li></ul><h2 id="15-4-节点流之二：FileInputStream、FileOutputStream">15.4 节点流之二：FileInputStream、FileOutputStream</h2><h3 id="15-4-1-字节输入流：InputStream">15.4.1 字节输入流：InputStream</h3><ul><li>java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</li><li>public int read()： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为 int 类型。如果已经到达流末尾，没有数据可读，则返回 -1。</li><li>public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b 中 。每次最多读取 b.length 个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回 -1。</li><li>public int read(byte[] b,int off,int len)：从输入流中读取一些字节数，并将它们存储到字节数组 b 中，从 b[off]开始存储，每次最多读取 len 个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回 -1。</li><li>public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。</li><li>注意：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li></ul><h3 id="15-4-2-字节输出流：OutputStream">15.4.2 字节输出流：OutputStream</h3><ul><li>java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</li><li>public void write(int b) ：将指定的字节输出流。虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</li><li>public void write(byte[] b)：将 b.length 字节从指定的字节数组写入此输出流。</li><li>public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。</li><li>public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li>public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li>注意：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li></ul><h3 id="15-4-3-文件字节输入流：FileInputStream">15.4.3 文件字节输入流：FileInputStream</h3><ul><li>java.io.FileInputStream 类是文件输入流，从文件中读取字节。</li><li>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File 对象 file 命名。</li><li>FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。</li></ul><h3 id="15-4-4-文件字节输出流：-FileOutputStream">15.4.4 文件字节输出流： FileOutputStream</h3><ul><li>java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。</li><li>public FileOutputStream(File file)：创建文件输出流，写出由指定的 File 对象表示的文件。</li><li>public FileOutputStream(String name)： 创建文件输出流，指定的名称为写出文件。</li><li>public FileOutputStream(File file, boolean append)： 创建文件输出流，指明是否在现有文件末尾追加内容。</li></ul><h2 id="15-5-读写数据的过程">15.5 读写数据的过程</h2><ul><li><p>步骤 1：创建 File 类的对象，作为读取或写出数据的端点。</p></li><li><p>步骤 2：创建相关的流的对象。</p></li><li><p>步骤 3：读取、写出数据的过程。</p></li><li><p>步骤 4：关闭流资源。</p></li><li><p>读取数据的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFileExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 步骤1：创建File类的对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"example.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤2：创建相关的流的对象</span></span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤3：读取数据的过程</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤4：关闭流资源</span></span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            reader.close();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>写出数据的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteFileExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 步骤1：创建File类的对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"example.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤2：创建相关的流的对象</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤3：写出数据的过程</span></span><br><span class="line">            bufferedWriter.write(<span class="string">"Hello, world!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤4：关闭流资源</span></span><br><span class="line">            bufferedWriter.close();</span><br><span class="line">            writer.close();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2 id="15-6-处理流之一：缓冲流">15.6 处理流之一：缓冲流</h2><p>为了提高数据读写的速度，Java API 提供了带缓冲功能的流类：缓冲流。</p><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p><ul><li>字节缓冲流：BufferedInputStream，BufferedOutputStream</li><li>字符缓冲流：BufferedReader，BufferedWriter</li></ul><p>缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用 8192<br>个字节(8Kb)的缓冲区），通过缓冲区读写，减少系统 IO 次数，从而提高读写的效<br>率。</p><p>构造器：</p><ul><li>public BufferedInputStream(InputStream in) ：创建一个 新的字节型的缓冲输入流。</li><li>public BufferedOutputStream(OutputStream out)： 创建一个新的字节型的缓冲输出流。</li></ul><p>字符缓冲流特有方法：</p><ul><li>BufferedReader：public String readLine(): 读一行文字。</li><li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li></ul><h2 id="15-7-处理流之二：转换流">15.7 处理流之二：转换流</h2><h3 id="15-7-1-InputStreamReader-与-OutputStreamWriter">15.7.1 InputStreamReader 与 OutputStreamWriter</h3><ul><li><p>InputStreamReader</p><ul><li><p>转换流 java.io.InputStreamReader，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li><li><p>构造器：</p><ul><li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。</li><li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul></li><li><p>OutputStreamWriter</p><ul><li><p>转换流 java.io.OutputStreamWriter ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p></li><li><p>构造器：</p><ul><li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。</li><li>OutputStreamWriter(OutputStream in,String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul></li></ul><h3 id="15-7-2-字符编码和字符集">15.7.2 字符编码和字符集</h3><ul><li><p>编码与解码 ：<br>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。</p></li><li><p>字符编码（Character Encoding） : 就是一套自然语言的字符与二进制数之间的对应规则。</p></li><li><p>编码表：生活中文字和计算机中二进制的对应规则。</p></li><li><p>乱码的情况：按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。</p></li><li><p>编码:字符——&gt;字节</p></li><li><p>解码:字节——&gt;字符</p></li><li><p>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p></li><li><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 ASCII 字符集、GBK 字符集、Unicode 字符集等。</p></li></ul><h2 id="15-8-处理流之三：对象流">15.8 处理流之三：对象流</h2><h3 id="15-8-1-对象流：ObjectOutputStream、ObjectInputStream">15.8.1 对象流：ObjectOutputStream、ObjectInputStream</h3><ul><li>ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现 Java 各种基本数据类型的数据以及对象的持久存储。</li><li>ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。</li><li>说明：对象流的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来。</li></ul><h3 id="15-8-2-对象流-API">15.8.2 对象流 API</h3><ul><li><p>ObjectOutputStream 中的构造器：</p><ul><li>public ObjectOutputStream(OutputStream out)： 创建一个指定的 ObjectOutputStream。</li></ul></li><li><p>ObjectOutputStream 中的方法：</p><ul><li>public void writeBoolean(boolean val)：写出一个 boolean 值。</li><li>public void writeByte(int val)：写出一个 8 位字节。</li><li>public void writeShort(int val)：写出一个 16 位的 short 值。</li><li>public void writeChar(int val)：写出一个 16 位的 char 值。</li><li>public void writeInt(int val)：写出一个 32 位的 int 值。</li><li>public void writeLong(long val)：写出一个 64 位的 long 值。</li><li>public void writeFloat(float val)：写出一个 32 位的 float 值。</li><li>public void writeDouble(double val)：写出一个 64 位的 double 值</li><li>public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。 如果 s 为 null，则抛出 NullPointerException。</li><li>public void writeObject(Object obj)：写出一个 obj 对象。</li><li>public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。</li></ul></li><li><p>ObjectInputStream 中的构造器：</p><ul><li>public ObjectInputStream(InputStream in)： 创建一个指定的 ObjectInputStream。</li></ul></li><li><p>ObjectInputStream 中的方法：</p><ul><li>public boolean readBoolean()：读取一个 boolean 值。</li><li>public byte readByte()：读取一个 8 位的字节。</li><li>public short readShort()：读取一个 16 位的 short 值。</li><li>public char readChar()：读取一个 16 位的 char 值。</li><li>public int readInt()：读取一个 32 位的 int 值。</li><li>public long readLong()：读取一个 64 位的 long 值。</li><li>public float readFloat()：读取一个 32 位的 float 值。</li><li>public double readDouble()：读取一个 64 位的 double 值。</li><li>public String readUTF()：读取 UTF-8 修改版格式的 String。</li><li>public void readObject(Object obj)：读入一个 obj 对象。</li><li>public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。</li></ul></li></ul><h3 id="15-8-3-认识对象序列化机制">15.8.3 认识对象序列化机制</h3><ul><li><p>何为对象序列化机制？</p><ul><li>对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</li></ul></li><li><p>序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。</p></li><li><p>反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。</p></li><li><p>序列化机制的重要性</p><ul><li>序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。</li><li>序列化的好处，在于可将任何实现了 Serializable 接口的对象转化为字节数据，使其在保存和传输时可被还原。</li></ul></li><li><p>实现原理</p><ul><li>序列化：用 ObjectOutputStream 类保存基本类型数据或对象的机制。方法为：<ul><li>public final void writeObject (Object obj) : 将指定的对象写出。</li></ul></li><li>反序列化：用 ObjectInputStream 类读取基本类型数据或对象的机制。方法为：<ul><li>public final Object readObject () : 读取一个对象。</li></ul></li></ul></li><li><p>如何实现序列化机制</p><ul><li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现 java.io.Serializable 接口。Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序<br>列化或反序列化，会抛出 NotSerializableException。</p></li><li><p>如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现 Serializable 接口。</p></li><li><p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 transient 关键字修饰。</p></li><li><p>静态（static）变量的值不会序列化。因为静态变量的值不属于某个对象。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"Tom"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 将对象序列化为字节流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"person.ser"</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.close();</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将字节流反序列化为对象</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"person.ser"</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            fis.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(p.getName() + <span class="string">" "</span> + p.getAge());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)</span><br><span class="line">        {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="15-8-4-反序列化失败问题">15.8.4 反序列化失败问题</h3><ul><li><p>问题 1：</p><ul><li>对于 JVM 可以反序列化对象，它必须是能够找到 class 文件的类。如果找不到该类的 class 文件，则抛出一个 ClassNotFoundException 异常。</li></ul></li><li><p>问题 2：</p><ul><li><p>当 JVM 反序列化对象时，能找到 class 文件，但是 class 文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 InvalidClassException 异常。发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配。</li><li>该类包含未知数据类型。</li></ul></li><li><p>解决办法：</p><ul><li><p>Serializable 接口给需要序列化的类，提供了一个序列版本号：serialVersionUID 。凡是实现 Serializable 接口的类都应该有一个表示序列化<br>版本标识符的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">234242343243L</span>;    <span class="comment">// 值随意指定即可</span></span><br></pre></td></tr></table></figure></li><li><p>serialVersionUID 用来表明类的不同版本间的兼容性。简单来说，Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</p></li><li><p>如果类没有显示定义这个静态常量，它的值是 Java 运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。因此，建议显式声明。</p></li><li><p>如果声明了 serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</p></li></ul></li></ul></li></ul><h2 id="15-9-其它流">15.9 其它流</h2><h3 id="15-9-1-数据流：DataInputStream-、DataOutputStream">15.9.1 数据流：DataInputStream 、DataOutputStream</h3><ul><li><p>如果需要将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中，那怎么办呢？</p></li><li><p>Java 提供了数据流和对象流来处理这些类型的数据：</p><ul><li>数据流：DataOutputStream、DataInputStream<ul><li>DataOutputStream：允许应用程序将基本数据类型、String 类型的变量写入输出流中。</li><li>DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String 类型的变量。</li></ul></li></ul></li><li><p>数据流的弊端：只支持 Java 基本数据类型和字符串的读写，而不支持其它 Java 对象的类型。而 ObjectOutputStream 和 ObjectInputStream 既支持 Java 基本数据类型的数据读写，又支持 Java 对象的读写。</p></li></ul><h3 id="15-9-2-标准的输入流、标准的输出流：System-in-、System-out">15.9.2 标准的输入流、标准的输出流：<a href="http://System.in">System.in</a> 、System.out</h3><ul><li><a href="http://System.in">System.in</a> 和 System.out 分别代表了系统标准的输入和输出设备。</li><li>默认输入设备是：键盘，输出设备是：显示器。</li><li><a href="http://System.in">System.in</a> 的类型是 InputStream。</li><li>System.out 的类型是 PrintStream，其是 OutputStream 的子类 FilterOutputStream 的子类。</li><li>重定向：通过 System 类的 setIn，setOut 方法对默认设备进行改变。<ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ul></li></ul><h3 id="15-9-3-打印流：PrintStream、PrintWriter">15.9.3 打印流：PrintStream、PrintWriter</h3><ul><li>实现将基本数据类型的数据格式转化为字符串输出。</li><li>打印流：PrintStream 和 PrintWriter。<ul><li>提供了一系列重载的 print()和 println()方法，用于多种数据类型的输出。</li><li>PrintStream 和 PrintWriter 的输出不会抛出 IOException 异常。</li><li>PrintStream 和 PrintWriter 有自动 flush 功能。</li><li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li><li>System.out 返回的是 PrintStream 的实例</li></ul></li><li>构造器：<ul><li>PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。</li><li>PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</li><li>PrintStream(OutputStream out) ：创建新的打印流。</li><li>PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。autoFlush 如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 (‘\n’) 时都会刷新输出缓冲区。</li><li>PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。</li><li>PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。</li><li>PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</li></ul></li></ul><h3 id="15-9-4-Scanner-类">15.9.4 Scanner 类</h3><ul><li><p>构造方法：</p><ul><li>Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。</li><li>Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。</li><li>Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li><li>Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li></ul></li><li><p>常用方法：</p><ul><li>boolean hasNextXxx()： 如果通过使用 nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。</li><li>Xxx nextXxx()： 将输入信息的下一个标记扫描为一个 Xxx</li></ul></li></ul><h2 id="15-10-企业真题">15.10 企业真题</h2><ol><li><p>谈谈 Java IO 里面的常用类，字节流，字符流？<br>答：<br>Java IO 里面的常用类包括：</p><ul><li>InputStream/OutputStream：字节流的基本类，用于读写字节数据。</li><li>Reader/Writer：字符流的基本类，用于读写字符数据。</li><li>FileInputStream/FileOutputStream：用于读写文件的字节流类。</li><li>FileReader/FileWriter：用于读写文件的字符流类。</li><li>ByteArrayInputStream/ByteArrayOutputStream：用于读写字节数组的流类。</li><li>CharArrayReader/CharArrayWriter：用于读写字符数组的流类。</li><li>BufferedInputStream/BufferedOutputStream：用于带缓冲的读写字节数据的流类。</li><li>BufferedReader/BufferedWriter：用于带缓冲的读写字符数据的流类。</li><li>DataInputStream/DataOutputStream：用于读写基本数据类型的字节流类。</li><li>InputStreamReader/OutputStreamWriter：用于将字节流转换成字符流的类。</li><li>ObjectInputStream/ObjectOutputStream：用于读写 Java 对象的字节流类。</li><li>PipedInputStream/PipedOutputStream：用于在线程之间传递数据的流类。</li><li>PrintStream/PrintWriter：用于将数据打印到输出流的类。</li></ul><p>总的来说，Java IO 提供了丰富的流类来满足各种读写需求，其中字节流和字符流是最基本的两种类型，字节流适用于读写二进制数据，而字符流适用于读写文本数据。在实际应用中需要根据具体的需求选择合适的流类。</p></li><li><p>Java 中有几种类型的流？JDK 为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？<br>答：<br>Java 中有四种类型的流：字节流、字符流、字节缓冲流和字符缓冲流。</p><p>JDK 为每种类型的流提供一些抽象类以供继承，如下所示：<br>① 字节流：<br>InputStream：所有字节输入流的父类。<br>OutputStream：所有字节输出流的父类。<br>② 字符流：<br>Reader：所有字符输入流的父类。<br>Writer：所有字符输出流的父类。<br>③ 字节缓冲流：<br>BufferedInputStream：字节缓冲输入流。<br>BufferedOutputStream：字节缓冲输出流。<br>④ 字符缓冲流：<br>BufferedReader：字符缓冲输入流。<br>BufferedWriter：字符缓冲输出流。</p></li><li><p>流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？<br>答：<br>在 Java 中，流一般需要关闭以释放资源和避免内存泄漏。关闭流可以使用 close()方法进行处理。例如，对于文件输入流，可以使用以下代码关闭流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"example.txt"</span>);</span><br><span class="line"><span class="comment">//处理流</span></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>对于网络连接，可以使用以下代码关闭流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//处理流</span></span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>在 Java 7 及以上版本中，可以使用 try-with-resources 语句来自动关闭流，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"example.txt"</span>))</span><br><span class="line">{</span><br><span class="line"><span class="comment">//处理流</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>OutputStream 里面的 write()是什么意思?<br>答：<br>OutputStream 中的 write()是将数据写入输出流的方法。它的作用是将指定的字节数组写入输出流中。在 Java 中，OutputStream 是一个抽象类，它提供了几个不同的 write()方法的实现，可以将字节数组、单个字节、字符串、整数等类型的数据写入输出流中。当数据被写入输出流后，它们就可以被传输到其他地方，例如网络连接、文件、内存等。</p></li><li><p>BufferedReader 属于哪种流？他主要是用来做什么的？<br>答：<br>BufferedReader 属于字符流，主要用于读取文本数据。它可以将字符从输入流中读取到缓冲区中，从而提高读取效率，同时也提供了一些方便的读取方法。常见的应用场景包括读取文本文件、读取网络数据等。</p></li><li><p>什么是缓冲区？有什么作用？<br>答：<br>缓冲区是一种临时存储数据的区域，用于提高数据的读写效率。在 Java 中，缓冲区主要用于输入输出流的操作中，如 BufferedReader 和 BufferedWriter 等。</p><p>缓冲区的作用是将数据暂时保存在内存中，等到缓冲区满了或者需要进行数据读取时，再一次性将数据写入到文件或者从文件中读取到缓冲区中。这样可以减少与硬盘的交互次数，提高数据读写效率，同时也减轻了硬盘的负担，延长了硬盘的使用寿命。</p><p>另外，缓冲区还可以提供一些额外的功能，如数据的压缩、加密、解密等操作，使得数据的处理更加灵活和高效。</p></li><li><p>字节流和字符流是什么？怎么转换？<br>答：<br>字节流和字符流是 Java 中用于处理输入输出的两种不同的流类型。字节流以字节为单位进行读写，适用于处理二进制文件和网络数据流等；字符流以字符为单位进行读写，适用于处理文本文件和文本数据流等。</p><p>在 Java 中，字节流主要由 InputStream 和 OutputStream 两个抽象类及其实现类构成，而字符流主要由 Reader 和 Writer 两个抽象类及其实现类构成。常用的字节流实现类有 FileInputStream、FileOutputStream、BufferedInputStream 等，常用的字符流实现类有 FileReader、FileWriter、BufferedReader 等。</p><p>转换字节流和字符流可以使用 InputStreamReader 和 OutputStreamWriter 类。InputStreamReader 将字节流转换为字符流，OutputStreamWriter 将字符流转换为字节流。例如，可以使用以下代码将字节流转换为字符流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"file.txt"</span>);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>其中，"file.txt"是要读取的文件名，"UTF-8"是字符集编码。可以使用以下代码将字符流转换为字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"file.txt"</span>);</span><br><span class="line"><span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>什么是 Java 序列化，如何实现？<br>答：<br>Java 序列化是将 Java 对象转换为字节序列的过程，以便在网络上传输或将其保存到磁盘上。序列化的过程中，Java 会将对象的状态保存为一组字节，并将其写入到输出流中，以便在需要时可以重新构造出原始对象。</p><p>要实现 Java 序列化，需要以下步骤：<br>① 让 Java 类实现 Serializable 接口。这个接口是一个标记接口，没有任何方法，只是用来表示该类可以被序列化。<br>② 创建一个 ObjectOutputStream 实例，并将其连接到一个输出流中。这个输出流可以是文件输出流、网络输出流等。<br>③ 调用 ObjectOutputStream 的 writeObject()方法，将需要序列化的 Java 对象写入输出流中。<br>④ 关闭输出流。</p><p>反序列化则是将字节序列转换为 Java 对象的过程。要实现反序列化，需要以下步骤：<br>① 创建一个 ObjectInputStream 实例，并将其连接到一个输入流中。这个输入流可以是文件输入流、网络输入流等。<br>② 调用 ObjectInputStream 的 readObject()方法，从输入流中读取字节序列，并将其转换为 Java 对象。<br>③ 关闭输入流。</p><p>需要注意的是，在序列化和反序列化过程中，Java 对象的类名、字段名等信息都会被写入到字节序列中，因此在反序列化时，需要确保读取的字节序列所对应的 Java 类仍然存在，否则会抛出 ClassNotFoundException 异常。</p></li><li><p>Java 有些类中为什么需要实现 Serializable 接口？<br>答：<br>Java 中的 Serializable 接口是一个标记接口，用于指示一个类的对象可以被序列化。序列化是指将对象转换为字节流的过程，以便在网络上传输或保存到文件中。实现 Serializable 接口的类可以被 Java 中的序列化机制所处理，从而可以实现对象的持久化和远程调用等功能。因此，如果一个类需要被序列化，就需要实现 Serializable 接口。</p></li></ol><h1>第 16 章 网络编程</h1><h2 id="16-1-网络编程概述">16.1 网络编程概述</h2><p>计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p><p>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</p><p>需要解决的三个问题：</p><ul><li>问题 1：如何准确地定位网络上一台或多台主机？</li><li>问题 2：如何定位主机上的特定的应用？</li><li>问题 3：找到主机后，如何可靠、高效地进行数据传输？</li></ul><h2 id="16-2-IP-地址和域名">16.2. IP 地址和域名</h2><h3 id="16-2-1-IP-地址">16.2.1 IP 地址</h3><ul><li><p>IP 地址：指互联网协议地址（Internet Protocol Address），俗称 IP。IP 地址<br>用来给网络中的一台计算机设备做唯一的编号。</p></li><li><p>IP 分类：</p><ul><li><p>角度一：IPv4、IPv6。</p><ul><li>IPv4：是一个 32 位的二进制数，通常被分为 4 个字节，表示成 a.b.c.d 的形式，以点分十进制表示，例如 192.168.65.100 。其中 a、b、c、d 都是 0~255 之间的十进制整数。</li><li>IPv6：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，共 16 个字节，写成 8 个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开。比如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，按保守方法估算 IPv6 实际可分配的地址，整个地球的每平方米面积上仍可分配 1000 多个地<br>址，这样就解决了网络地址资源数量不够的问题。</li></ul></li><li><p>角度二：公网地址、私网地址（或局域网)。</p><ul><li>192.168.开头的就是私有地址，范围即为 192.168.0.0–192.168.255.255，专门为组织机构内部使用。</li></ul></li></ul></li><li><p>使用 InetAddress 类表示 IP 地址。</p><ul><li>实例化：getByName(String host) 、getLocalHost()。</li><li>常用方法：getHostName() 、getHostAddress()。</li></ul></li></ul><h3 id="16-2-2-域名">16.2.2 域名</h3><ul><li><p>Internet 上的主机有两种方式表示地址：</p><ul><li>域名(hostName)：<a href="https://www.baidu.com">https://www.baidu.com</a></li><li>IP 地址(hostAddress)：202.108.22.5</li></ul></li><li><p>域名解析：因为 IP 地址数字不便于记忆，因此出现了域名。域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS，Domain Name System，域名系统)负责将域名转化成 IP 地址，这样才能和主机建立连接。</p></li></ul><h2 id="16-3-端口号">16.3 端口号</h2><p>如果说 IP 地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程。</p><p>不同的进程分配不同的端口号。</p><p>端口号：用两个字节表示的整数，它的取值范围是 0~65535。</p><ul><li>公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23）。</li><li>注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。</li><li>动态/ 私有端口：49152~65535。</li></ul><h2 id="16-4-网络通信协议">16.4 网络通信协议</h2><p>网络通信协议有两套参考模型。</p><ul><li>OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广。</li><li>TCP/IP 参考模型(或 TCP/IP 协议)：事实上的国际标准。</li></ul><p><img src="https://img-blog.csdnimg.cn/bdfd05b2f58642159c389244049bf717.png" alt="在这里插入图片描述"></p><h3 id="16-4-1-TCP、UDP">16.4.1 TCP、UDP</h3><p>在传输层中涉及到两个协议：TCP、UDP。二者的对比。</p><ul><li>TCP：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。</li><li>UDP：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在 64kb 以内）、效率高。</li></ul><h3 id="16-4-2-TCP-的三次握手">16.4.2 TCP 的三次握手</h3><p>TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p><ul><li>第一次握手，客户端向服务器端发起 TCP 连接的请求。</li><li>第二次握手，服务器端发送针对客户端 TCP 连接请求的确认。</li><li>第三次握手，客户端发送确认的确认。</li></ul><p><img src="https://img-blog.csdnimg.cn/77bb5cafefe4434fa946062b07d2b1eb.png" alt="TCP的三次握手"></p><h3 id="16-4-2-TCP-的四次挥手">16.4.2 TCP 的四次挥手</h3><p>TCP 协议中，在发送数据结束后，释放连接时需要经过四次挥手。</p><ul><li>第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据。</li><li>第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据。</li><li>第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。</li><li>第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待 2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待 2MSL 后，没有收到，那么彻底断开。</li></ul><p><img src="https://img-blog.csdnimg.cn/6eb581bd50db4be08b06d5bef53d90eb.png" alt="TCP的四次挥手"></p><h2 id="16-5-网络编程-API">16.5 网络编程 API</h2><h3 id="16-5-1-InetAddress-类">16.5.1 InetAddress 类</h3><ul><li><p>InetAddress 类主要表示 IP 地址，两个子类：Inet4Address、Inet6Address。</p></li><li><p>InetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取 InetAddress 实例。</p><ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByName(String host)</li><li>public static InetAddress getByAddress(byte[] addr)</li></ul></li><li><p>InetAddress 提供了如下几个常用的方法。</p><ul><li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）。</li><li>public String getHostName() ：获取此 IP 地址的主机名。</li><li>public boolean isReachable(int timeout)：测试是否可以达到该地址。</li></ul></li></ul><h3 id="16-5-2-Socket-类">16.5.2 Socket 类</h3><p>网络上具有唯一标识的 IP 地址和端口号组合在一起构成唯一能识别的标识符套接字 （Socket）。</p><p>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。网络通信其实就是 Socket 间的通信。</p><p>通信的两端都要有 Socket，是两台机器间通信的端点。</p><p>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输。</p><p>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</p><p>Socket 分类：</p><ul><li>流套接字（stream socket）：使用 TCP 提供可依赖的字节流服务。<ul><li>ServerSocket：此类实现 TCP 服务器套接字。服务器套接字等待请求通过网络传入。</li><li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li></ul></li><li>数据报套接字（datagram socket）：使用 UDP 提供“尽力而为”的数据报服务。<ul><li>DatagramSocket：此类表示用来发送和接收 UDP 数据报包的套接字。</li></ul></li></ul><h3 id="16-5-3-DatagramSocket-类">16.5.3 DatagramSocket 类</h3><ul><li>DatagramSocket 类的常用方法：<ul><li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li><li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。</li><li>public void close()关闭此数据报套接字。</li><li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</li><li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时， DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。</li><li>public InetAddress getLocalAddress()获取套接字绑定的本地地址。</li><li>public int getLocalPort()返回此套接字绑定的本地主机上的端口号。</li><li>public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。</li><li>public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。</li></ul></li></ul><h3 id="16-5-4-DatagramPacket-类">16.5.4 DatagramPacket 类</h3><ul><li>DatagramPacket 类的常用方法：<ul><li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li><li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报<br>包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li><li>public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。</li><li>public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。</li><li>public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。</li><li>public int getLength()返回将要发送或接收到的数据的长度。</li></ul></li></ul><h2 id="16-6-TCP-网络编程">16.6 TCP 网络编程</h2><h3 id="16-6-1-通信模型">16.6.1 通信模型</h3><p>Java 语言的基于套接字 TCP 编程分为服务端编程和客户端编程，其通信模型如图所示：</p><p><img src="https://img-blog.csdnimg.cn/128625d7069044499b107733a9f31d3b.png" alt="通信模型"></p><h3 id="16-6-2-开发步骤">16.6.2 开发步骤</h3><ul><li><p>客户端程序包含以下四个基本的步骤 ：</p><ul><li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket 的输入/ 出流： 使用 getInputStream()方法获得输入流，使用<br>getOutputStream()方法获得输出流，进行数据传输。</li><li>按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</li><li>关闭 Socket ：断开客户端到服务器的连接，释放线路。</li></ul></li><li><p>服务器端程序包含以下四个基本的 步骤：</p><ul><li>调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li><li>调用该 Socket 类对象的 getOutputStream() 和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。</li><li>关闭 Socket 对象：客户端访问结束，关闭通信套接字。</li></ul></li></ul><h2 id="16-7-UDP-网络编程">16.7 UDP 网络编程</h2><h3 id="16-7-1-通信模型">16.7.1 通信模型</h3><p>UDP 协议是一种面向非连接的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP 协议无法控制，因此说，UDP 协议是一种不可靠的协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。</p><p>UDP 会尽最大努力交付数据，但不保证可靠交付，没有 TCP 的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP 也不会给应用层返回错误信息。</p><p>UDP 协议是面向数据报文的信息传送服务。UDP 在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于 ip 层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送 100 个字节的报文，我们调用一次 send()方法就会发送 100 字节，接收方也需要用 receive() 方法一次性接收 100 字节，不能使用循环每次获取 10 个字节，获取十次这样的做法。</p><p>UDP 协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然 UDP 的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证 UDP 报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。因此 UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在 64K 以下。</p><p>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的 IP 地址和端口号以及接收端的 IP 地址和端口号。</p><h3 id="16-7-2-开发步骤">16.7.2 开发步骤</h3><ul><li><p>发送端程序包含以下四个基本的步骤：</p><ul><li>创建 DatagramSocket ：默认使用系统随机分配端口号。</li><li>创建 DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长<br>度，接收方的 IP 地址和端口号。</li><li>调用该 DatagramSocket 类对象的 send 方法 ：发送数据报 DatagramPacket 对象。</li><li>关闭 DatagramSocket 对象：发送端程序结束，关闭通信套接字。</li></ul></li><li><p>接收端程序包含以下四个基本的步骤 ：</p><ul><li>创建 DatagramSocket ：指定监听的端口号。 -创建 DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。</li><li>调用 该 DatagramSocket 类对象的 receive 方法 ：接收数据报 DatagramPacket 对<br>象。</li><li>关闭 DatagramSocket ：接收端程序结束，关闭通信套接字。</li></ul></li></ul><h2 id="16-8-URL-编程">16.8 URL 编程</h2><p>Java 后台：将写好的 Java 程序部署在 Tomcat 服务器。启动 Tomcat 服务器。</p><p>前台：使用浏览器进行访问。需要使用 url。（HTML+CSS+JavaScript）</p><p>URL 的作用：定位互联网上某一资源的地址。</p><p>URL 的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.21.107:8080/examples/abcd.jpg?name=Tom</span><br><span class="line">应用层协议    ip地址    端口号    资源地址     参数列表</span><br></pre></td></tr></table></figure><p>使用 URL 实现数据的下载。</p><h2 id="16-9-企业真题">16.9 企业真题</h2><ol><li><p>TCP 协议和 UDP 协议的区别？<br>答：<br>TCP 协议和 UDP 协议是网络传输协议，二者的区别主要有以下几点：<br>① 连接方式：TCP 协议是面向连接的协议，UDP 协议是无连接的协议。<br>② 可靠性：TCP 协议提供可靠的传输，保证数据的完整性和正确性，而 UDP 协议不保证数据的可靠性，因此传输速度更快。<br>③ 传输速度：UDP 协议的传输速度比 TCP 协议快，因为它没有建立连接的过程和数据校验的过程。<br>④ 数据包大小：TCP 协议传输的数据包大小是有限制的，而 UDP 协议可以传输更大的数据包。<br>⑤ 流量控制：TCP 协议具有流量控制和拥塞控制的功能，可以调整数据的传输速度，而 UDP 协议则没有这个功能。<br>⑥ 应用场景：TCP 协议适用于需要可靠传输的场景，如文件传输、电子邮件等；UDP 协议适用于实时传输和数据量较小的场景，如音频、视频等。</p><p>综上所述，TCP 协议和 UDP 协议各有优缺点，根据不同的应用场景选择合适的协议可以提高网络传输效率和数据传输质量。</p></li><li><p>简单说说 TCP 协议的三次握手与四次挥手机制？<br>答：<br>TCP 协议的三次握手是指，在建立 TCP 连接时，客户端和服务器双方需要进行三次通信来确认彼此的身份和确认双方的通信能力。具体流程如下：<br>① 客户端发送一个 SYN 报文给服务器端，表示客户端请求连接。<br>② 服务器接收到客户端的 SYN 报文后，向客户端发送一个 SYN+ACK 报文，表示服务器已经收到客户端的请求，并请求确认连接。<br>③ 客户端接收到服务器端的 SYN+ACK 报文后，向服务器端发送一个 ACK 报文，表示客户端已经确认连接，连接建立成功。</p><p>TCP 协议的四次挥手是指，在关闭 TCP 连接时，客户端和服务器双方需要进行四次通信来关闭连接。具体流程如下：<br>① 客户端向服务器端发送一个 FIN 报文，表示客户端要关闭连接。<br>② 服务器接收到客户端的 FIN 报文后，向客户端发送一个 ACK 报文，表示服务器已经接收到客户端的请求，但是服务器还需要一些时间来处理数据。<br>③ 服务器处理完数据后，向客户端发送一个 FIN 报文，表示服务器也要关闭连接。<br>④ 客户端接收到服务器端的 FIN 报文后，向服务器端发送一个 ACK 报文，表示客户端已经接收到服务器端的请求，连接关闭成功。</p></li></ol><h1>第 17 章 反射机制</h1><h2 id="17-1-反射的概述">17.1 反射的概述</h2><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在运行期间借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p><p>Java 给我们提供了一套 API，使用这套 API 我们可以在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等。</p><p>反射相关的主要 API：</p><ul><li>java.lang.Class：代表一个类。</li><li>java.lang.reflect.Method：代表类的方法。</li><li>java.lang.reflect.Field：代表类的成员变量。</li><li>java.lang.reflect.Constructor：代表类的构造器。</li></ul><p>反射的优点和缺点：</p><ul><li>优点：</li><li>提高了 Java 程序的灵活性和扩展性，降低了耦合性，提高自适应能力。</li><li>允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li><li>缺点：</li><li>反射的性能较低。<ul><li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上。</li></ul></li><li>反射会模糊程序内部逻辑，可读性较差。</li></ul><p>反射，平时开发中，我们使用并不多。主要是在框架的底层使用。</p><h2 id="17-2-Class-反射的源头">17.2 Class:反射的源头</h2><p>Class 的理解：</p><ul><li>针对于编写好的.java 源文件进行编译(使用 javac.exe)，会生成一个或多个.class 字节码文件。接着，我们使用 java.exe 命令对指定的.class 文件进行解释运行。这个解释运行的过程中，我们需要将.class 字节码文件加载(使用类的加载器)到内存中(存放在方法区)。加载到内存中的.class 文件对应的结构即为 Class 的一个实例。</li></ul><p>Class 本身也是一个类。</p><p>Class 对象只能由系统建立对象。</p><p>一个加载的类在 JVM 中只会有一个 Class 实例。</p><p>一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件。</p><p>每个类的实例都会记得自己是由哪个 Class 实例所生成。</p><p>通过 Class 可以完整地得到一个类中的所有被加载的结构。</p><p>Class 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象。</p><p>获取 Class 的实例的几种方式。</p><ul><li>类.class</li><li>对象.getClass()</li><li>Class 调用静态方法 forName(String className)</li><li>使用 ClassLoader 的方法 loadClass(String className)</li></ul><p>Class 可以指向哪些结构？</p><ul><li>简言之，所有 Java 类型。<br>① class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>② interface：接口<br>③ []：数组<br>④ enum：枚举<br>⑤ annotation：注解@interface<br>⑥ primitive type：基本数据类型<br>⑦ void</li></ul><h2 id="17-3-类的加载过程、类的加载器">17.3 类的加载过程、类的加载器</h2><ul><li><p>类的加载过程</p><p><img src="https://img-blog.csdnimg.cn/fd2f3b1b74b64c19bbd04e2fc27562e9.png" alt="类的加载过程"></p><ul><li><p>过程 1：类的装载(loading)</p><ul><li>将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。此过程由类加载器完成。</li></ul></li><li><p>过程 2：链接(linking)<br>① 验证(Verify):确保加载的类信息符合 JVM 规范，例如：以 cafebabe 开头，没有安全方面的问题。<br>② 准备(Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。<br>③ 解析(Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p></li><li><p>过程 3：初始化(initialization)</p><ul><li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</clinit></clinit></li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li></ul></li></ul></li><li><p>类的加载器</p><p><img src="https://img-blog.csdnimg.cn/d725cc5fa3294ba1bba5ab911885cede.png" alt="类的加载器"></p><ul><li><p>作用：负责类的加载，并对应于一个 Class 的实例。</p></li><li><p>分类：</p><ul><li>启动类加载器（引导类加载器，Bootstrap ClassLoader）<ul><li>使用 C/C++语言编写的，不能通过 Java 代码获取其实例。</li><li>负责加载 Java 的核心库。（JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容）</li></ul></li><li>扩展类加载器（Extension ClassLoader）<ul><li>负责加载从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。</li></ul></li><li>应用程序类加载器（系统类加载器，AppClassLoader）<ul><li>我们自定义的类，默认使用的类的加载器。</li></ul></li><li>用户自定义类的加载器。<ul><li>实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。</li></ul></li></ul></li></ul></li></ul><h2 id="17-4-反射的应用-1：创建运行时类的对象">17.4 反射的应用 1：创建运行时类的对象</h2><p>在 Java 中，我们可以通过反射来创建运行时类的对象。具体步骤如下：<br>① 获取运行时类的 Class 对象，可以使用 Class.forName()方法或者运行时类的.class 属性来获取。<br>② 使用 Class 对象的 newInstance()方法来创建运行时类的对象。该方法会调用运行时类的无参构造器来创建对象。<br>③ 如果运行时类没有无参构造器，可以使用 Class 对象的 getConstructor()方法来获取指定参数类型的构造器，然后使用 Constructor 对象的 newInstance()方法来创建运行时类的对象。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取运行时类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">"com.example.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Class对象的newInstance()方法来创建对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Constructor对象的newInstance()方法来创建对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>需要注意的是，使用反射创建对象的效率较低，因为需要通过反射调用构造器来创建对象，而不是直接调用 new 关键字。因此，在实际开发中，应该尽量避免频繁使用反射来创建对象。</p><h2 id="17-5-反射的应用-2：获取运行时类所有的结构">17.5 反射的应用 2：获取运行时类所有的结构</h2><p>在 Java 中，可以使用反射获取运行时类所有的结构，包括类名、父类、接口、构造方法、字段、方法等。以下是一些常用的反射方法：</p><ul><li>获取类名：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> clazz.getName();</span><br></pre></td></tr></table></figure><ul><li>获取父类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; superClass = clazz.getSuperclass();</span><br></pre></td></tr></table></figure><ul><li>获取实现的接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br></pre></td></tr></table></figure><ul><li>获取构造方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br></pre></td></tr></table></figure><ul><li>获取字段：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = clazz.getFields();</span><br></pre></td></tr></table></figure><ul><li>获取方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br></pre></td></tr></table></figure><p>通过反射，可以动态地获取运行时类的结构信息，并且可以根据需要进行访问和修改。但是，使用反射也需要谨慎，因为它可能会影响程序的性能和安全性。</p><h2 id="17-6-反射的应用-3：调用指定的结构">17.6 反射的应用 3：调用指定的结构</h2><p>在 Java 中，可以使用反射调用指定类的方法。首先需要获取该类的 Class 对象，然后通过 Class 对象获取指定方法的 Method 对象，最后通过 Method 对象调用该方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Hello, I'm "</span> + name + <span class="string">", "</span> + age + <span class="string">" years old."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">        method.invoke(person);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上代码中，首先通过 Class 对象获取构造方法，然后创建一个 Person 对象。然后通过 Class 对象获取 sayHello 方法的 Method 对象，最后通过 Method 对象调用该方法。输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I'm Tom, 20 years old.</span><br></pre></td></tr></table></figure><h2 id="17-7-反射的应用-4：注解的使用">17.7 反射的应用 4：注解的使用</h2><p>在 Java 语言中，反射是指在运行时动态地获取类的信息并进行操作的能力。注解是一种在程序中添加元数据的方式，它可以在类、方法、字段等元素上添加注释，提供额外的信息。注解的使用可以通过反射来实现。</p><p>例如，我们定义了一个注解@MyAnnotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation</span><br><span class="line">{</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们可以在程序中使用@MyAnnotation 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value="Hello World")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在程序运行时，我们可以通过反射获取这个类的注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;MyClass&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();    <span class="comment">// value的值为"Hello World"</span></span><br></pre></td></tr></table></figure><p>通过反射获取注解信息，我们可以根据注解的值来进行不同的操作，例如根据注解值来动态生成代码、修改程序行为等等。</p><h2 id="17-8-体会：反射的动态性">17.8 体会：反射的动态性</h2><ul><li><p>反射的动态性指的是在程序运行时，可以通过反射机制获取并操作对象的信息，而不需要在编译时就确定对象的类型。这种动态性使得程序具有更大的灵活性和扩展性。</p></li><li><p>例如，我们可以通过反射机制获取一个类的所有方法、属性、构造器等信息，然后动态地创建对象、调用方法、修改属性等。这样就可以在运行时根据需要动态地创建和操作对象，而不需要在编译时就确定对象的类型和行为。</p></li><li><p>反射的动态性也带来了一些挑战和风险，因为在运行时动态创建和操作对象可能会导致一些不可预测的行为和错误。因此，在使用反射机制时需要谨慎考虑其使用场景和限制条件，以确保程序的正确性和稳定性。</p></li><li><p>以下是一个简单的反射示例代码，演示如何通过反射机制获取类的信息并创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取类对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造器并创建对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法并调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">"setValue"</span>, <span class="type">int</span>.class);</span><br><span class="line">        method.invoke(obj, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性并修改</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(obj.getValue()); <span class="comment">// 输出30</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们首先通过 MyClass.class 获取了该类的类对象 clazz，然后通过 clazz 获取了构造器、方法和属性等信息。接着，我们使用反射机制创建了一个 MyClass 对象 obj，并通过反射调用了 setValue 方法和修改了 value 属性的值。最后，我们输出了 obj 的 value 属性值，结果为 30。</p></li></ul><h2 id="17-9-企业真题">17.9 企业真题</h2><ol><li><p>对反射了解吗？反射有什么好处？为什么需要反射？<br>答：<br>反射是一种程序能够在运行时自我检查和修改自身行为和状态的能力。在 Java 语言中，反射允许程序在运行时获取类的信息，比如类名、方法、属性等，并且可以动态地调用这些方法和属性。</p><p>反射的好处是它可以使程序更加灵活和可扩展。通过反射，程序可以在运行时动态地加载和使用类，而不需要在编译时就确定类的类型。这使得程序可以根据需要动态地创建对象、调用方法、访问属性等。</p><p>反射的另一个好处是它可以帮助程序员编写更加通用和灵活的代码。通过反射，程序员可以编写通用的代码，而不需要针对每个具体的类编写不同的代码。这使得代码更加简洁、易于维护和扩展。</p><p>需要反射的主要原因是程序需要在运行时动态地加载和使用类。这通常发生在以下情况下：<br>① 当程序需要动态地创建对象时，比如根据用户输入的类名创建对象。<br>② 当程序需要动态地调用方法时，比如根据用户输入的方法名和参数类型调用方法。<br>③ 当程序需要动态地访问属性时，比如根据用户输入的属性名获取属性值。</p><p>总之，反射是一种非常有用的技术，可以使程序更加灵活、通用和可扩展。但是，由于反射需要在运行时动态地加载和使用类，所以它可能会影响程序的性能。因此，在使用反射时需要权衡性能和灵活性之间的平衡。</p></li><li><p>反射的使用场合和作用、及其优缺点？<br>答：<br>反射是指在运行时动态地获取类的信息并进行操作的能力。它可以在程序运行时动态地获取类或对象的属性、方法、构造函数等信息，并进行操作。反射可以让程序员在不知道类名的情况下，通过字符串来获取类的信息、创建对象、调用方法等。反射在以下场合有很好的应用：<br>① 框架开发：反射可以在框架开发中使用，例如 Spring 框架中的 IOC 容器就是基于反射实现的。<br>② 动态代理：反射可以用于动态代理，它可以在运行时动态地创建代理对象，并增加一些额外的功能。<br>③ 序列化和反序列化：反射可以在序列化和反序列化过程中使用，例如 Java 中的 ObjectInputStream 和 ObjectOutputStream 类就是基于反射实现的。<br>④ 单元测试：反射可以用于单元测试中，例如 JUnit 框架就是基于反射实现的。</p><p>反射的优点：<br>① 反射提供了动态性，可以在运行时获取类的信息，方便进行操作。<br>② 反射可以实现类似于泛型的功能，可以在编译时不确定类型，在运行时才确定。<br>③ 反射可以实现一些复杂的功能，例如动态代理、注解处理等。</p><p>反射的缺点：<br>① 反射效率较低，反射调用方法和访问属性的效率比直接调用要低。<br>② 反射容易导致代码不稳定，容易出现一些运行时异常，例如 ClassCastException 等。<br>③ 反射使用不当会导致安全问题，例如通过反射获取私有属性或方法，破坏了封装性和安全性。</p></li><li><p>实现 Java 反射的类有什么？<br>答：<br>实现 Java 反射的类有以下几个：<br>① Class 类：表示一个类或接口，在运行时可以通过它获取类的信息，如类名、父类、接口、构造方法、成员变量、方法等。<br>② Constructor 类：表示一个构造方法，在运行时可以通过它创建对象。<br>③ Method 类：表示一个方法，在运行时可以通过它调用方法。<br>④ Field 类：表示一个成员变量，在运行时可以通过它获取或设置成员变量的值。<br>⑤ Modifier 类：表示一个修饰符，在运行时可以通过它获取修饰符的信息，如 public、private、static 等。<br>⑥ Array 类：表示一个数组，在运行时可以通过它创建数组对象，并获取数组元素的值。</p></li><li><p>反射是怎么实现的？<br>答：<br>在 Java 中，反射是通过 Class 类来实现的。每个类在内存中都有一个 Class 对象，该对象包含了类的所有信息，包括类的名称、属性、方法等。</p><p>通过 Class 类的 newInstance()方法可以动态地创建一个类的实例。通过 Class 类的 getMethod()、getField()、getDeclaredMethod()、getDeclaredField()等方法可以获取类的方法和属性，从而动态地调用方法或修改属性的值。</p><p>反射的实现基于 Java 虚拟机的动态加载机制，可以在程序运行时动态地加载和使用类。这种机制使得 Java 程序可以在运行时根据需要加载和使用不同的类，从而实现更加灵活和动态的编程。</p></li><li><p>Class 类的作用？生成 Class 对象的方法有哪些？<br>答：<br>Class 类的作用是描述类的结构信息，包括类的属性、方法、构造器等。它是 Java 反射的核心类，通过 Class 类可以获取一个类的信息并操作它的属性和方法。</p><p>生成 Class 对象的方法主要有三种：<br>① 调用对象的 getClass()方法：可以通过一个已经存在的对象来获取它所属的类的 Class 对象。<br>② 使用类的.class 语法：在编译期间就可以确定一个类的 Class 对象，可以直接使用类名.class 来获取。<br>③ 使用 Class.forName()方法：可以通过类的全限定名来获取 Class 对象，这种方式可以在运行时动态加载类。</p></li><li><p>Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？<br>答：<br>Class.forName(“全路径”) 会调用类的静态初始化块（static{}）和静态变量的初始化，但不会调用构造方法。加载的类会放在 JVM 的方法区（Method Area）中。</p></li><li><p>类加载流程？<br>答：<br>类加载是 Java 虚拟机将类的.class 文件中的二进制数据读入内存中，使其成为方法区内的 Class 对象的过程。类加载的流程包括以下几个步骤：<br>① 加载：查找并加载类的二进制数据。在此阶段，Java 虚拟机需要完成以下任务：<br>a. 通过一个类的全限定名获取定义此类的二进制字节流。<br>b. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。<br>c. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。<br>② 链接：将类的二进制数据合并到 JVM 的运行状态之中。在此阶段，Java 虚拟机需要完成以下任务：<br>a. 验证：确保加载的类的正确性。<br>b. 准备：为类的静态变量分配内存，并设置默认初始值。<br>c. 解析：将类中的符号引用转换为直接引用。<br>③ 初始化：为类的静态变量赋予正确的初始值，并执行初始化代码块。在此阶段，Java 虚拟机需要完成以下任务：<br>a. 执行类构造器<clinit>()方法的过程。<br>b. 如果该类还有父类，JVM 会先初始化其父类。</clinit></p><p>以上是类加载的主要流程。需要注意的是，类的加载过程是按需的，即只有在使用时才会进行类的加载。此外，JVM 还提供了一些机制来控制类的加载行为，例如类加载器、双亲委派机制等。</p></li><li><p>说一下创建对象的几种方法？<br>答：<br>① 使用 new 关键字创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><p>② 使用 Class 类的 newInstance() 方法创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">"MyClass"</span>).newInstance();</span><br></pre></td></tr></table></figure><p>③ 使用 clone() 方法创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) oldObject.clone();</span><br></pre></td></tr></table></figure><p>④ 使用反序列化创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"object.ser"</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br></pre></td></tr></table></figure><p>⑤ 使用工厂方法创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> MyClassFactory.createMyClass();</span><br></pre></td></tr></table></figure><p>⑥ 使用构造方法引用创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure></li><li><p>如何找到对象实际类的？<br>答：<br>可以使用 getClass()方法来获取对象实际的类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line">Class&lt;?&gt; cls = obj.getClass();</span><br><span class="line">System.out.println(cls.getName());</span><br></pre></td></tr></table></figure><p>输出结果为：java.lang.String</p></li><li><p>Java 反射创建对象效率高还是通过 new 创建对象的效率高？<br>答：<br>在创建对象方面，通过 new 创建对象的效率要高于 Java 反射创建对象。</p><p>这是因为 Java 反射创建对象需要进行额外的操作，在运行时需要进行类的加载、方法的调用等操作，这些都会消耗一定的时间，因此相对于直接通过 new 创建对象，Java 反射创建对象的效率会稍微慢一些。</p><p>但是，Java 反射创建对象也具有其独特的优点，比如可以在运行时动态地创建对象、调用方法等，这对于某些特定的场景是非常有用的。因此，在具体实现中需要根据实际情况进行选择。</p></li><li><p>如何利用反射机制来访问一个类的方法？<br>答：<br>可以通过以下步骤来利用反射机制访问一个类的方法：<br>① 获取该类的 Class 对象，可以通过 Class.forName()方法或者类名.class 来获取。<br>② 获取指定方法的 Method 对象，可以通过 Class 对象的 getMethod()方法或者 getDeclaredMethod()方法来获取。<br>③ 调用 Method 对象的 invoke()方法来执行该方法，需要传入该方法所属的对象和方法参数。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 获取指定方法的Method对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">"methodName"</span>, <span class="type">int</span>.class, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建该方法所属的对象</span></span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, <span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出方法返回值</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">{</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>说一下 Java 反射获取私有属性，如何改变值？<br>答：<br>Java 反射可以通过 getDeclaredField()方法获取私有属性，并通过 setAccessible(true)方法设置访问权限，最终通过 set()方法修改值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">myPrivateField</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">        {</span><br><span class="line">            <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> MyClass.class.getDeclaredField(<span class="string">"myPrivateField"</span>);</span><br><span class="line">            privateField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">            privateField.set(obj, newValue);</span><br><span class="line"></span><br><span class="line">            System.out.println(obj.myPrivateField);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>上述代码中，我们使用反射获取了 MyClass 类中的私有属性 myPrivateField，并设置了访问权限。然后通过 set()方法将其值修改为 20，并打印出结果。</p><p>需要注意的是，在 JDK17 中，内部的私有结构已经不再支持反射调用。这是因为 Java 官方认为这种调用方式可能会导致安全问题。因此，我们需要在编写代码时避免使用这种方法。</p></li></ol><h1>第 18 章 JDK8 到 JDK17 新特性</h1><h2 id="18-1-JDK-新特性的概述">18.1 JDK 新特性的概述</h2><ul><li><p>几个重要的版本：</p><ul><li>jdk 5.0、jdk 8.0：里程碑式的版本。</li><li>jdk 9.0 开始每 6 个月发布一个新的版本。</li><li>LTS（长期支持版本）: jdk8、jdk 11、jdk 17。</li></ul></li><li><p>如何学习新特性？</p><ul><li>角度 1：新的语法规则<ul><li>自动装箱、自动拆箱、enum、泛型、Lambda 表达式、接口中的默认方法、静态方法、局部变量的类型推断、switch 表达式、文本块等。</li></ul></li><li>角度 2：增加、过时、删除 API - Stream、Optional、新的日期时间的 API、HashMap 的底层结构、String 的底层结构<br>等。</li><li>角度 3：底层的优化、内存结构（永久代——&gt;元空间）、新的 JS 执行引擎、新的垃圾回收器、GC 参数、JVM 的优化。</li></ul></li></ul><h2 id="18-2-JDK8-lambda-表达式">18.2 JDK8:lambda 表达式</h2><p>在给函数式接口提供实例时，都可以考虑使用 lambda 表达式。</p><p>基本语法的使用：</p><ul><li>Lambda 表达式：在 Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：<ul><li>左侧：指定了 Lambda 表达式需要的参数列表。</li><li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li></ul></li></ul><p>下面是一个使用 lambda 表达式的简单代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"Alice"</span>);</span><br><span class="line">        names.add(<span class="string">"Bob"</span>);</span><br><span class="line">        names.add(<span class="string">"Charlie"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式遍历List并打印每个元素</span></span><br><span class="line">        names.forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式对List进行排序</span></span><br><span class="line">        names.sort((name1, name2) -&gt; name1.compareTo(name2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式过滤List中长度大于4的元素</span></span><br><span class="line">        List&lt;String&gt; longNames = names.stream()</span><br><span class="line">                                      .filter(name -&gt; name.length() &gt; <span class="number">4</span>)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用了 lambda 表达式来遍历 List、对 List 进行排序以及过滤 List 中的元素。在遍历 List 时，我们使用了 forEach()方法，该方法接受一个 Consumer 接口作为参数，该接口中定义了一个 accept()方法，用于处理每个元素。在排序 List 时，我们使用了 sort()方法，该方法接受一个 Comparator 接口作为参数，该接口中定义了一个 compare()方法，用于比较两个元素的大小关系。在过滤 List 时，我们使用了 stream()方法和 filter()方法，这两个方法都接受一个 Predicate 接口作为参数，该接口中定义了一个 test()方法，用于判断元素是否符合条件。</p><h2 id="18-3-函数式接口">18.3 函数式接口</h2><p>只包含一个抽象方法（Single Abstract Method，简称 SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</p><p>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p><p>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p><p>在 java.util.function 包下定义了 Java 8 的丰富的函数式接口。</p><ul><li><p>常见的函数式接口。Comparator、Runnable、java.util.function 下定义的丰富的函数式接口。</p><ul><li>消费型接口：Consumer<t> void accept(T t)</t></li><li>供给型接口：Supplier<t> T get()</t></li><li>函数型接口：Function&lt;T,R&gt; R apply(T t)</li><li>判断型接口：Predicate<t> boolean test(T t)</t></li></ul></li><li><p>消费型接口示例：将字符串转为大写输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str.toUpperCase());</span><br><span class="line">consumer.accept(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure></li><li><p>供给型接口示例：生成一个随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> supplier.get();</span><br></pre></td></tr></table></figure></li><li><p>函数型接口示例：将字符串转为整型并乘以 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; function = str -&gt; Integer.parseInt(str) * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> function.apply(<span class="string">"10"</span>);</span><br></pre></td></tr></table></figure></li><li><p>判断型接口示例：判断字符串是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = str -&gt; str == <span class="literal">null</span> || str.isEmpty();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> predicate.test(<span class="string">""</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="18-4-方法引用、构造器引用、数组引用">18.4 方法引用、构造器引用、数组引用</h2><p>方法引用、构造器引用、数组引用：看做是 lambda 表达式的进一步凝练。</p><p>方法引用格式：</p><ul><li>格式：使用方法引用操作符 “::” 将类(或对象) 与 方法名分隔开来。</li><li>两个:中间不能有空格，而且必须英文状态下半角输入。</li></ul><p>如下三种主要使用情况：</p><ul><li>情况 1：对象 :: 实例方法名</li><li>情况 2：类 :: 静态方法名</li><li>情况 3：类 :: 实例方法名</li></ul><p>方法引用使用前提：</p><ul><li><p>要求 1：Lambda 体只有一句语句，并且是通过调用一个对象的类现有的方法来完成的。</p><ul><li>例如：System.out 对象，调用 println()方法来完成 Lambda 体<br>Math 类，调用 random()静态方法来完成 Lambda 体</li></ul></li><li><p>要求 2：</p><ul><li>针对情况 1：函数式接口中的抽象方法 a 在被重写时使用了某一个对象的方法 b。如果方法 a 的形参列表、返回值类型与方法 b 的形参列表、返回值类型都相同，则我们可以使用方法 b 实现对方法 a 的重写、替换。</li><li>针对情况 2：函数式接口中的抽象方法 a 在被重写时使用了某一个类的静态方法 b。如果方法 a 的形参列表、返回值类型与方法 b 的形参列表、返回值类型都相同，则我们可以使用方法 b 实现对方法 a 的重写、替换。</li><li>针对情况 3：函数式接口中的抽象方法 a 在被重写时使用了某一个对象的方法 b。如果方法 a 的返回值类型与方法 b 的返回值类型相同，同时方法 a 的形参列表中有 n 个参数，方法 b 的形参列表有 n-1 个参数，且方法 a 的第 1 个参数作为方法 b 的调用者，且方法 a 的后 n-1 参数与方法 b 的 n-1 参数匹配（类型相同或满足多态场景也可以）<br>例如：<br>t-&gt;System.out.println(t)<br>() -&gt; Math.random() 都是无参。</li></ul></li><li><p>方法引用代码示例：<br>① 静态方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>);</span><br><span class="line">        list.forEach(Main::print); <span class="comment">// 静态方法引用</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>② 实例方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>);</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        list.forEach(main::print); <span class="comment">// 实例方法引用</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>③ 对象方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>);</span><br><span class="line">        list.forEach(String::toUpperCase); <span class="comment">// 对象方法引用</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>构造器引用示例：<br>① 无参构造器引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        Supplier&lt;Person&gt; supplier = Person::<span class="keyword">new</span>; <span class="comment">// 无参构造器引用</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Create a person."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>② 有参构造器引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        BiFunction&lt;String, Integer, Person&gt; function = Person::<span class="keyword">new</span>; <span class="comment">// 有参构造器引用</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> function.apply(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"Create a person: "</span> + name + <span class="string">", "</span> + age);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>数组引用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        Function&lt;Integer, <span class="type">int</span>[]&gt; function = <span class="type">int</span>[]::<span class="keyword">new</span>; <span class="comment">// 数组引用</span></span><br><span class="line">        <span class="type">int</span>[] array = function.apply(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2 id="18-5-JDK8-Stream-API">18.5 JDK8:Stream API</h2><p>Java8 中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</p><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库最好的补充，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p><p>注意：<br>① Stream 自己不会存储元素。<br>② Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。<br>③ Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。<br>④ Stream 一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。</p><p>Stream 的操作三个步骤：</p><ul><li>创建 Stream 一个数据源（如：集合、数组），获取一个流。</li><li>中间操作 每次处理都会返回一个持有结果的新 Stream，即中间操作的方法返回值仍然是 Stream 类型的对象。因此中间操作可以是个操作链，可对数据源的数据进行 n 次处理，但是在终结操作前，并不会真正执行。</li><li>终止操作(终端操作) 终止操作的方法返回值类型就不再是 Stream 了，因此一旦执行终止操作，就结束整个 Stream 操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束 Stream。</li></ul><p>以下是一个简单的代码示例，展示了如何使用 Java 8 的 Stream API 从列表中过滤和映射数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">"John"</span>, <span class="string">"Sarah"</span>, <span class="string">"Mark"</span>, <span class="string">"Bob"</span>, <span class="string">"Mary"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream API过滤出名字长度大于等于4的人，并将结果收集到一个新列表中</span></span><br><span class="line">        List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                .filter(name -&gt; name.length() &gt;= <span class="number">4</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Filtered names: "</span> + filteredNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream API将名字转换为小写，并将结果收集到一个新列表中</span></span><br><span class="line">        List&lt;String&gt; lowerCaseNames = names.stream()</span><br><span class="line">                .map(String::toLowerCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Lower case names: "</span> + lowerCaseNames);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filtered names: [John, Sarah, Mark, Mary]</span><br><span class="line">Lower case names: [john, sarah, mark, bob, mary]</span><br></pre></td></tr></table></figure><p>代码解释：</p><p>① 首先，我们创建了一个字符串列表 names，其中包含了一些名字。<br>② 我们使用 stream()方法将列表转换为一个流。<br>③ 然后，我们使用 filter()方法过滤出名字长度大于等于 4 的人，并将结果收集到一个新列表中。<br>④ 接下来，我们使用 map()方法将所有名字转换为小写，并将结果收集到一个新列表中。<br>⑤ 最后，我们打印出过滤后的名字列表和所有名字的小写列表。</p><p>这个示例只是 Stream API 功能的冰山一角，Stream API 还有很多其他有用的方法，例如 distinct()、sorted()、limit()和 reduce()等等。</p><h2 id="18-6-JDK8-之后的新特性：语法层面">18.6 JDK8 之后的新特性：语法层面</h2><ul><li><p>jShell 工具：</p><ul><li>Java 终于拥有了像 Python 和 Scala 之类语言的 REPL 工具（交互式编程环境，read - evaluate - print - loop）：jShell。以交互式的方式对语句和表达式进行求值。即写即得、快速运行。</li><li>利用 jShell 在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句"废话"。</li></ul></li><li><p>try-catch 结构的变化：</p><ul><li><p>在 try 的后面可以增加一个()，在括号中可以声明流对象并初始化。try 中的代码执行完毕，会自动把流对象释放，就不用写 finally 了。</p></li><li><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try(资源对象的声明和初始化)</span><br><span class="line">{</span><br><span class="line">  业务逻辑代码,可能会产生异常</span><br><span class="line">}</span><br><span class="line">catch(异常类型 1 e)</span><br><span class="line">{</span><br><span class="line">  处理异常代码</span><br><span class="line">}</span><br><span class="line">catch(异常类型 2 e)</span><br><span class="line">{</span><br><span class="line">  处理异常代码</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p>局部变量的类型推断：var</p></li><li><p>instanceof 的模式匹配：</p><ul><li><p>instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少 Java 程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。</p></li><li><p>Java 14 之前旧写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)</span><br><span class="line">{</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;    <span class="comment">//需要强转</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>Java 14 新特性写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)</span><br><span class="line">{</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul></li><li><p>switch 的模式匹配：</p><ul><li><p>switch 语句是一种选择结构，通常用于根据一个表达式的值来决定程序的执行流程。在 Java 中，switch 语句可以使用模式匹配来匹配多个值。</p></li><li><p>下面是一个简单的代码示例，展示了如何使用 switch 语句的模式匹配功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// num为switch语句的表达式</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">"One"</span>); <span class="comment">// 如果num等于1，则执行此分支</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"Two"</span>); <span class="comment">// 如果num等于2，则执行此分支</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">"Three"</span>); <span class="comment">// 如果num等于3，则执行此分支</span></span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"Other"</span>); <span class="comment">// 如果num不匹配任何一个case分支，则执行此分支</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上面的代码中，我们使用了 Java 14 中的新特性-箭头表达式，可以更简洁的书写代码，效果与 Java 12 中的 switch 表达式相同。</p><p>在这个示例中，我们定义了一个整型变量 num，并使用 switch 语句对它进行匹配。在每个 case 分支中，我们使用箭头表达式输出不同的值。如果 num 的值不匹配任何一个 case 分支，程序将执行 default 分支。</p></li></ul></li><li><p>文本块：</p><ul><li><p>在 Java 13 及以上版本中，可以使用文本块来更方便地处理多行文本。文本块的格式为三个双引号（“”"）开始，三个双引号结束，中间可以插入多行文本。</p></li><li><p>下面是一个详细的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextBlockExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 定义一个文本块</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">textBlock</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">                Hello,</span></span><br><span class="line"><span class="string">                This is a text block.</span></span><br><span class="line"><span class="string">                It can span multiple lines.</span></span><br><span class="line"><span class="string">                """</span>;</span><br><span class="line">        <span class="comment">// 输出文本块</span></span><br><span class="line">        System.out.println(textBlock);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 可以在文本块中使用双引号和换行符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">textBlockWithQuoteAndNewLine</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">                "Hello," she said.</span></span><br><span class="line"><span class="string">                This is a text block.</span></span><br><span class="line"><span class="string">                It can span multiple lines.</span></span><br><span class="line"><span class="string">                """</span>;</span><br><span class="line">        <span class="comment">// 输出带有双引号和换行符的文本块</span></span><br><span class="line">        System.out.println(textBlockWithQuoteAndNewLine);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 可以在文本块中插入表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"Tom"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">textBlockWithExpression</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">                Hello, %s.</span></span><br><span class="line"><span class="string">                This is a text block.</span></span><br><span class="line"><span class="string">                It can span multiple lines.</span></span><br><span class="line"><span class="string">                """</span>.formatted(name);</span><br><span class="line">        <span class="comment">// 输出带有表达式的文本块</span></span><br><span class="line">        System.out.println(textBlockWithExpression);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">This is a text block.</span><br><span class="line">It can span multiple lines.</span><br><span class="line">  </span><br><span class="line">"Hello," she said.</span><br><span class="line">This is a text block.</span><br><span class="line">It can span multiple lines.</span><br><span class="line">  </span><br><span class="line">Hello, Tom.</span><br><span class="line">This is a text block.</span><br><span class="line">It can span multiple lines.</span><br></pre></td></tr></table></figure><p>在文本块中，可以使用反斜杠（\）来转义双引号、换行符等特殊字符。如果要在文本块中插入美元符号（$），需要使用两个美元符号来转义。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">textBlockWithEscape</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">        "Hello,\" she said."</span></span><br><span class="line"><span class="string">        This is a text block.</span></span><br><span class="line"><span class="string">        It can span multiple lines.</span></span><br><span class="line"><span class="string">        This is a variable: $$</span></span><br><span class="line"><span class="string">        """</span>;</span><br><span class="line">System.out.println(textBlockWithEscape);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"Hello," she said."</span><br><span class="line">This is a text block.</span><br><span class="line">It can span multiple lines.</span><br><span class="line">This is a variable: $</span><br></pre></td></tr></table></figure></li></ul></li><li><p>新的引用数据类型：record (记录)</p><ul><li><p>在 Java 16 中，引入了一种新的引用数据类型：record。record 是一种不可变的类，用于表示数据记录。它提供了一个简单的方法来定义一个类，该类包含一组属性和一些实用方法。</p></li><li><p>以下是一个简单的 record 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 构造器、获取方法和其他方法</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个 record 定义了一个名为 Person 的类，它有两个属性：name 和 age。它还提供了一个构造函数和两个访问器方法：getName()和 getAge()。这些方法都是自动生成的，因为 record 是不可变的，所以不需要 setter 方法。</p></li><li><p>以下是一个更详细的示例，它展示了如何使用 record 来定义一个学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, <span class="type">int</span> age, String major, <span class="type">double</span> gpa)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> Student</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || gpa &lt; <span class="number">0</span> || gpa &gt; <span class="number">4.0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Invalid age or GPA"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMajor</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGpa</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> gpa;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHonors</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> gpa &gt;= <span class="number">3.5</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" ("</span> + age + <span class="string">") - "</span> + major + <span class="string">", GPA: "</span> + gpa;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个 record 定义了一个名为 Student 的类，它有四个属性：name、age、major 和 gpa。它还提供了一个构造函数，该函数检查年龄和 GPA 是否有效。它还提供了访问器方法和其他方法，例如 isHonors()和 toString()。</p><p>使用 record 可以使代码更简洁，更易于阅读和维护。它还可以提高代码的性能，因为它是不可变的，所以可以避免同步问题。</p></li></ul></li><li><p>密封类：sealed class</p><ul><li><p>密封类（sealed class）是一种特殊的类，它可以被继承，但是只能在定义的文件中被继承，不能在其他文件中被继承。密封类常用于表示有限数量的类型，例如枚举类型。</p></li><li><p>下面是一个 Java 中密封类的详细代码示例和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个密封类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">permits</span> Dog, Cat, Bird</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 定义一个抽象方法makeSound，所有子类都必须实现该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个继承自Animal的子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 实现makeSound方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Woof!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个继承自Animal的子类Cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 实现makeSound方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Meow!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个继承自Animal的子类Bird</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 实现makeSound方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"Chirp!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个Dog对象并调用makeSound方法</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal1.makeSound();    <span class="comment">// 输出Woof!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Cat对象并调用makeSound方法</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal2.makeSound();    <span class="comment">// 输出Meow!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Bird对象并调用makeSound方法</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        animal3.makeSound();    <span class="comment">// 输出Chirp!</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个密封类 Animal，它有三个子类：Dog、Cat 和 Bird。每个子类都必须实现 Animal 类中定义的抽象方法 makeSound。在测试类中，我们创建了三个 Animal 对象，并分别调用它们的 makeSound 方法，输出了它们各自的声音。</p></li></ul></li></ul><h2 id="18-7-JDK8-之后的新特性：Optional-API">18.7. JDK8 之后的新特性：Optional API</h2><p>Optional 类是 Java 8 中引入的一个新特性，用于解决空指针异常的问题。Optional 类可以包含一个非空的对象，也可以表示一个空对象。它可以用于返回值、方法参数、变量等等，以避免空指针异常的发生。</p><p>下面是一个使用 Optional 类的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalExample</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 创建一个非空的Optional对象</span></span><br><span class="line">        Optional&lt;String&gt; nonEmptyOptional = Optional.of(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个空的Optional对象</span></span><br><span class="line">        Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断Optional对象是否为空</span></span><br><span class="line">        System.out.println(nonEmptyOptional.isPresent());    <span class="comment">// true</span></span><br><span class="line">        System.out.println(emptyOptional.isPresent());    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Optional对象中的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> nonEmptyOptional.get();</span><br><span class="line">        System.out.println(value);    <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果Optional对象为空，则返回指定的默认值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultValue</span> <span class="operator">=</span> emptyOptional.orElse(<span class="string">"Default Value"</span>);</span><br><span class="line">        System.out.println(defaultValue); <span class="comment">// Default Value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果Optional对象为空，则执行指定的操作</span></span><br><span class="line">        emptyOptional.ifPresent(s -&gt; System.out.println(<span class="string">"Optional is empty"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用map操作将Optional对象中的值转换成另一个值</span></span><br><span class="line">        Optional&lt;Integer&gt; integerOptional = nonEmptyOptional.map(String::length);</span><br><span class="line">        System.out.println(integerOptional.get()); <span class="comment">// 11</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，我们创建了一个非空的 Optional 对象和一个空的 Optional 对象。我们使用 isPresent 方法来判断 Optional 对象是否为空，使用 get 方法来获取 Optional 对象中的值。我们使用 orElse 方法来获取 Optional 对象中的值，如果 Optional 对象为空，则返回指定的默认值。我们使用 ifPresent 方法来执行操作，如果 Optional 对象为空，则不执行任何操作。我们使用 map 方法来将 Optional 对象中的值转换成另一个值。</p><h2 id="18-8-企业真题">18.8 企业真题</h2><ol><li><p>谈谈 java8 新特性？<br>答：<br>Java 8 引入了很多新特性，其中最重要的包括：<br>① Lambda 表达式：Lambda 表达式是一种简洁的语法，用于表示可传递的函数式接口。它可以使代码更加简洁、易读、易维护。<br>② 方法引用：方法引用是一种简洁的语法，用于表示已经存在的方法的引用。它可以使代码更加简洁、易读、易维护。<br>③ Stream API：Stream API 是一种新的 API，用于处理集合数据。它可以使代码更加简洁、易读、易维护。<br>④ 接口默认方法：接口默认方法是在接口中定义的具有默认实现的方法。它可以使接口更加灵活、易扩展。<br>⑤ 函数式接口：函数式接口是只有一个抽象方法的接口。它可以用于 Lambda 表达式和方法引用。<br>⑥ Optional 类：Optional 类是代表一个可能存在的值或不存在的值的容器类。它可以用于避免空指针异常。<br>⑦ Date/Time API：Date/Time API 是一个新的 API，用于处理日期和时间。它可以使日期和时间的处理更加简单、易读、易维护。<br>⑧ Nashorn JavaScript 引擎：Nashorn JavaScript 引擎是一种新的 JavaScript 引擎，用于在 Java 应用程序中执行 JavaScript 代码。它可以使 Java 应用程序更加灵活、易扩展。</p></li><li><p>JDK1.8 在数据结构上发生了哪些变化 ？<br>答：<br>JDK1.8 在数据结构上发生了以下变化：<br>① 元空间替代永久代：在 JDK1.8 中，永久代被元空间替代。元空间是一块本地内存区域，与堆内存分离，用于存储类的元数据信息。这样可以避免永久代的内存溢出问题，并且可以动态地调整元空间大小。<br>② HashMap 底层结构：在 JDK1.8 中，HashMap 的底层结构发生了变化。在之前的版本中，HashMap 使用数组+链表的方式实现，但是在 JDK1.8 中，当链表长度达到一定阈值（默认为 8）时，会将链表转化为红黑树，提高了查找效率。</p><p>除此之外，JDK1.8 还引入了一些新的数据结构，如 ConcurrentHashMap 的分段锁机制、Stream API 等，以提高程序的性能和可读性。</p></li><li><p>你说的了解 Java 的新特性 ，你说说 JDK8 改进的地方？<br>答：<br>JDK8 改进的地方包括：<br>① Lambda 表达式：Lambda 表达式是一种简洁的语法，可以实现函数式编程，提高了代码的可读性和简洁性。<br>② Stream API：Stream API 是一种处理集合数据的新方式，可以实现更加简洁高效的数据处理。<br>③ 接口的默认方法：接口的默认方法可以在不破坏原有实现的情况下，为接口添加新的方法。<br>④ 时间日期 API：新的时间日期 API 提供了更加丰富和易用的时间日期处理功能。<br>⑤ 方法引用：方法引用可以让代码更加简洁，提高可读性。<br>⑥ 并行流：并行流可以利用多核处理器的优势，提高集合数据的处理效率。<br>⑦ 重复注解：重复注解可以让同一个注解在同一个元素上出现多次，增加了灵活性。<br>⑧ Type Annotations：Type Annotations 可以在更加精细的层次上注解类型，提高了代码的可读性和可维护性。</p></li><li><p>JDK1.8 用的是哪个垃圾回收器？<br>答：<br>JDK1.8 默认使用的是 Parallel GC（并行垃圾回收器）。</p><p>随着计算机硬件的不断进步和应用场景的多样化，垃圾回收器也在不断地发展和优化。从 Parallel GC 到 G1GC 再到 ZGC，Java 垃圾回收器的发展方向大致可以归纳为以下几个方面：<br>① 并行化：Parallel GC 是一种以并行方式进行垃圾回收的垃圾回收器。它通过将内存分割成多个区域，然后在多个线程中同时进行垃圾回收，从而提高了回收效率。在多核 CPU 的环境下，Parallel GC 表现出色，可以有效地利用多核处理器的优势。<br>② 低延迟：G1GC（G1 垃圾回收器）是一种低延迟垃圾回收器。它采用了基于区域的内存管理方式，可以在不影响应用程序性能的情况下，实现更加精细的内存管理和垃圾回收。G1GC 还具备自适应的垃圾回收策略，可以根据应用程序的实际情况，自动调整垃圾回收的时间和频率。<br>③ 大内存支持：ZGC（Z 垃圾回收器）是一种专门针对大内存场景的垃圾回收器。它可以在数十 GB、甚至数百 GB 级别的堆内存上进行垃圾回收，而且不会出现明显的停顿。ZGC 采用了柔性化的垃圾回收策略，可以在不同的内存使用情况下，自动调整垃圾回收的时间和方式。</p><p>总的来说，Java 垃圾回收器的发展方向是趋向于并行化、低延迟和大内存支持。随着计算机硬件的不断升级，垃圾回收器的性能和功能也会不断提高，为 Java 应用程序提供更加优秀的性能和稳定性。</p></li><li><p>Lambda 表达式有了解吗，说说如何使用的？<br>答：<br>我了解 Lambda 表达式的概念和用法。Lambda 表达式是 Java 8 引入的一种新特性，用于简化函数式编程的语法。它可以将函数作为参数传递，也可以将函数作为返回值。</p><p>Lambda 表达式的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; { statements; }</span><br></pre></td></tr></table></figure><p>其中，parameters 是函数的参数列表，expression 是函数的返回值，statements 是函数体。Lambda 表达式可以用在函数式接口中，函数式接口是只有一个抽象方法的接口。Lambda 表达式可以使用 Java 中的函数式接口，例如 Java.util.function 包中的接口，如 Consumer、Function、Predicate 等。</p><p>举个例子，下面是一个使用 Lambda 表达式的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);</span><br><span class="line">names.forEach(name -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure><p>上述代码使用了 forEach 方法和 Lambda 表达式，遍历了一个字符串列表并打印了每个字符串的值。</p></li><li><p>什么是函数式接口？有几种函数式接口？<br>答：<br>函数式接口是只包含一个抽象方法的接口。在 Java 8 中引入了函数式接口的概念，以支持 Lambda 表达式和方法引用。函数式接口的一个重要特点是可以通过 Lambda 表达式或方法引用来创建其实例。</p><p>Java 8 中提供了一些常用的函数式接口，包括：<br>① Consumer<t>：消费型接口，接受一个参数，无返回值。<br>② Supplier<t>：供给型接口，不接受任何参数，返回一个值。<br>③ Function&lt;T, R&gt;：函数型接口，接受一个参数，返回一个值。<br>④ Predicate<t>：判断型接口，接受一个参数，返回一个布尔值。</t></t></t></p><p>除了这些常用的函数式接口之外，Java 8 还提供了一些其他的函数式接口，如 BiFunction、UnaryOperator、BinaryOperator 等。这些函数式接口可以帮助开发人员更方便地使用 Lambda 表达式和方法引用。</p></li><li><p>创建 Stream 的方式？<br>答：<br>Java 中创建 Stream 的方式有以下几种：<br>① 通过集合创建 Stream：可以使用 Collection 接口提供的 stream()方法或 parallelStream()方法来创建 Stream。<br>② 通过数组创建 Stream：可以使用 Arrays 类提供的 stream()方法来创建 Stream。<br>③ 通过 Stream.of()方法创建 Stream：可以使用 Stream.of()方法创建包含任意数量元素的 Stream。<br>④ 通过 Stream.iterate()方法创建 Stream：可以使用 Stream.iterate()方法创建一个包含无限元素的 Stream。<br>⑤ 通过 Stream.generate()方法创建 Stream：可以使用 Stream.generate()方法创建一个包含无限元素的 Stream。<br>⑥ 通过 BufferedReader.lines()方法创建 Stream：可以使用 BufferedReader.lines()方法创建一个包含文件中所有行的 Stream。</p><p>以上是创建 Stream 的几种方式，可以根据具体的需求选择最合适的方式。</p></li><li><p>你讲讲 stream 表达式是咋用的，干啥的？<br>答：<br>Stream 表达式是 Java 8 中引入的一种新特性，它提供了一种流式处理数据的方式，可以用来操作集合、数组等数据结构。通过 Stream，我们可以使用类似于 SQL 的语法来对数据进行过滤、排序、映射等操作，大大简化了代码的编写和维护。</p><p>具体来说，Stream 表达式可以通过以下步骤来使用：<br>① 获取一个数据源，比如一个集合。<br>② 对数据源进行过滤、排序、映射等操作，生成一个新的 Stream。<br>③ 对新生成的 Stream 进行聚合操作，如求和、取最大值等。<br>④ 最终生成一个结果。</p><p>Stream 表达式的好处在于它可以大大简化代码的编写和维护，同时也可以提高代码的可读性和可维护性。例如，使用 Stream 表达式可以将一些复杂的操作链式化，从而减少了代码的嵌套层次，使得代码更加简洁易懂。</p><p>总之，Stream 表达式是一种强大的工具，可以帮助 Java 后端开发工程师更加高效地处理数据。</p></li><li><p>集合用 Stream 流怎么实现过滤？<br>答：<br>可以使用 Stream 的 filter() 方法来实现集合的过滤。例如，假设有一个 List<string> 类型的集合，我们可以通过以下代码实现对集合中所有长度大于等于 5 的元素进行过滤：</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"pear"</span>, <span class="string">"grape"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; filteredList = list.stream()</span><br><span class="line">                                .filter(s -&gt; s.length() &gt;= <span class="number">5</span>)</span><br><span class="line">                                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先将 List 转换为 Stream，然后使用 filter() 方法对元素进行过滤，最后使用 collect() 方法将过滤后的元素收集到一个新的 List 中。</p></li><li><p>用 Stream 怎么选出 List 里想要的数据？<br>答：<br>使用 Stream 可以通过 filter 方法来筛选出 List 中想要的数据，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; filteredNumbers = numbers.stream()</span><br><span class="line">.filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">System.out.println(filteredNumbers); <span class="comment">// 输出 [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们先定义了一个包含数字的 List，然后使用 stream()方法将其转换为一个 Stream 对象。接着使用 filter()方法对 Stream 中的元素进行筛选，筛选条件为 n % 2 == 0，即只选择偶数。最后使用 collect()方法将筛选出来的元素收集到一个新的 List 中。</p></li><li><p>说说 JDK15、JDK16、JDK17 中的新特性都有什么？<br>答：<br>以下是 JDK 15、JDK 16 和 JDK 17 中的一些主要新特性。请注意，这不是一个详尽无遗的列表，而仅仅是重要特性的概述。</p><ul><li><p>JDK 15（2020 年 9 月发布）<br>① JEP 339: Edwards-Curve 数字签名算法 (EdDSA)：提供了一个新的签名方案，支持高性能且更安全的加密。<br>② JEP 360: 封装类（Sealed Classes，预览）：允许开发者限制某个类或接口的扩展，从而可以更清晰地表示其设计意图。<br>③ JEP 371: 隐藏类（Hidden Classes）：允许在运行时生成类，并确保它们不会与其他类相互干扰，有助于框架的设计与实现。<br>④ JEP 372: 移除 Applet API：由于 Java Web Start 和相关浏览器插件已被废弃，因此移除了 Applet API。<br>⑤ JEP 378: 文本块（第二次预览）：简化多行字符串字面量的编写，使代码更易读。</p></li><li><p>JDK 16（2021 年 3 月发布）<br>① JEP 338: 向量 API (Incubator)：引入了一个新的向量 API，以提高硬件加速计算的性能。<br>② JEP 389: 外部内存访问 API (Incubator)：提供了一种新的 API，用于访问不受 JVM 直接管理的内存，以提高性能和简化原生内存访问。<br>③ JEP 390: 警告使用不稳定的值类型：警告开发者使用值类型时可能遇到的潜在问题。<br>④ JEP 392: 将 JEP 389 的外部内存访问 API 引入 JDK 16，并将其作为一个孵化器模块发布。<br>⑤ JEP 393: 覆盖记录类的默认方法：允许在记录类中覆盖 equals()、hashCode() 和 toString() 等默认方法。<br>⑥ JEP 394: 模式匹配实例（第二次预览）：引入了模式匹配和 instanceof 运算符的结合，简化了类型检查和类型转换的代码。</p></li><li><p>JDK 17（2021 年 9 月发布）<br>① JEP 356: 增强伪随机数生成器（PRNG）API：改进了伪随机数生成器，包括性能提升和更简洁的 API。<br>② JEP 382: 新 macOS 渲染管道：为 macOS 提供了一个新的 Metal 渲染管道，以替代已废弃的 Quartz 渲染管道。<br>③ JEP 389: 外部内存访问 API（第二次孵化）：对在 JDK 16 中引入的外部内存访问 API 进行了改进。<br>④ JEP 411: 废弃实验性的 AOT 和 JIT 编译器：废弃了实验性的 ahead-of-time 编译器和 just-in-time 编译器。<br>⑤ JEP 391: macOS/AArch64 端口：为 macOS 上的 ARM64 架构提供了一个原生端口。<br>⑥ JEP 390: 警告使用不稳定的值类型：警告开发者使用值类型时可能遇到的潜在问题。<br>⑦ JEP 395: 封装类和接口（正式版）：正式引入了 JDK 15 预览版中的封装类和接口特性。<br>⑧ JEP 398: 移除 Applet API：正式从 JDK 中移除已废弃的 Applet API。</p></li></ul><p>这些新特性在不同程度上改进了 Java 的性能、安全性、易用性和功能。请务必查阅 JDK 发行说明以获取更详细的信息和其他较小的改进。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Java 基础 第 1 阶段：基本语法——尚硅谷学习笔记（含面试题） 2023 年&lt;/h1&gt;
&lt;h1&gt;第 1 章 Java 语言概述&lt;/h1&gt;</summary>
    
    
    
    <category term="java" scheme="http://lyay23.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://lyay23.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>考研408大纲</title>
    <link href="http://lyay23.github.io/posts/66e64d45/"/>
    <id>http://lyay23.github.io/posts/66e64d45/</id>
    <published>2024-11-04T13:34:21.000Z</published>
    <updated>2024-11-04T10:00:31.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2025年计算机学科专业基础考试大纲">2025年计算机学科专业基础考试大纲</h2><span id="more"></span><h3 id="一、-数据结构">一、 数据结构</h3><h4 id="【考查目标】">【考查目标】</h4><p>1掌握数据结构的基本概念 基本原理和基本方法。</p><p>2掌握数据的逻辑结构 存储结构及基本操作的实现 能够对算法进行基本的时间复杂度与空间复杂度的分析。</p><p>3．能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用C 或C＋＋语言设计</p><p>与实现算法的能力。</p><h3 id="一、基本概念量（2025新增）">一、基本概念量（2025新增）</h3><p>（一）数据结构的基本概念</p><p>（二）算法的基本概念</p><h3 id="二、线性表">二、线性表</h3><p>（一）线性表的基本概念</p><p>（二）线性表的实现</p><p>1．顺序存储</p><p>2链式存储</p><h4 id="（三）线性表的应用">（三）线性表的应用</h4><h3 id="三、栈、队列和数组">三、栈、队列和数组</h3><p>（一）栈和队列的基本概念</p><p>（二）栈和队列的顺序存储结构</p><p>（三）栈和队列的链式存储结构</p><p>（四）多维数组的存储</p><p>（五）特殊矩阵的压缩存储</p><p>（六）栈、队列和数组的应用</p><h3 id="四、树与二叉树">四、树与二叉树</h3><p>（一）树的基本概念</p><p>（二）二叉树</p><p>1．二叉树的定义及其主要特征</p><p>2．二叉树的顺序存储结构和链式存储结构</p><p>3．二叉树的遍历</p><p>4．线索二叉树的基本概念和构造</p><h4 id="（三）树、森林">（三）树、森林</h4><p>1树的存储结构</p><p>2森林与二叉树的转换</p><p>3树和森林的遍历</p><h4 id="（四）树与二叉树的应用">（四）树与二叉树的应用</h4><p>1．哈夫曼（Huffman）树和哈夫曼编码</p><p>2．并查集及其应用</p><p>3．堆及其应用（25新增）</p><h3 id="四、图">四、图</h3><p>（一）图的基本概念</p><p>（二）图的存储及基本操作</p><p>1邻 接矩阵</p><p>2邻 接表</p><p>3．邻接多重表 十字链表</p><h4 id="（三）图的遍历">（三）图的遍历</h4><p>1．深度优先搜索</p><p>2．广度优先搜索</p><h4 id="（四）图的基本应用">（四）图的基本应用</h4><p>1最小（代价）生成树</p><p>2最短路径</p><p>3拓 扑排序</p><p>4．关键路径</p><h3 id="五、查找">五、查找</h3><p>（一）查找的基本概念</p><p>（二）顺序查找法</p><p>（三）分块查找法</p><p>（四）折半查找法</p><p>（五）树型查找</p><p>1．二叉树搜索树</p><p>2．平衡二叉树</p><p>3．红黑树</p><p>（六）B树及其基本操作、B＋树的基本概念</p><p>（七）散列（Hash）表</p><p>（八）字符串模式匹配</p><p>（九）查找算法的分析及应用</p><h3 id="六、排序">六、排序</h3><p>（一）排序的基本概念</p><p>（二）直接插入排序</p><p>（三）折半插入排序</p><p>（四）起泡排序（bu b b le sort）</p><p>（五）简单选择排序</p><p>（六）希尔排序（sh e ll sort）</p><p>（七）快速排序</p><p>（八）堆排序</p><p>（九）二路归并排序｛m er g e sort）</p><p>（十）基数排序</p><p>（十一）外部排序</p><h4 id="（十二）排序算法的分析和应用">（十二）排序算法的分析和应用</h4><h3 id="二、计算机组成原理">二、计算机组成原理</h3><h4 id="【考查目标】-2">【考查目标】</h4><p>1．理解单处理器计算机系统中主要部件的工作原理、组成结构以及相互连接方式。</p><p>2掌握指令集休系结构的基本知识和基本实现方法，对计算机硬件相关问题进行分析，并能够对相关部件进行设计。</p><p>3．理解计算机系统的整机概念，能够综合运用计算机组成的基本原理和基本方法，对高级编程语言（C语言）程序中的相关问题进行分析，具备软硬件协同分析和设计能力。</p><h3 id="一、计算机系统概述">一、计算机系统概述</h3><h4 id="（一）计算机系统层次结构">（一）计算机系统层次结构</h4><p>1．计算机系统的基本组成</p><p>2．计算机硬件的基本组成</p><p>3．计算机软件和硬件的关系</p><p>4．计算机系统的工作原理</p><p>“存储程序”工作方式，高级语言程序与机器语言程序之间的转换，程序和指令的执行过程。</p><h4 id="（二）计算机性能指标">（二）计算机性能指标</h4><p>吞吐最、响应时间；CPU 时钟周期、主频、CP，I GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。CPU执行时间；MIPS， MFLOPS</p><h3 id="二、数据的表示和运算">二、数据的表示和运算</h3><h4 id="（一）数制与编码">（一）数制与编码</h4><p>进位计数制及其数据之间的相互转换</p><h5 id="2．定点数的编码表示">2．定点数的编码表示</h5><h4 id="（二）运算方法和运算电路">（二）运算方法和运算电路</h4><h5 id="1-基本运算部件">1 基本运算部件</h5><p>加法器，算术逻辑部件（ALU）</p><p>加／减运算</p><p>补码加／减运算器，标志位的生成。</p><p>3乘／除运算</p><p>乘／除法运算的基本原理，乘法电路和除法电路的基本结构。</p><h4 id="（三）整数的表示和运算">（三）整数的表示和运算</h4><p>1无符号整数的表示和运算</p><p>2．带符号整数的表示和运算</p><h4 id="（四）浮点数的表示和运算">（四）浮点数的表示和运算</h4><h5 id="1．浮点数的表示">1．浮点数的表示</h5><p>IEEE 754 标准</p><h5 id="2．浮点数的加／减运算">2．浮点数的加／减运算</h5><h3 id="三、存储器层次结构">三、存储器层次结构</h3><p>（一）存储器的分类</p><p>（二）层次化存储器的基本结构</p><p>（三）半导体随机存取存储器</p><p>.SRA M 存储器</p><p>DRAM 存储器</p><p>Flash 存储器</p><h4 id="（四）主存储器">（四）主存储器</h4><p>1．DRAM 芯片和内存条</p><p>2多模块存储器</p><p>3．主存和CPU之间的连接</p><h4 id="（五）外部存储器">（五）外部存储器</h4><p>1．磁盘存储器</p><p>2．固态硬盘（SSD）</p><h4 id="（六）高速缓冲存储器（Cache）1．Cache…的基本原理2．Cach和主存之间的映射方式">（六）高速缓冲存储器（Cache）1．Cache…的基本原理2．Cach和主存之间的映射方式</h4><p>Cache 中主存块的替换算法</p><p>Cache 写策略</p><h4 id="（七）虚拟存储器">（七）虚拟存储器</h4><p>1虚拟存储器的基本概念</p><p>2．页式虚拟存储器</p><p>拈本原理，页表，地址转换，TLB（块表）</p><p>3．段式虚拟存储器</p><p>4．段页式虚拟存储器</p><h3 id="四、指令系统">四、指令系统</h3><p>（一）指令系统的基本概念</p><p>（二）指令格式</p><p>（三）寻址方式</p><p>（四）数据的对齐和大／小端存放方式</p><p>（五）CISC和RISC的基本概念</p><p>（六）高级语言程序与机器级代码之间的对应</p><p>编译器，汇编器和链路器的基本概念</p><p>2．选择结构语旬的机器级表示</p><p>3．循环结构语旬的机器级表示4．过程（函数）调用对应的机器级表示</p><h3 id="五、中央处理器（CPU）">五、中央处理器（CPU）</h3><p>（一）CPU的功能和基本结构</p><p>（二）指令执行过程</p><p>（三）数据通路的功能和基本结构</p><p>（四）控制器的功能和工作原理</p><p>（五）异常和中断机制</p><p>1异常和中断的基本概念</p><p>2异常和中断的分类</p><p>3异常和中断的检测与响应</p><h4 id="（六）指令流水线">（六）指令流水线</h4><p>1指令流水线的基本概念</p><p>指令流水线的基本实现</p><p>3．结构冒险、数据冒险和控制冒险的处理</p><p>4超 标量和动态流水线的基本概念</p><h4 id="（七）多处理器基本概念">（七）多处理器基本概念</h4><p>1．SISD SIMD MIM D、向械处理器的基本概念</p><p>2硬件多线程的基本概念 3多核处理器（multi-core）的灿本概</p><p>念4．共享内存多处理器（SMP）的基本</p><h3 id="六、总线和输入／输出系统">六、总线和输入／输出系统</h3><h4 id="（一）总线">（一）总线</h4><p>1．总线的晶本概念</p><p>2．总线的组成及性能指标</p><p>3．总线事务和定时</p><h4 id="（二）1／0接口（1／0-控制器）">（二）1／0接口（1／0 控制器）</h4><p>1.1／0 接口的功能和基本结构</p><p>2.1／0 端口及其编址</p><h4 id="（三）1／0方式">（三）1／0方式</h4><p>1程序查询方式</p><p>2程 序中断方式</p><p>中断的基本概念；中断响应过程；中断处理过程；多重中断和中断屏蔽的概念。</p><h4 id="3．DMA-方式">3．DMA 方式</h4><p>DMA 控制器的组成，DMA 传送过程</p><h3 id="三、-操作系统">三、 操作系统</h3><h4 id="【考查目标】-3">【考查目标】</h4><ol><li>掌握操作系统的基本概念方法和原理了解操作系统的结构、功能和服务，理解操作系统所采用的的策略、算法和机制。</li></ol><p>2．能够从计算机系统的角度理解并描述应用程序、操作系统内核和计算机硬件协作完成任务</p><p>的过程</p><p>3．能够运用操作系统原理分析并解决计算机系统中与操作系统相关的问题。</p><h3 id="一、操作系统概述">一、操作系统概述</h3><p>（一）操作系统的基本概念</p><p>（二）操作系统的发展历程</p><p>（三）程序运行环境</p><p>1．CPU 运行模式</p><p>内核模式、用户模式</p><p>2．中断和异常的处理</p><p>3系统调用</p><p>4程序的链接与装入</p><p>5程 序运行时内存映像与地址空间</p><h4 id="（四）操作系统结构">（四）操作系统结构</h4><p>分层，模块化，宏内核，微内核，外核</p><p>（五）操作系统引导</p><p>（六）虚拟机</p><h3 id="二、进程管理">二、进程管理</h3><h4 id="（一）进程与线程">（一）进程与线程</h4><p>1．进程与线程的基本概念</p><p>2．进程／线程的状态与转换</p><p>3．线程的实现</p><p>内核支持的线程，线程库支持的线程</p><p>4．进程与线程的组织与控制</p><p>5．进程间通信</p><p>共享内存，消息传递，管道，信号（2025新增）</p><h4 id="（二）CPU调度与上下文切换">（二）CPU调度与上下文切换</h4><p>1．调度的基本概念</p><p>2．调度的目标</p><p>3．调度的实现</p><p>调度器／调度程序（scheduler），调度的时机与调度方式（抢占式／非抢占式），闲逛进程，内核级线程与用户级线程调度</p><p>4．CPU调度算法（2025新增）</p><p>5．多处理机调度（2025新增）</p><p>6．上下文及其切换机制</p><h4 id="（三）同步与互斥">（三）同步与互斥</h4><p>1．同步于互斥的基本概念</p><p>2基本的实现方法 软件方法；硬件方法。</p><p>3锁</p><p>4．信号鼠</p><p>5条件变昌</p><p>6．经典同步问题</p><p>生产者-消费者问题；读者-写者问题；哲学家进餐问题。</p><h4 id="（四）死锁">（四）死锁</h4><p>1．死锁的基本概念</p><p>2．死锁预防</p><p>3．死锁避免</p><p>4死锁检测和解除</p><h3 id="三、内存管理">三、内存管理</h3><h4 id="（一）内存管理基础">（一）内存管理基础</h4><p>内存管理的基本概念</p><p>逻辑地址空间与物理地址空间，地址变换，内存共享，内存保护，内存分配与回收</p><p>2连续分配管理方式</p><p>3．页式管理4．段式管理</p><p>5．段页式管理</p><h4 id="（二）虚拟内存管理">（二）虚拟内存管理</h4><p>1虚拟内存基本概念</p><p>2．请求页式管理</p><p>3．页框分配与回收（2025新增）</p><p>4．页置换算法</p><p>5．内存映射文件（Memory-Mapped Files）</p><p>6．虚拟存储器性能的影响因素及改进方式</p><h3 id="四、文件管理">四、文件管理</h3><h4 id="（一）文件">（一）文件</h4><p>1．文件的基本概念</p><p>2．文件元数据和索引节点（in o de）</p><p>3．文件的操作</p><p>建立，删除，打开，关闭，读写</p><p>4．文件的保护</p><p>5．文件的逻捐结构</p><p>6．文件的物理结构</p><h4 id="（二）目录">（二）目录</h4><p>1．目录的基本概念</p><p>2．树形目录</p><p>3．目录的操作</p><p>4硬 链接和软链接</p><h4 id="（三）文件系">（三）文件系</h4><p>1．文件系统的全局结构（layout）</p><p>文件系统在外存中的结构，文件系统在内存中的结构</p><p>2．外存空闲空间管理办法</p><p>3虚拟文件系统</p><p>4．文件系统挂载（mounting）</p><h3 id="五、输入输出（1／0）管理">五、输入输出（1／0）管理</h3><h4 id="（一）1／0管理基础">（一）1／0管理基础</h4><h5 id="1．设备">1．设备</h5><p>设备的基本概念，设备的分类，1／0接口，1／0端口</p><h6 id="2-1／0-控制方式">2.1／0 控制方式</h6><p>轮询方式，中断方式，OMA方式</p><h5 id="3-1／0-软件层次结构">3.1／0 软件层次结构</h5><p>中断处理程序，驱动程序，设备独立软件，用户层1／0软件</p><h5 id="4．输入／输出应用程序接口">4．输入／输出应用程序接口</h5><p>字符设备接口，块设备接口，网络设备接口，阻塞／非阻塞1／0</p><h4 id="（二）设备独立软件">（二）设备独立软件</h4><p>1．缓冲区管理</p><p>2．设备分配与回收</p><p>3．假脱机技术（SPOOLing）</p><p>4．设备驱动程序接口</p><h4 id="（三）外存管理">（三）外存管理</h4><h5 id="1．磁盘">1．磁盘</h5><p>磁盘结构，格式化，分区，磁盘调度方法</p><h5 id="2．固态硬盘">2．固态硬盘</h5><p>读写性能特性，磨损均衡</p><h3 id="四计算机网络">四计算机网络</h3><h3 id="【考查目标】-4">【考查目标】</h3><p>1掌握计算机网络的基本概念、基本原理和基本方法。</p><p>2掌握典型计算机网络的结构 协议、应用以及典型网络设备的工作原理</p><p>3．能够运用计算机网络的基本概念、基本原理和基本方法进行网络系统的分析、设计和应用。一、计算机网络概述</p><h3 id="（一）计算机网络基本概念">（一）计算机网络基本概念</h3><p>1．计算机网络的定义、组成勹功能</p><p>2．计算机网络的分类</p><p>3．计算机网络主要性能指标</p><h3 id="（二）计算机网络体系结构">（二）计算机网络体系结构</h3><p>1．计算机网络分层结构</p><p>2．计算机网络协议、接口、服务等概念</p><p>3.1S0 ／0 SI参考模型和 TCP／IP 模型</p><h3 id="二、物理层">二、物理层</h3><h4 id="（一）通信基础">（一）通信基础</h4><p>1．信道信号、带宽码元、波特、速率、信源与信宿等基本概念</p><p>2．奈奎斯特定理与香农定理</p><p>3．编码与凋制4．电路交换报文交换与分组交换</p><p>5数据报与虚电路</p><h4 id="（二）传输介质">（二）传输介质</h4><p>1．双绞线同轴电缆光纤与无线传输介质</p><p>2．物理层接口的特性</p><h4 id="（三）物理层设备">（三）物理层设备</h4><p>1．中继器</p><p>2集线器</p><h3 id="三、数据链路层">三、数据链路层</h3><p>（一）数据链路层的功能</p><p>（二）组帧</p><p>（三）差错控制</p><p>1捡错编码</p><p>2．纠错编码</p><h4 id="（四）流量控制与可靠传输机制">（四）流量控制与可靠传输机制</h4><p>1．流晕控制可靠传输与滑动窗口机制</p><p>2．停止-等待协议</p><p>3．后退N 帧协议（GBN）</p><p>4．选择重传协议（SR）</p><h4 id="（五）介质访问控制">（五）介质访问控制</h4><h5 id="1．信道划分">1．信道划分</h5><p>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和拈本原理。</p><h5 id="2．随即访问">2．随即访问</h5><p>ALOHA 协议； CSMA 协议；C SM NCD协议；C SM N CA协议。</p><h5 id="3．轮询访问">3．轮询访问</h5><p>令牌传递协议</p><h4 id="（六）局域网">（六）局域网</h4><p>1．局域网的基本概念与体系结构</p><p>2．以太网与IEEE 802.3</p><p>IEEE802.11 尤线局域网</p><p>VLAN 拈本概念与基本原理</p><h4 id="（七）广域网">（七）广域网</h4><p>广域网的基本概念</p><p>PPP 协议</p><h4 id="（八）数据链路层设备">（八）数据链路层设备</h4><p>以太网交换机及其工作原理</p><h3 id="四、网络层">四、网络层</h3><h4 id="（一）网络层的功能">（一）网络层的功能</h4><p>1 异构网络互联</p><p>2路由勹转发</p><p>SDN 基本概念</p><p>4拥塞控制</p><h4 id="（二）路由算法">（二）路由算法</h4><p>1．静态路由与动态路由</p><p>2．距离-向量路由算法</p><p>链路状态路由算法</p><h5 id="4．层次路山">4．层次路山</h5><h4 id="（三）1Pv4-1-1Pv4-分组">（三）1Pv4 1.1Pv4 分组</h4><p>2.1Pv4 地址与 NAT</p><h4 id="3．子网划分、路由聚集、子网掩码与CIDR">3．子网划分、路由聚集、子网掩码与CIDR</h4><p>ARP协议 DHCP 协议与ICMP协议</p><h3 id="（四）1Pv6">（四）1Pv6</h3><h3 id="1-1Pv6-的主要特点">1.1Pv6 的主要特点</h3><p>2.1Pv6 地址</p><h3 id="（五）路由协议">（五）路由协议</h3><p>1．自治系统</p><p>2．域内路由与域间路由</p><p>3．RIP路由协议</p><p>4.0 SPF 路由协议</p><p>5．BGP 路由协议</p><h3 id="（六）IP组播">（六）IP组播</h3><p>1．组播的概念</p><p>2．IP 组播地址</p><h3 id="（七）移动-IP">（七）移动 IP</h3><p>1移动IP的概念</p><p>2移动IP 通信过程</p><h3 id="（八）网络层设备">（八）网络层设备</h3><p>1路 由器的组成和功能</p><p>2路由表与分组转发</p><h3 id="五、传输层">五、传输层</h3><h4 id="（一）传输层提供的服务">（一）传输层提供的服务</h4><p>1．传输层的功能2．传输层寻址与端门 3无 连接服务与面向连接服务</p><h4 id="（二）UDP协议">（二）UDP协议</h4><p>UDP 数据报</p><p>UDP 校验</p><h4 id="（三）TCP-协议">（三）TCP 协议</h4><p>1．TCP 段</p><p>TCP连接管理</p><p>TCP可靠传输</p><p>TCP流鼠控制</p><p>TCP拥塞控制</p><h3 id="六、应用层">六、应用层</h3><h4 id="（一）网络应用模型">（一）网络应用模型</h4><p>1．客户／服务器（C／S）模型</p><p>2．对等（P2P）模型</p><h4 id="（二）DNS系统">（二）DNS系统</h4><p>1．层次域名空间</p><p>2．域名服务器</p><p>3．域名解析过程</p><h4 id="（三）FTP">（三）FTP</h4><p>1．FTP协议的工作原理</p><p>2控制连接与数据连接</p><h4 id="（四）电子邮件">（四）电子邮件</h4><p>1．电子邮件系统的组成结构2．电子邮件格式与MIM E 3．SMTP 协议与POP3 协议</p><h4 id="（五）WWW">（五）WWW</h4><p>.WWW的概念与组成结构</p><p>HTTP 协议</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2025年计算机学科专业基础考试大纲&quot;&gt;2025年计算机学科专业基础考试大纲&lt;/h2&gt;</summary>
    
    
    
    <category term="408" scheme="http://lyay23.github.io/categories/408/"/>
    
    
    <category term="408" scheme="http://lyay23.github.io/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>力扣</title>
    <link href="http://lyay23.github.io/posts/6ead9846/"/>
    <id>http://lyay23.github.io/posts/6ead9846/</id>
    <published>2024-10-21T13:34:21.000Z</published>
    <updated>2024-11-05T13:37:24.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣之初体验">力扣之初体验</h2><span id="more"></span><h5 id="1-两数之和">1.两数之和</h5><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1] </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h6 id="题解">题解</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> {</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) {</span><br><span class="line">                <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">                arr[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 考虑不存在的情况，但本题中不会出现</span></span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>时间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><p>这里为暴力循环，第一层先遍历i，然后遍历j当找到相同时创建一个新数组</p><h5 id="2-两数相加">2.两数相加</h5><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h6 id="题解-2">题解</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newNode</span> =</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> =</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">while</span>(l1 || l2)</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int</span> a= l1 ? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> b= l2 ? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">      sum =a+b+carry;</span><br><span class="line">      <span class="keyword">if</span>(!head)</span><br><span class="line">      {</span><br><span class="line">        head =newNode =(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode -&gt;val=sum%<span class="number">10</span>;</span><br><span class="line">        newNode -&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">      }<span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        newNode -&gt;next=(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        newNode-&gt;next-&gt;val=sum%<span class="number">10</span>;</span><br><span class="line">        newNode=newNode-&gt;next;</span><br><span class="line">        newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">      }</span><br><span class="line">      carry=sum/<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(l1)</span><br><span class="line">      {</span><br><span class="line">        l1=l1-&gt;next;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span>(l2)</span><br><span class="line">      {</span><br><span class="line">        l2=l2-&gt;next;</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">    <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)</span><br><span class="line">     {</span><br><span class="line">      newNode-&gt;next =(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">      newNode-&gt;next-&gt;val=carry;</span><br><span class="line">      newNode= newNode-&gt;next;</span><br><span class="line">      newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="3-无重复字符的最长子串">3.无重复字符的最长子串</h5><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "abcabcbb"</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "bbbbb"</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "pwwkew"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h6 id="题解-滑动窗口解决">题解-滑动窗口解决</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> {</span><br><span class="line">    <span class="type">int</span> i,len=<span class="number">0</span>,max=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index[<span class="number">255</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">if</span>(index[s[i]]&gt;start)<span class="comment">//如果不是第一次出现</span></span><br><span class="line">       {</span><br><span class="line">        len=i-start;</span><br><span class="line">        start=index[s[i]];</span><br><span class="line">        <span class="keyword">if</span>(len&gt;max)</span><br><span class="line">        {</span><br><span class="line">            max=len;</span><br><span class="line">        }</span><br><span class="line">       }</span><br><span class="line">       index[s[i]]=i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len-start&gt;max){</span><br><span class="line">        <span class="keyword">return</span> len-start;</span><br><span class="line">    }<span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>个人理解：</p><ol><li>首先定义了一个空数组，255个字节代表255的char类型</li><li>进入for循环，这里我们以pwwkew为例</li><li>首先index[s[i]]代表index的第多少元素位置，例如p的阿史克马的位置</li><li>p第一次出现，p的位置为0，不大于0，不会进入循环，然后将index[s[0]]的位置改为p的实际位置 1</li><li>同理，w位置为2，此时i为1</li><li>w，进入循环，Len =2-0=2；start=2(因为此时未执行到index[s[i]]=i+1;所以start还是上一次的值），max=2;</li><li>…</li><li>w时，Len=5-3=3；start=2,max=3</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;力扣之初体验&quot;&gt;力扣之初体验&lt;/h2&gt;</summary>
    
    
    
    <category term="力扣" scheme="http://lyay23.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="力扣刷题" scheme="http://lyay23.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础</title>
    <link href="http://lyay23.github.io/posts/9ec06885/"/>
    <id>http://lyay23.github.io/posts/9ec06885/</id>
    <published>2024-10-10T07:34:21.000Z</published>
    <updated>2024-11-02T09:48:27.047Z</updated>
    
    <content type="html"><![CDATA[<h1>C语言基础</h1><p>c语言是<strong>结构化</strong>的程序设计----顺序结构，选择结构，循环结构</p><span id="more"></span><h2 id="一、C语言入门">一、C语言入门</h2><h3 id="一、hello-world">一、hello world</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>程序从main函数开始执行，且只有一个</p></li><li><p>return 返回0,int是整型，然后返回一个整型0</p></li><li><p>print f 打印函数   \n换行</p></li><li><p>include   包含一个名字叫stdio.h的文件</p></li></ol><h3 id="二、数据类型">二、数据类型</h3><p>char     字符  ’ ’   打印字符   %c打印字符格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int 整型    %d</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age = <span class="number">20</span>;<span class="comment">//%d</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%f–浮点型     %lf–double型   %p—以地址打印    %x—打印16进制</p><p>%c在C语言中代表字符型格式符</p><p>%s在C语言中代表字符串型格式符</p><h4 id="字符占用长度"><strong>字符占用长度</strong></h4><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">字节（8个比特位）</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">long long</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8</td></tr></tbody></table><h3 id="三、键盘输入函数-scanf">三、键盘输入函数-----scanf()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入求和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入两个数\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;num,&amp;num1 );</span><br><span class="line">sum = num + num1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、变量的作用域和生命周期">四、变量的作用域和生命周期</h3><p><strong>作用域（scope）</strong>，程序设计概念，通常来说一段代码中所用到的名字并不是总是有效的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><p><strong>生命周期</strong>，变量的生命周期是指变量的创建到变量销毁的一个时间段</p><h3 id="五、常量">五、常量</h3><h4 id="1-字面常量">1.字面常量</h4><ul><li>const修饰的常变量</li></ul><p>​            将变量转换为不可变的固定常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>​            相当于java的fianily</p><ul><li><p>define定义的标识符常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, MAX);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-枚举常量">2.枚举常量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MALE,</span><br><span class="line">FEMALA,</span><br><span class="line">SECRET</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//enum Sex s=MALE;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, MALE);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, FEMALA);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, SECRET);<span class="comment">//2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字符串的打印">3.字符串的打印</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**  \0  表示字符串的结束符</p><p>1.strlen()–字符串统计函数  string length–计算字符串长度</p><p><img src="%E5%9B%BE/images/image-20230402145454188.png" alt></p><p>eg:arr2的abc后面放着一个随机值–直到0为止</p><h2 id="二、循环语句">二、循环语句</h2><h3 id="1、if–else">1、if–else</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你要好好学习吗(1/0)&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> (input == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要好好学习&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不要&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-while循环">2.while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> line = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (line &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲了一行代码%d\n&quot;</span>,line);</span><br><span class="line">line++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你已经是大牛啦&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="三、方法">三、方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z = x + y;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num1= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">sum = Add(num1, num2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果是%d&quot;</span>, sum);</span><br><span class="line">sum = Add(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sun = %d\n&quot;</span>, sum);</span><br><span class="line">       <span class="comment">//用户输入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;c,%d)</span><br><span class="line">        <span class="type">int</span> sum=Add(c,d)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sun)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>add()自定义函数</p><h2 id="四、数组">四、数组</h2><p>int arr[10]={1,2,3,4,5}</p><p>打印数组所有元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%D&quot;</span>,arr[i]);</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、异或非">五、异或非</h2><p><strong>^</strong>  异或：对应的二进制相同则为0，相异则为1</p><p><strong>给你们句口诀与：全一则一 或：有一则一 异或：有一则一全一则零</strong></p><h2 id="六、常见关键字">六、常见关键字</h2><p><img src="/posts/9ec06885/image-20230523100459368-1684807509870-1.png" alt="image-20230523100459368"></p><h3 id="typedef关键字">typedef关键字</h3><p>typedef:类型定义，这里理解为类型重命名</p><p>例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> unit;</span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num =<span class="number">0</span>;</span><br><span class="line">uint num1=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static关键字">static关键字</h3><p>用来修饰变量和函数的</p><p>1.修饰局部变量-称为静态局部变量</p><p>2.修饰全局变量-称为静态全局变量</p><p>3.修饰函数-称为静态函数</p><p>①</p><p><img src="/posts/9ec06885/image-20230523103200606.png" alt="image-20230523103200606"></p><p>修饰局部变量时改变了变量存储位置，修饰全局变量时这个属性变成内部链接属性，其他源文件不能使用</p><h3 id="register关键字–寄存器">register关键字–寄存器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> num=<span class="number">3</span><span class="comment">//register建议3存放在寄存器中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="define–定义常量和宏">define–定义常量和宏</h3><p><strong>宏</strong>是有参数的–宏是完成替换的</p><p>define ADD(x,y) （x+y）【无类型的】</p><p>​             宏名 宏参数 宏体</p><h2 id="7-指针">7.指针</h2><p><img src="/posts/9ec06885/image-20240313205843838.png" alt="image-20240313205843838"></p><h3 id="1-内存">1.内存</h3><p>内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的。<br>所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。</p><p><img src="/posts/9ec06885/image-20240309184905328.png" alt="image-20240309184905328"></p><p>指针就是地址----使用指针就是使用地址</p><p>指针的大小是相同的</p><p>指针需要多大空间，取决于地址的存储需要多大空间</p><h3 id="2-指针是什么？">2.指针是什么？</h3><p>在计算机科学中，指针( Pointer )是编程语言中的一个对象，利用地址，它的值直接指向( points to )存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针&quot;。意思是通过它能找到以它为地址的内存单元。</p><p>&amp;a取到的地址是a四个字节的第一个字节</p><p>存放地址的变量叫指针变量</p><p>指针在32位平台为4个字节，64位为8个字节</p><p>%p—打印地址</p><h3 id="3-指针和指针类型">3.指针和指针类型</h3><ol><li><p>指针类型决定了：指针解引用的权限有多大</p></li><li><p>指针类型决定了，指针走一步能走多远（步长）</p></li><li><p>int+4,char+1,double+8字节</p></li></ol><h3 id="4-野指针">4.野指针</h3><p>野指针是指指向位置是不可知的（随机的，不正确的，没有明确限制的）</p><h4 id="1-指针未初始化-image-20240310161410537">1.指针未初始化 <img src="/posts/9ec06885/image-20240310161410537.png" alt="image-20240310161410537"></h4><h4 id="2-越界访问">2.越界访问</h4><p><img src="/posts/9ec06885/image-20240310161842007.png" alt="image-20240310161842007"></p><h4 id="3-指针指向的空间释放">3.指针指向的空间释放</h4><h3 id="5-如何规避野指针">5.如何规避野指针</h3><ol><li>指针初始化</li><li>小心指针越界</li><li>指针指向空间释放即使置NULL</li><li>指针使用之前检查有效性</li></ol><h3 id="6-指针的运算">6.指针的运算</h3><h4 id="1-指针±整数">1.指针±整数</h4><p><img src="/posts/9ec06885/image-20240310165229404.png" alt="image-20240310165229404"></p><h4 id="2-指针-指针">2.指针-指针</h4><p><img src="/posts/9ec06885/image-20240310165527969.png" alt="image-20240310165527969"></p><h4 id="3-指针-指针得到的是指针之间元素的个数">3.<strong>指针-指针得到的是指针之间元素的个数</strong></h4><p>​      <img src="/posts/9ec06885/image-20240310172326316.png" alt="image-20240310172326316"></p><h4 id="4-指针的关系运算">4.指针的关系运算</h4><p><img src="/posts/9ec06885/image-20240310173749434.png" alt="image-20240310173749434"></p><h3 id="7-指针与数组">7.指针与数组</h3><p>数组名是数组首元素的地址</p><h3 id="8-二级指针">8.二级指针**</h3><h3 id="9-指针数组">9.指针数组</h3><p>存放指针的数组—int* p[5];//整型指针的数组</p><p><img src="/posts/9ec06885/image-20240311164918262.png" alt="image-20240311164918262"></p><p>结论:指针数组是一个数组,每个数组元素存放一个指针变量</p><h3 id="10-数组指针">10.数组指针</h3><p>int (*p)[5];</p><p><img src="/posts/9ec06885/image-20240311165726371.png" alt="image-20240311165726371"></p><p>结论:数组指针是一个指针,它指向的是一个数组</p><p><img src="/posts/9ec06885/image-20240311170512924.png" alt="image-20240311170512924"></p><h3 id="11-解引用">11.解引用</h3><p>在一个地址前面加上取值运算符“*”，即把一个地址取出来，这种操作就叫解引用</p><h3 id="12-二维指针数组">12.二维指针数组</h3><p><img src="/posts/9ec06885/image-20240312134439175.png" alt="image-20240312134439175"></p><p><img src="/posts/9ec06885/image-20240312134600152.png" alt="image-20240312134600152"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//二维数组解引用</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            arr[i][j]=k++;<span class="comment">//将数组自动赋值</span></span><br><span class="line">        <span class="comment">//    printf(&quot;%d\n&quot;,arr[i][j]);//打印</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(arr+1):%p\n&quot;</span>,*(arr+<span class="number">1</span>));<span class="comment">//打印二维数组第二行首个地址值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1]:%p\n&quot;</span>,arr[<span class="number">1</span>]);<span class="comment">//打印二维数组首个地址值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[1][0]:%p\n&quot;</span>,&amp;arr[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//取出第二行第0个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(arr+1):%d\n&quot;</span>,**(arr+<span class="number">1</span>));<span class="comment">//取出第二行第一个数组值--打开第二行第一个数组盒子</span></span><br><span class="line">    <span class="comment">//&amp;是取地址，*取值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(*(arr+1)+3):%d\n&quot;</span>,**(arr+<span class="number">1</span>)+<span class="number">3</span>);<span class="comment">//将打印二维数组第二行首个地址值+3--然后打开这个盒子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][3]:%d\n&quot;</span>,arr[<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-数组指针和二维数组">13.数组指针和二维数组</h3><p><img src="/posts/9ec06885/image-20240312140103106.png" alt="image-20240312140103106"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>]=arr;<span class="comment">//*P的位置是一个空，相当于[][3],将arr赋给他时*p就变成2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(p+1):%d\n&quot;</span>,**(p+<span class="number">1</span>));<span class="comment">//p+1相当于跳到第二行，*p+1相当于第二行的地址，**p+1相当于取第一位的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(arr+1):%d\n&quot;</span>,**(arr+<span class="number">1</span>));<span class="comment">//同上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][0]:%d\n&quot;</span>,arr[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//打印第二行第一个</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(p+1):%d\n&quot;</span>,*(*(p+<span class="number">1</span>)+<span class="number">2</span>));<span class="comment">//右移动2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**(arr+1):%d\n&quot;</span>,**(arr+<span class="number">1</span>)+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][0]:%d\n&quot;</span>,arr[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-void指针–无类型指针">14. void指针–无类型指针</h3><p>void指针我们把它称之为通用指针,就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。</p><p><img src="/posts/9ec06885/image-20240312160924732.png" alt="image-20240312160924732"></p><h3 id="15-null指针–如果一个指针不指向任何一个数据就是空指针">15. null指针–如果一个指针不指向任何一个数据就是空指针</h3><p>当你还不清楚要将指针初始化为什么地址时，请将它初始化NULL;在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。</p><h3 id="16-指向指针的指针（二级指针-–">16. 指向指针的指针（二级指针)–**</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span> **pp=&amp;p;</span><br><span class="line">pr(a)</span><br><span class="line">pr(*P)</span><br><span class="line">pr(**P)</span><br></pre></td></tr></table></figure><h3 id="17-指向指针的指针和指针数组">17. 指向指针的指针和指针数组</h3><ul><li><p>避免重复分配内存</p></li><li><p>只需要进行一次修改</p><p><img src="/posts/9ec06885/image-20240312171433063.png" alt="image-20240312171433063"></p></li></ul><h3 id="18-数组指针和二维数组">18.数组指针和二维数组</h3><p><img src="/posts/9ec06885/image-20240312172653097.png" alt="image-20240312172653097"></p><p>将array的首地址交给p，p+1就跳到了第二列</p><p><img src="/posts/9ec06885/image-20240312173043329.png" alt="image-20240312173043329"></p><p><img src="/posts/9ec06885/image-20240312173750488.png" alt="image-20240312173750488"></p><h3 id="19-常量与指针">19.常量与指针</h3><p>const关键字可将变量变成只读</p><ul><li>指针可以修改为指向不同的常量</li><li>指针可以修改为指向不同的变量</li><li>可以通过解引用来读取指针指向的数据</li><li>不可以通过解引用修改指针指向的数据</li></ul><h4 id="1-常量指针">1.<strong>常量指针</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;num;</span><br></pre></td></tr></table></figure><ul><li><p>指向非常量的常量指针</p><p>——指针自身不可以被修改-</p><p>——指针指向的值可以被修改</p></li><li><p>指向常量的常量指针</p><p>一指针自身不可以被修改</p><p>一指针指向的值也不可以被修鸡</p></li></ul><p>const接近哪个哪个就不可以改变</p><p><img src="/posts/9ec06885/image-20240312181447885.png" alt="image-20240312181447885"></p><p><strong>指针指代的是常量</strong></p><h4 id="2-指向常量的常量指针"><strong>2.指向常量的常量指针</strong></h4><p><img src="/posts/9ec06885/image-20240312181504410.png" alt="image-20240312181504410"></p><p><img src="/posts/9ec06885/image-20240312181856194.png" alt="image-20240312181856194"></p><h3 id="20、malloc函数用法—">20、malloc函数用法—</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 动态数组---malloc函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fo</span><span class="params">(<span class="type">int</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    *q=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    int * p=(int *) malloc(4);</span></span><br><span class="line"><span class="comment">//    /*</span></span><br><span class="line"><span class="comment">//     * #include &lt;malloc.h&gt;必须加</span></span><br><span class="line"><span class="comment">//     * 4表示请求系统为本程序分配4个字节</span></span><br><span class="line"><span class="comment">//     * Malloc函数只有一个形参，并且为整型</span></span><br><span class="line"><span class="comment">//     * malloc函数只能返回第一个字节的地址</span></span><br><span class="line"><span class="comment">//     *这里分配了8个字节，地址占4个，整型占4个</span></span><br><span class="line"><span class="comment">//     * p是静态分配了4个字节，malloc是动态请求了4个字节</span></span><br><span class="line"><span class="comment">//     * fee(p)代表将p指向的内存给释放掉，但是p没有释放，只能等程序结束由其系统释放</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    *p=4;//*p代表的是一个int变量</span></span><br><span class="line"><span class="comment">//    free(p);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p =(<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">     *p=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    fo(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、函数">八、函数</h2><p>类型名  函数名(参数列表)</p><p>{</p><p>​        函数体</p><p>}</p><h3 id="作用："><strong>作用</strong>：</h3><ol><li>​避免了重复性操作</li><li>​有利于程序的模块化</li></ol><h4 id="1、函数声明">1、函数声明</h4><p><img src="/posts/9ec06885/image-20240312182939425.png" alt="image-20240312182939425"></p><h4 id="2-函数小案例1-控制台输入求1-2-3-…-n-1-n的和">2.函数小案例1----控制台输入求1+2+3+…(n-1)+n的和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//函数之初体验---控制台输入求1+2+3+...(n-1)+n的和</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sun</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> a,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">     sum= sun(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-函数小案例2">3.函数小案例2------</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        temp=a;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        temp =b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    temp= max(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值是：%d&quot;</span>,temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、参数和返回值">2、参数和返回值</h3><p><strong>形参</strong>：形式参数–函数定义时写的参数</p><p><strong>实参</strong>：实际参数–函数调用时传的实际值</p><p><strong>传值</strong>：</p><p><strong>传址</strong>：</p><p><strong>可变参数</strong>----include &lt;stdarg.h&gt;</p><h3 id="3、指针函数">3、指针函数</h3><p>用指针变量作为函数的返回值，就是指针函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 指针函数--用户输入给东西</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fluth</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:<span class="keyword">return</span> <span class="string">&quot;鼠标&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:<span class="keyword">return</span> <span class="string">&quot;鼠标1&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:<span class="keyword">return</span> <span class="string">&quot;鼠标2&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="string">&quot;狗屁&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> input;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字母：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, fluth(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、函数指针–指向函数的指针">4、函数指针–指向函数的指针</h3><p><img src="/posts/9ec06885/image-20240313141438459.png" alt="image-20240313141438459"></p><p><img src="/posts/9ec06885/image-20240313142022453.png" alt="image-20240313142022453"></p><p>等价</p><p><img src="/posts/9ec06885/image-20240313142059456.png" alt="image-20240313142059456"></p><h3 id="5、函数指针作为参数">5、函数指针作为参数</h3><p><img src="/posts/9ec06885/image-20240313143044874.png" alt="image-20240313143044874"></p><h2 id="九、结构体">九、结构体</h2><h3 id="struct关键字"><strong>struct关键字</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 结构体---struct</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> socre;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>=</span>&#123;<span class="number">21</span>,<span class="number">59.9</span>,<span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2 f %c\n&quot;</span>,st.age,st.socre,st.sex );</span><br><span class="line"><span class="comment">//赋值读取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st2</span>;</span></span><br><span class="line">    st2.age=<span class="number">20</span>;</span><br><span class="line">    st2.socre=<span class="number">60</span>;</span><br><span class="line">    st2.sex=<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2f %c\n&quot;</span>,st2.sex,st2.socre,st2.sex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过指针读取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Student</span> *<span class="title">pst</span>=</span>&amp;st;</span><br><span class="line">    pst -&gt;age=<span class="number">88</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pst-&gt;age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pst-&gt;age 在计算机内部会被转化成(*pst).age</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量名-&gt;成员名﹐在计算机内部会被转化成(*指针变量名).成员名的方式来执行</p><p>pst -&gt; age 含义： pst所指向的那个结构体变量中的age成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 结构体---struct</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> socre;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>=</span>&#123;<span class="number">21</span>,<span class="number">59.9</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&quot;小李&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2lf %c %s\n&quot;</span>,st.age,st.socre,st.sex ,st.name);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st2</span>;</span></span><br><span class="line">    st2.age=<span class="number">20</span>;</span><br><span class="line">    st2.socre=<span class="number">60</span>;</span><br><span class="line">    st2.sex=<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(st2.name,<span class="string">&quot;小米&quot;</span>);<span class="comment">//字符串修改</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2lf %c %s\n&quot;</span>,st2.sex,st2.socre,st2.sex,st2.name);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">Student</span> *<span class="title">pst</span>=</span>&amp;st;</span><br><span class="line">    pst -&gt;age=<span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,pst-&gt;age,pst-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小案例1–冒泡排序">小案例1–冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">               t=a[j];</span><br><span class="line">               a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">               a[j+<span class="number">1</span>]=t;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    sort(a,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小案例二–用户输入成绩并排序">小案例二–用户输入成绩并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 动态构造存放学生信息的结构体数组</span></span><br><span class="line"><span class="comment">//   存放学生信息，然后按分数排序输出</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">parr</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生人数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    parr=(<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student)*len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生信息:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;age=:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;parr[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;score=:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;parr[i].score);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name=:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,parr[i].name);<span class="comment">//name本身就是数组类型的，已经有了首地址值，所以不用加&amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parr[j].score &gt; parr[j+<span class="number">1</span>].score)&#123;</span><br><span class="line">                t=parr[j];</span><br><span class="line">                parr[j]=parr[j+<span class="number">1</span>];</span><br><span class="line">                parr[j+<span class="number">1</span>]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请第%d个学生信息:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;age=:%d\n&quot;</span>,parr[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;score=:%d\n&quot;</span>,parr[i].score);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name=:%s\n&quot;</span>,parr[i].name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、枚举–enum">十、枚举–enum</h2><p>把一个事物的说有可能的取值都一一陈列出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekDay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> weekDay i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    f(Friday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码更安全，</p><h2 id="十一、进制">十一、进制</h2><p><strong>注意余数要倒序排序</strong></p><p>八进制前面要加0，最大是7</p><p>十六进制前面要加0 X，最大0-9，a-f</p><p>在汇编中:在数字后加字母B表示二进制数，加字母О表示八进制数，加字母D表示十进制数，加字母H表示十六进制数。</p><p><img src="/posts/9ec06885/image-20240317164814772.png" alt="image-20240317164814772"></p><p>进制转换----以15为例子</p><p><strong>2进制</strong>                                          1111</p><p>15%2商7余1                           1*2的3次方+1 *2的2次方+1 *1的1次方+1 *1的0次方=15</p><p>7%2商3余1</p><p>3%2商1余1</p><p>还余1</p><p>因此为1111</p><p><strong>8进制</strong>                                               17</p><p>15%8商1余7</p><p>因此为17                                       1*8+7</p><p><img src="/posts/9ec06885/image-20240317170620392.png" alt="image-20240317170620392"></p><p><img src="/posts/9ec06885/image-20240317170758864.png" alt="image-20240317170758864"></p><p><img src="/posts/9ec06885/image-20240317171116638.png" alt="image-20240317171116638"></p><p>%#X–打印16</p><p><img src="/posts/9ec06885/image-20240317172306481.png" alt="image-20240317172306481"></p><p><img src="/posts/9ec06885/image-20240317172350602.png" alt="image-20240317172350602"></p><p><img src="/posts/9ec06885/image-20240317172439413.png" alt="image-20240317172439413"></p><h2 id="十二、补码">十二、补码</h2><h3 id="原码">原码</h3><ul><li>​         也叫符号-绝对值码</li><li>​        最高位0表示正1表示负，其余二进制位是该数字的绝对值的二进制位</li></ul><p>​       <strong>例如</strong>：5</p><p>​       的二进制是101–1表示负数   因此源码是1101</p><ul><li>原码简单易懂加减运算复杂</li><li>存在加减乘除四种运算，</li><li>增加了CPU的复杂度</li><li>零的表示不唯一</li></ul><h3 id="反码">反码</h3><p>不用</p><h3 id="移码">移码</h3><ul><li>表示数值平移n位，n称为移码量</li><li>移码主要用于浮点数的阶码的存储</li></ul><h3 id="补码">补码</h3><ul><li><p><strong>十进制转二进制</strong></p><p>​       <em>正整数转二进制</em></p><p>​                 除2取余，直到商位0，余数倒叙排序</p><p>​      <em>负整数转二进制</em></p><p>​                  先求与该负数相对应的正整数二进制的,然后将所有位取反，末尾加1，不够位数时，左边补1</p><p>​                例如：-3</p><p>​                3的二进制011，取反变成100，然后末尾加1变成 101—》11111101</p></li><li><p><strong>零转二进制</strong></p><p>​       全是0</p></li><li><p><strong>二进制转十进制</strong></p><p>​     如果首位是0，则表明是正整数，按普通方法</p><p>​     如果首位是1，则表明是复数</p><p>​              将所有位取反，末尾加1，所得的数字就是该复数的绝对值    前面全补1</p></li></ul><h2 id="十三、位运算符">十三、位运算符</h2><h3 id="–按位与">&amp;–按位与</h3><p>​     &amp;&amp; 逻辑与 也叫并且（左边有右边是否相等-真1或假0）</p><p>​     &amp;将两个二进制进行一个相与</p><ul><li><p>​    1&amp;1=1</p></li><li><p>​    1&amp;0=0</p></li><li><p>0&amp;1=0</p></li><li><p>0&amp;0=0</p></li><li><p>eg: 5&amp;7=5    21&amp;7=5</p></li></ul><h3 id="—按位或">|—按位或</h3><p>​       ||逻辑与</p><p>​        |按位或</p><ul><li>​    1&amp;1=1</li><li>​    1&amp;0=1</li><li>0&amp;1=1</li><li>0&amp;0=0</li></ul><h3 id="按位取反">~   按位取反</h3><p>就是把变量按二进制取反</p><h3 id="按位异或">^  按位异或</h3><p>相同为0，不同为1</p><ul><li>​    1^0=1</li><li>​    0^1=1</li><li>1^1=0</li><li>0^0=0</li></ul><h3 id="按位左移">&lt;&lt;    按位左移</h3><p>​       i&lt;&lt;1    表示把i的所有二进制左移一位</p><p>​      左移n位相当于乘以2的n次方</p><p><img src="/posts/9ec06885/image-20240318171945054.png" alt="image-20240318171945054"></p><p>​      答案下面的快，</p><h3 id="按位右移">&gt;&gt;  按位右移</h3><p>​       i&gt;&gt;3    表示把i的所有二进制左移3位,左边一般都为0</p><p>​      右移n位相当于除以2的n次方</p><p>通过位运算符我们可以对数据精确到每一位</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;C语言基础&lt;/h1&gt;
&lt;p&gt;c语言是&lt;strong&gt;结构化&lt;/strong&gt;的程序设计----顺序结构，选择结构，循环结构&lt;/p&gt;</summary>
    
    
    
    <category term="c语言" scheme="http://lyay23.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="http://lyay23.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
